<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[编程思想：面向对象和面向过程]]></title>
    <url>%2F2019%2F06%2F16%2F%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[## 前言 什么是面向对象？面向过程又是什么？对于这编程界的两大思想，一直贯穿在我们学习和工作当中。也许我们心里对这两个概念有个模糊的理解，却又说不出个所以然。 一、面向过程 首先我们来认识下，什么是面向过程？如果咬文嚼字的话可以这样来理解，面向过程就是面向解决问题的过程进行编程。仔细思考一下，我们在学习和工作中，当我们去实现某项功能或完成某项任务时，是不是会不自觉的按部就班的罗列出我们要做的事情？而当我们按着我们罗列的步骤去解决问题时，实质上就是按照面向过程的思想去解决问题。我们罗列的步骤就是过程，按照步骤解决问题就是面向过程。 传统的面向过程的编程思想总结起来就八个字——自顶向下，逐步细化！ 实现步骤如下： 将要实现的功能描述为一个从开始到结束按部就班的连续的步骤（过程）； 依次逐步完成这些步骤，如果某一步的难度较大，又可以将该步骤再次细化为若干个子步骤，以此类推，一直到结束得到想要的结果； 程序的主体是函数，一个函数就是一个封装起来的模块，可以实现一定的功能，各个子步骤往往就是通过各个函数来完成的，从而实现代码的重用和模块化编程！ 面向过程，就是按照我们分析好了的步骤，按部就班的依次执行就行了！所以当我们用面向过程的思想去编程或解决问题时，首先一定要把详细的实现过程弄清楚。一旦过程设计清楚，代码的实现简直轻而易举。 二、面向对象 讨论完了面向过程，我们再来认识下面向对象。所谓的面向对象，就是在编程的时候尽可能的去模拟真实的现实世界，按照现实世界中的逻辑去处理一个问题，分析问题中参与其中的有哪些实体，这些实体应该有什么属性和方法，我们如何通过调用这些实体的属性和方法去解决问题。当我们使用面向对象进行编程时，一定要建立这样一个观念：万物皆对象！ 现实世界中，任何一个操作或者是业务逻辑的实现都需要一个实体来完成，也就是说，实体就是动作的支配者，没有实体，就肯定没有动作发生！ 有动词就一定有实现这个动作的实体！ 所谓的模拟现实世界，就是使计算机的编程语言在解决相关业务逻辑的方式，与真实的业务逻辑的发生保持一致！需要使每一个动作的背后都一个完成这个动作的实体！ 因为任何功能的实现都是依赖于一个具体的实体的“动作|操作|行动”，可以看作是一个又一个的实体在发挥其各自的“能力”并在内部进行协调有序的调用过程！ 当采用面向对象的思想解决问题时，可分为下面几步： 分析哪些动作是由哪些实体发出的； 定义这些实体，为其增加相应的属性和功能； 让实体去执行相应的功能或动作。 贴图加深理解 这张图里就把苹果放进冰箱这件事，分别用面向过程和面向对象来实现。面向过程更像是我们日常的行为一步一步的做，站在第一人称视角；而面向对象，把冰箱和人看成两个对象，赋予特定行为和属性，类似于第三人称视角。 三、面向对象和面向过程的比较在我们将面向过程和面向对象讨论完后，会明显的感觉两者之间有着很大的区别。面向过程简单直接，易于入门理解，模块化程度较低。而面向对象相对于面向过程较为复杂，不易理解，模块化程度较高。可总结为下面三点： 都可以实现代码重用和模块化编程，但是面对对象的模块化更深，数据更封闭，也更安全！因为面向对象的封装性更强！ 面对对象的思维方式更加贴近于现实生活，更容易解决大型的复杂的业务逻辑 从前期开发角度上来看，面对对象远比面向过程要复杂，但是从维护和扩展功能的角度上来看，面对对象远比面向过程要简单！ 如何选择面向对象还是面向过程，对于一个有着丰富开发经验的老手来说，这是个得心应手的过程。而对于一个新手而言，其实从两者的对比就可以看出，当我们的业务逻辑比较简单时，使用面向过程能更快的实现。但是当我们的业务逻辑比较复杂时，为了将来的维护和扩展，还是面向对象更为靠谱点！]]></content>
      <categories>
        <category>编程思想</category>
      </categories>
      <tags>
        <tag>面向对象和面向过程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3动画]]></title>
    <url>%2F2019%2F06%2F16%2Fcss3%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[## 什么是 CSS3 中的动画？ 动画是使元素从一种样式逐渐变化为另一种样式的效果。 您可以改变任意多的样式任意多的次数。 @keyframes 语法：@keyframes animationname {keyframes-selector {css-styles;}} 通过 @keyframes 规则，您能够创建动画。 创建动画的原理是，将一套 CSS 样式逐渐变化为另一套样式。 在动画过程中，您能够多次改变这套 CSS 样式。 以百分比来规定改变发生的时间，或者通过关键词 “from” 和 “to”，等价于 0% 和 100%。 0% 是动画的开始时间，100% 动画的结束时间。 为了获得最佳的浏览器支持，您应该始终定义 0% 和 100% 选择器。 CSS3 动画属性 实例运行名为 myfirst 的动画，其中设置了所有动画属性：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; div &#123; width: 100px; height: 100px; background: red; position: relative; animation-name: myfirst; animation-duration: 5s; animation-timing-function: linear; animation-delay: 2s; animation-iteration-count: infinite; /* 规定动画应该无限次播放。 */ animation-direction: alternate; /*动画应该轮流反向播放。*/ animation-play-state: running; /*规定动画正在播放。*/ &#125; @keyframes myfirst &#123; 0% &#123; background: red; left: 0px; top: 0px; &#125; 25% &#123; background: yellow; left: 200px; top: 0px; &#125; 50% &#123; background: blue; left: 200px; top: 200px; &#125; 75% &#123; background: green; left: 0px; top: 200px; &#125; 100% &#123; background: red; left: 0px; top: 0px; &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 另外一种简洁写法： 1234div&#123; animation: myfirst 5s linear 2s infinite alternate;&#125;]]></content>
      <categories>
        <category>H5/C3</category>
      </categories>
      <tags>
        <tag>css3动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis与mysql的区别和使用]]></title>
    <url>%2F2019%2F06%2F13%2Fredis%E4%B8%8Emysql%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[## 区别 类型 redis是一个key-value存储系统,是nosql,即非关系型数据库,和memcached都是缓存数据库. mysql是关系型数据库 存储 redis用于存储使用相对频繁的数据到内存中, mysql用于存放持久化数据到磁盘中 速度 redis读取速度快 mysql相对速度较慢 数据类型 redis数据类型:字符串类型（string），散列类型（hash），列表类型（list），集合类型（set），有序集合类型（zset） mysql数据类型,大致三类:数值,日期,字符使用一般来说，mysql用于写入和更新，redis用于读取。 这样就说 mysql-&gt;redis的同步用的比较多。 mysql作为数据持久化和管理比redis好太多，redis大多只用来做 数据读取缓存、队列、锁、等等的使用. 因为需求的不同，要根据具体业务场景去选型,一般都是配合使用.]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs连接mysql]]></title>
    <url>%2F2019%2F06%2F11%2Fnodejs%E8%BF%9E%E6%8E%A5mysql%2F</url>
    <content type="text"><![CDATA[## nodejs连接mysql 想要成为一个全栈工程师，自然需要会后端，那nodejs连接mysql就更不能不会了。 首先安装sql依赖：npm i sql 编写代码连接 1234567891011121314151617181920212223242526const mysql = require('mysql')// 创建链接对象const con = mysql.createConnection(&#123; host: 'localhost', user: 'root', password: '123456', port: '3306', database: 'myblog'&#125;)// 开始链接con.connect()// 执行 sql 语句const sql = 'select * from users;'con.query(sql,(err,result)=&gt; &#123; if(err)&#123; console.error(err) return &#125; console.log(result)&#125;)// 关闭链接con.end() 运行 ：node index.js 如果遇到报错： Client does not support authentication protocol requested by server 可看这篇文章:连接MySQL报错：Client does not support authentication protocol requested by server]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>nodejs连接mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[连接MySQL报错：Client does not support authentication protocol requested by server]]></title>
    <url>%2F2019%2F06%2F11%2F%E8%BF%9E%E6%8E%A5MySQL%E6%8A%A5%E9%94%99%EF%BC%9AClient%20does%20not%20support%20authentication%20protocol%20requested%20by%20server%2F</url>
    <content type="text"><![CDATA[## 在使用nodejs连接MySQL报错： Client does not support authentication protocol requested by server; consider upgrading MySQL client大概意思是：客户端不支持服务器请求的身份验证协议;考虑升级MySQL客户端 原因：将mysql升级到5.x版本后，用客户端登录时出现了 Client does not support authentication protocol requested by server错误，是由于新旧版本的mysql的密码算法不同引起 解决方法如下：登录mysql，输入如下命令即可。 12alter user 'root'@'localhost' identified with mysql_native_password by '123456';flush privileges; 这样就能解决这个问题了。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL报错</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP的三次握手与四次挥手 TCP]]></title>
    <url>%2F2019%2F06%2F09%2FTCP%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%2F</url>
    <content type="text"><![CDATA[## TCP的位置 TCP工作在网络OSI的七层模型中的第四层——Transport层，IP在第三层——Network层，ARP在第二层——Data Link层； 在第二层上的数据，我们把它叫Frame，在第三层上的数据叫Packet，第四层的数据叫Segment。 数据从应用层发下来，会在每一层都会加上头部信息，进行封装，然后再发送到数据接收端。这个基本的流程你需要知道，就是每个数据都会经过数据的封装和解封装的过程。 在OSI七层模型中，每一层的作用和对应的协议如下： 三次握手第一次握手：主机A发送位码为syn＝1,随机产生seq number=x的数据包到服务器，客户端进入SYN_SEND状态，等待服务器的确认；主机B由SYN=1知道，A要求建立联机； 第二次握手：主机B收到请求后要确认联机信息，向A发送ack number(主机A的seq+1),syn=1,ack=1,随机产生seq=y的包,此时服务器进入SYN_RECV状态; 第三次握手：主机A收到后检查ack number是否正确，即第一次发送的seq number+1,以及位码ack是否为1，若正确，主机A会再发送ack number(主机B的seq+1),ack=1，主机B收到后确认seq值与ack=1则连接建立成功。客户端和服务器端都进入ESTABLISHED状 态，完成TCP三次握手。 TCP位码,有6种标示:SYN(synchronous建立联机) ACK(acknowledgement 确认) PSH(push传送) FIN(finish结束) RST(reset重置) URG(urgent紧急) Sequence number(顺序号码) Acknowledge number(确认号码) 四次挥手第一次挥手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了； 第二次挥手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我也没有数据要发送了，可以进行关闭连接了； 第三次挥手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入CLOSE_WAIT状态； 第四次挥手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。 问题1.为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？ 虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。 2.client发送完最后一个ack之后，进入time_wait状态，但是他怎么知道server有没有收到这个ack呢？莫非sever也要等待一段时间，如果收到了这个ack就close，如果没有收到就再发一个fin给client？这么说server最后也有一个time_wait哦？求解答！ 因为网络原因，主动关闭的一方发送的这个ACK包很可能延迟，从而触发被动连接一方重传FIN包。极端情况下，这一去一回，就是两倍的MSL时长。如果主动关闭的一方跳过TIME_WAIT直接进入CLOSED，或者在TIME_WAIT停留的时长不足两倍的MSL，那么当被动 关闭的一方早先发出的延迟包到达后，就可能出现类似下面的问题：1.旧的TCP连接已经不存在了，系统此时只能返回RST包2.新的TCP连接被建立起来了，延迟包可能干扰新的连接，这就是为什么time_wait需要等待2MSL时长的原因。]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[一张图理清Vue中的生命周期和钩子函数]]></title>
    <url>%2F2019%2F06%2F04%2F%E4%B8%80%E5%BC%A0%E5%9B%BE%E7%90%86%E6%B8%85Vue%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[## 前言 Vue 框架的入口就是 Vue 实例，其实就是框架中的 view model ，它包含页面中的业务处理逻辑、数据模型等，它的生命周期中有多个事件钩子，让我们在控制整个Vue实例的过程时更容易形成好的逻辑。 贴图下面的图片是在官方文档的图片上进行了解释说明，帮大家更好的理解这张图。 代码贴上一个小案例辅助理解 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src="lib/vue.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="app"&gt; &lt;input type="button" value="修改" @click="msg='no'"&gt; &lt;h3 id="h3"&gt;&#123;&#123; msg &#125;&#125;&lt;/h3&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el:'#app', data:&#123; msg:'ok' &#125;, methods:&#123; show()&#123; console.log('执行了show方法'); &#125; &#125;, beforeCreate()&#123;// 这是我们遇到的第一个生命周期函数，表示实例完全被创建出来之前，会执行它// console.log(this.msg);// this.show() // 注意： 在 beforeCreate 生命周期函数执行的时候，data 和 methods 中的 数据都还没有没初始化 &#125;, created()&#123; // 这是遇到的第二个生命周期函数 console.log(this.msg); this.show() &#125;, beforeMount()&#123; // 这是遇到的第3个生命周期函数，表示 模板已经在内存中编辑完成了，但是尚未把 模板渲染到 页面中 console.log(document.getElementById('h3').innerText); // 在 beforeMount 执行的时候，页面中的元素，还没有被真正替换过来，只是之前写的一些模板字符串 &#125;, mounted()&#123; // 这是遇到的第4个生命周期函数，表示，内存中的模板，已经真实的挂载到了页面中，用户已经可以看到渲染好的页面了 console.log(document.getElementById('h3').innerText); // 注意： mounted 是 实例创建期间的最后一个生命周期函数，当执行完 mounted 就表示，实例已经被完全创建好了，此时， // 03如果没有其它操作的话，这个实例，就静静的 躺在我们的内存中，一动不动 &#125;, // 接下来的是运行中的两个事件 beforeUpdate()&#123; // 这时候，表示 我们的界面还没有被更新【数据被更新了吗？ 数据肯定被更新了】 console.log('界面上元素的内容：'+document.getElementById('h3').innerText); console.log(' data中的msg数据是：'+ this.msg); // 得出结论： 当执行 beforeUpdate 的时候，页面中的显示的数据，还是旧的，此时 data 数据是最新的，页面尚未和 最新的数据保持同步 &#125;, updated()&#123; console.log('界面上元素的内容：'+document.getElementById('h3').innerText); console.log(' data中的msg数据是：'+ this.msg); &#125; &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>生命周期和钩子函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新版本vue中没有dev-server.js文件，如何进行后台数据模拟？]]></title>
    <url>%2F2019%2F06%2F04%2F%E6%96%B0%E7%89%88%E6%9C%ACvue%E4%B8%AD%E6%B2%A1%E6%9C%89dev-server.js%E6%96%87%E4%BB%B6%EF%BC%8C%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%90%8E%E5%8F%B0%E6%95%B0%E6%8D%AE%E6%A8%A1%E6%8B%9F%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[## 前言 今天在写一个vue项目时，发现build中并没有dev-server.js文件，那如何进行后台数据模拟呢？ 解决方法最新的vue里dev-server.js被替换成了webpack-dev-conf.js 在模拟后台数据的时候直接在webpack-dev-conf.js文件中修改 第一步:在const portfinder = require(‘portfinder’)后面添加1234const express = require('express') const app = express()//请求servervar appData = require('../data.json')//加载本地数据文件var seller = appData.seller//获取对应的本地数据var goods = appData.goods var ratings = appData.ratings var apiRoutes = express.Router() app.use('/api', apiRoutes)//通过路由请求数据 第二步：找到devServer,在里面加上before（）方法1234567891011121314151617181920212223242526272829303132333435363738devServer: &#123; clientLogLevel: 'warning', historyApiFallback: true, hot: true, compress: true, host: HOST || config.dev.host, port: PORT || config.dev.port, open: config.dev.autoOpenBrowser, overlay: config.dev.errorOverlay ? &#123; warnings: false, errors: true &#125; : false, publicPath: config.dev.assetsPublicPath, proxy: config.dev.proxyTable, quiet: true, // necessary for FriendlyErrorsPlugin watchOptions: &#123; poll: config.dev.poll, &#125;, //第二步找到devServer,在里面添加before(app) &#123; app.get('/api/seller', (req, res) =&gt; &#123; res.json(&#123; errno: 0, data: seller &#125;)//接口返回json数据，上面配置的数据seller就赋值给data请求后调用 &#125;), app.get('/api/goods', (req, res) =&gt; &#123; res.json(&#123; errno: 0, data: goods &#125;) &#125;), app.get('/api/ratings', (req, res) =&gt; &#123; res.json(&#123; errno: 0, data: ratings &#125;) &#125;)&#125; 注意：要确保项目根目录有data.json，这里提供一个json数据1234567891011121314151617181920212223242526272829303132333435363738&#123; "seller": &#123; "name": "粥品香坊（回龙观）", "description": "蜂鸟专送", "deliveryTime": 38, "score": 4.2, "serviceScore": 4.1, "foodScore": 4.3, "rankRate": 69.2, "minPrice": 20, "deliveryPrice": 4, "ratingCount": 24, "sellCount": 90, "bulletin": "粥品香坊其烹饪粥料的秘方源于中国千年古法，在融和现代制作工艺，由世界烹饪大师屈浩先生领衔研发。坚守纯天然、0添加的良心品质深得消费者青睐，发展至今成为粥类的引领品牌。是2008年奥运会和2013年园博会指定餐饮服务商。", "supports": [ &#123; "type": 0, "description": "在线支付满28减5" &#125;, &#123; "type": 1, "description": "VC无限橙果汁全场8折" &#125;, &#123; "type": 2, "description": "单人精彩套餐" &#125;, &#123; "type": 3, "description": "该商家支持发票,请下单写好发票抬头" &#125;, &#123; "type": 4, "description": "已加入“外卖保”计划,食品安全保障" &#125; ], "avatar": "http://static.galileo.xiaojukeji.com/static/tms/seller_avatar_256px.jpg", "pics": [ "http://fuss10.elemecdn.com/8/71/c5cf5715740998d5040dda6e66abfjpeg.jpeg?imageView2/1/w/180/h/180", "http://fuss10.elemecdn.com/b/6c/75bd250e5ba69868f3b1178afbda3jpeg.jpeg?imageView2/1/w/180/h/180", "http://fuss10.elemecdn.com/f/96/3d608c5811bc2d902fc9ab9a5baa7jpeg.jpeg?imageView2/1/w/180/h/180", "http://fuss10.elemecdn.com/6/ad/779f8620ff49f701cd4c58f6448b6jpeg.jpeg?imageView2/1/w/180/h/180" ], "infos": [ "该商家支持发票,请下单写好发票抬头", "品类:其他菜系,包子粥店", "北京市昌平区回龙观西大街龙观置业大厦底商B座102单元1340", "营业时间:10:00-20:30" ] &#125;&#125;]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>dev-server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mock数据时，http___localhost_8080_#_api_goods 无法访问到数据]]></title>
    <url>%2F2019%2F06%2F04%2Fmock%E6%95%B0%E6%8D%AE%E6%97%B6%EF%BC%8Chttp___localhost_8080_%23_api_goods%20%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE%E5%88%B0%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[## 前言 在mock数据时，http://localhost:8080/#/api/goods 无法访问到数据，经过查询发现是将build目录下的webpack.dev.conf.js文件出问题了 解决将build目录下的webpack.dev.conf.js文件改为： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102'use strict'const utils = require('./utils')const webpack = require('webpack')const config = require('../config')const merge = require('webpack-merge')const baseWebpackConfig = require('./webpack.base.conf')const HtmlWebpackPlugin = require('html-webpack-plugin')const FriendlyErrorsPlugin = require('friendly-errors-webpack-plugin')const portfinder = require('portfinder') const appData = require('../data.json')const seller = appData.sellerconst goods = appData.goodsconst ratings = appData.ratings const devWebpackConfig = merge(baseWebpackConfig, &#123; module: &#123; rules: utils.styleLoaders(&#123; sourceMap: config.dev.cssSourceMap, usePostCSS: true &#125;) &#125;, // cheap-module-eval-source-map is faster for development devtool: config.dev.devtool, // these devServer options should be customized in /config/index.js devServer: &#123; before(app) &#123; app.get('/api/seller', function(req, res) &#123; res.json(&#123; errno: 0, data: seller &#125;) &#125;); app.get('/api/goods', function(req, res) &#123; res.json(&#123; errno: 0, data: goods &#125;) &#125;); app.get('/api/ratings', function(req, res) &#123; res.json(&#123; errno: 0, data: ratings &#125;) &#125;); &#125;, clientLogLevel: 'warning', historyApiFallback: true, hot: true, host: process.env.HOST || config.dev.host, port: process.env.PORT || config.dev.port, open: config.dev.autoOpenBrowser, overlay: config.dev.errorOverlay ? &#123; warnings: false, errors: true, &#125; : false, publicPath: config.dev.assetsPublicPath, proxy: config.dev.proxyTable, quiet: true, // necessary for FriendlyErrorsPlugin watchOptions: &#123; poll: config.dev.poll, &#125; &#125;, plugins: [ new webpack.DefinePlugin(&#123; 'process.env': require('../config/dev.env') &#125;), new webpack.HotModuleReplacementPlugin(), new webpack.NamedModulesPlugin(), // HMR shows correct file names in console on update. new webpack.NoEmitOnErrorsPlugin(), // https://github.com/ampedandwired/html-webpack-plugin new HtmlWebpackPlugin(&#123; filename: 'index.html', template: 'index.html', inject: true &#125;), ]&#125;) module.exports = new Promise((resolve, reject) =&gt; &#123; portfinder.basePort = process.env.PORT || config.dev.port portfinder.getPort((err, port) =&gt; &#123; if (err) &#123; reject(err) &#125; else &#123; // publish the new Port, necessary for e2e tests process.env.PORT = port // add port to devServer config devWebpackConfig.devServer.port = port // Add FriendlyErrorsPlugin devWebpackConfig.plugins.push(new FriendlyErrorsPlugin(&#123; compilationSuccessInfo: &#123; messages: [`Your application is running here: http://$&#123;config.dev.host&#125;:$&#123;port&#125;`], &#125;, onErrors: config.dev.notifyOnErrors ? utils.createNotifierCallback() : undefined &#125;)) resolve(devWebpackConfig) &#125; &#125;)&#125;) 注意如果devServer下面的before(app)里面的内容要根据自己数据名称进行修改，修改时文件头部const也要跟着一起修改。]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>mock数据</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue组件间传值]]></title>
    <url>%2F2019%2F06%2F04%2FVue%E7%BB%84%E4%BB%B6%E9%97%B4%E4%BC%A0%E5%80%BC%2F</url>
    <content type="text"><![CDATA[# Vue组件间传值 父组件向子组件传递数据在 Vue 中，通过 props 向子组件传递数据。 子组件部分：123456789&lt;template&gt; &lt;header class="header"&gt; &lt;div id="1ogo"&gt;&#123;&#123;1ogo&#125;&#125;&lt;/div&gt; &lt;ul class="nav"&gt; &lt;li v-for="nav in navs"&gt;&#123;&#123;nav.li&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/header&gt;&lt;/template&gt; 这是 header.vue 的 HTML 部分，logo 是在 data 中定义的变量。如果需要从父组件获取 logo 的值，就需要使用 props: [‘logo’] 123456789101112&lt;script&gt; export default&#123; name:'headerDiv', data()&#123; return&#123; navs:[ &#123;1i:'主页'&#125;,&#123;1i:'日志'&#125;,&#123;1i:'说说'&#125;,&#123;1i:'主页'&#125;,&#123;1i:'相册&#125; ] &#125;, props:['logo'] &#125;&lt;/script&gt; 父组件部分：12345&lt;template&gt; &lt;div id="app"&gt; &lt;HeaderDiv :logo="logoMsg"&gt;&lt;/HeaderDiv&gt; &lt;/div&gt;&lt;/template&gt; 在调用组件的时候，使用 v-bind 将 logo 的值绑定为 App.vue 中定义的变量 logoMsg 1234567891011121314&lt;script&gt; import HeaderDiv from'./components/header' export default&#123; name:'app', data()&#123; return&#123; logoMsg:'WiseWrong' &#125; &#125;, components:&#123; HeaderDiv &#125; &#125;&lt;/script&gt; 然后就能将App.vue中 logoMsg 的值传给 header.vue 了： 子组件向父组件传递数据子组件主要通过事件传递数据给父组件 子组件部分12345678910&lt;template&gt; &lt;section&gt; &lt;div class="login"&gt; &lt;label&gt; &lt;span&gt;用户名：&lt;/span&gt; &lt;input v-model="username"@change="setUser"/&gt; &lt;/label&gt; &lt;div&gt; &lt;/section&gt;&lt;/template&gt; 这是 login.vue 的 HTML 部分，当的值发生变化的时候，将 username 传递给 App.vue首先声明一个了方法 setUser，用 change 事件来调用 setUser123456789101112131415&lt;script&gt; export default&#123; name:' login', data()&#123; return&#123; username:'' &#125; &#125;, methods:&#123; setUser: function()&#123; this.$emit(' transferUser', this. username) &#125; &#125; &#125;&lt;/script&gt; 在 setUser 中，使用了 $emit 来遍历 transferUser 事件，并返回 this.username其中 transferUser 是一个自定义的事件，功能类似于一个中转，this.username 将通过这个事件传递给父组件 父组件部分123456&lt;template&gt; &lt;div id="app"&gt; &lt;LoginDiv @transferUser="getUser"&gt;&lt;/LoginDiv&gt; &lt;p&gt;用户名为：&#123;&#123;user&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt; 在父组件 App.vue 中，声明了一个方法 getUser，用 transferUser 事件调用 getUser 方法，获取到从子组件传递过来的参数 username1234567891011121314151617&lt;script&gt; import LoginDiv from'./components/login' export default &#123; name:' app', data()&#123; return&#123; user:'' &#125; &#125;, methods:&#123; getUser(msg)&#123; this. user=msg &#125;, components:&#123; LoginDiv &#125; &#125;&lt;/script&gt; getUser 方法中的参数 msg 就是从子组件传递过来的参数 username]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>组件间传值</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js 2.0 中#$on与$emit如何理解使用]]></title>
    <url>%2F2019%2F06%2F04%2FVue.js%202.0%20%E4%B8%AD%23%24on%E4%B8%8E%24emit%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[## 先看看官方文档的解释 vm.$on( event, callback ) 参数 {string | Array} event (数组只在 2.2.0+ 中支持) {Function} callback 用法 监听当前实例上的自定义事件。事件可以由vm.$emit触发。回调函数会接收所有传入事件触发函数的额外参数。 示例 12345vm.$on('test', function (msg) &#123; console.log(msg)&#125;)vm.$emit('test', 'hi')// =&gt; "hi" 这里$emit监听test事件，附加参数（hi）都会传给监听器回调。然后$on和$emit监听同一个事件，接收到$emit传过来的数据（hi），然后通过回调函数打印出来。 vm.$emit( eventName, […args] ) 参数 {string} eventName […args] 用法 触发当前实例上的事件。附加参数都会传给监听器回调。 示例 先定义一个计数组件123456789101112131415161718192021Vue.component('simple-com',&#123; template:'&lt;button v-on:click="incresone"&gt;&#123;&#123;count&#125;&#125;&lt;/button&gt;', data:function()&#123; return &#123; count:0 &#125; &#125;, methods:&#123; incresone:function()&#123; this.count+=1 //监听自定义的事件 this.$on('increment',function(msg)&#123; //获取$emit方法传递的第二个参数 console.log(msg); alert("1"); &#125;) //触发自定义的事件 this.$emit('increment',this.count) &#125; &#125; &#125;) 使用组件 1234&lt;simple-com v-on:increment="incretol"&gt;&lt;/simple-com&gt;&lt;simple-com v-on:increment="incretol"&gt;&lt;/simple-com&gt;&lt;simple-com v-on:increment="incretol"&gt;&lt;/simple-com&gt;&lt;p&gt;&#123;&#123;total&#125;&#125;&lt;/p&gt; 实例化vue的代码 1234567891011var vm = new Vue(&#123; el:"#app", data: &#123; total:0 &#125; methods:&#123; incretol:function()&#123; this.total+=1 &#125; &#125;&#125;) 当我点击计数的时候，$on监听increment事件，当increment事件执行时，便会弹出1，然后再继续执行后面的代码。]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>$on和$emit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue2.x过渡(transition)与动画(animationend)]]></title>
    <url>%2F2019%2F06%2F04%2Fvue2.x%E8%BF%87%E6%B8%A1(transition)%E4%B8%8E%E5%8A%A8%E7%94%BB(animationend)%2F</url>
    <content type="text"><![CDATA[## transition Vue 提供了 transition 的封装组件，在下列情形中，可以给任何元素和组件添加进入/离开过渡 条件渲染 (使用 v-if) 条件展示 (使用 v-show) 动态组件 组件根节点 示例： 12345678&lt;div id="demo"&gt; &lt;button v-on:click="show = !show"&gt; Toggle &lt;/button&gt; &lt;transition name="fade"&gt; &lt;p v-if="show"&gt;hello&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt; 123456new Vue(&#123; el: '#demo', data: &#123; show: true &#125;&#125;) 123456.fade-enter-active, .fade-leave-active &#123; transition: opacity .5s;&#125;.fade-enter, .fade-leave-to /* .fade-leave-active below version 2.1.8 */ &#123; opacity: 0;&#125; 点击Toggle按钮实现淡入淡出 过渡的类名在进入/离开的过渡中，会有 6 个 class 切换。 1.v-enter：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除。 2.v-enter-active：定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。 3.v-enter-to: 2.1.8版及以上 定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 v-enter 被移除)，在过渡/动画完成之后移除。 4.v-leave: 定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。 5.v-leave-active：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。 6.v-leave-to: 2.1.8版及以上 定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 v-leave 被删除)，在过渡/动画完成之后移除。 贴图方便理解 对于这些在过渡中切换的类名来说，如果你使用一个没有名字的 \，则 v- 是这些类名的默认前缀。如果你使用了 \，那么 v-enter 会替换为 my-transition-enter。v-enter-active 和 v-leave-active 可以控制进入/离开过渡的不同的缓和曲线。 小例子12345678&lt;div id="example-1"&gt; &lt;button @click="show = !show"&gt; Toggle render &lt;/button&gt; &lt;transition name="slide-fade"&gt; &lt;p v-if="show"&gt;hello&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt; 123456new Vue(&#123; el: '#example-1', data: &#123; show: true &#125;&#125;) 12345678910111213/* 可以设置不同的进入和离开动画 *//* 设置持续时间和动画函数 */.slide-fade-enter-active &#123; transition: all .3s ease;&#125;.slide-fade-leave-active &#123; transition: all .8s cubic-bezier(1.0, 0.5, 0.8, 1.0);&#125;.slide-fade-enter, .slide-fade-leave-to/* .slide-fade-leave-active for below version 2.1.8 */ &#123; transform: translateX(10px); opacity: 0;&#125; 点击按钮实现hello向右缓动消失，在点击向左缓动出现 CSS 动画CSS 动画用法同 CSS 过渡，区别是在动画中 v-enter 类名在节点插入 DOM 后不会立即删除，而是在 animationend 事件触发时删除。 示例：(省略了兼容性前缀) 123456&lt;div id="example-2"&gt; &lt;button @click="show = !show"&gt;Toggle show&lt;/button&gt; &lt;transition name="bounce"&gt; &lt;p v-if="show"&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris facilisis enim libero, at lacinia diam fermentum id. Pellentesque habitant morbi tristique senectus et netus.&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt; 123456new Vue(&#123; el: '#example-2', data: &#123; show: true &#125;&#125;) 1234567891011121314151617.bounce-enter-active &#123; animation: bounce-in .5s;&#125;.bounce-leave-active &#123; animation: bounce-in .5s reverse;&#125;@keyframes bounce-in &#123; 0% &#123; transform: scale(0); &#125; 50% &#123; transform: scale(1.5); &#125; 100% &#123; transform: scale(1); &#125;&#125; 点击按钮，这段文本内容或弹跳出现，在点击弹跳消失]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>transition,animationend</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解设备像素比devicePixelRatio]]></title>
    <url>%2F2019%2F06%2F04%2F%E7%90%86%E8%A7%A3%E8%AE%BE%E5%A4%87%E5%83%8F%E7%B4%A0%E6%AF%94devicePixelRatio%2F</url>
    <content type="text"><![CDATA[## 定义 window.devicePixelRatio是设备上物理像素和设备独立像素(device-independent pixels (dips))的比例。公式表示就是：window.devicePixelRatio = 物理像素 / dips 理解移动端的设备多种多样，不同的设备又有不同的分辨率，低一点的有 800 400，中等的有 1280 720，高的有 1920 * 1080，甚至还有更高的 4k 屏等。我们在开发移动端页面时，将视口（viewport）设置为设备宽度（device-width）后，同一份页面在这些不同的设备上会出现相同的表现。为什么这些设备拥有不同的分辨率，而在渲染页面时表现都一样呢？其实这是由设备像素比造成的。设备像素比是怎么发挥作用的呢？要理解这个问题，需要三块预备知识： 设备独立像素 DPI/PPI CSS 中的像素 设备独立像素设备的独立像素是和设备的分辨率相关联的，比如 IPhone6 的分辨率为 1334 750，那么表示该手机的屏幕上有 1366 750 个物理像素，而 Galaxy S5 的屏幕上有 1280*720 个像素。 PPI/DPI表示每英寸所包含的像素点数目，数值越高，说明屏幕能以更高密度显示图像 计算公式——以 IPhone6 为例，可以计算出的 IPhone6 的 PPI 为：325.16。该结果表示在 IPhone6 上，每英寸有 325.16 个物理像素，四舍五入为 325 个物理像素。可以发现：这个 PPI 的值近似等于 IPhone6 这个设备的水平物理像素的一半，也即： 1750 / 325 = 2 这个由设备水平物理像素和设备 PPI/DPI 计算出来出来的比值就是设备像素比。 CSS 中的像素CSS 中的像素是一个相对值，不是绝对值，因此1px 的 CSS 像素并不一定等于 1px 的物理像素。需要注意的是，CSS 中的像素单位是抽象的，只是一种规范，最终的显示是取决于物理设备的。物理设备根据某种规则，决定该采用几个物理像素去显示 1px 的 CSS 像素，这个规则就是设备像素比。 设备像素比当设备像素比为1:1时，使用1（1×1）个设备像素显示1个CSS像素； 当设备像素比为2:1时，使用4（2×2）个设备像素显示1个CSS像素； 当设备像素比为3:1时，使用9（3×3）个设备像素显示1个CSS像素。 如下图所示： 前面已经说到过，设备像素比等于设备的水平物理像素和设备 PPI 的比值。设备像素比的意义就是决定了用多少个物理像素去显示 1px 的 CSS 像素。比如在 IPhone6 中，设备像素比为 2，那么在 IPhone6 上就会使用 22 = 4 个物理像素去显示 1px 的 CSS 像素。因此，如果我们给一个 DIV 元素设置 300px 300px 的样式，那么其在 IPhone6 上将会占用 600 600 个物理像素。这就是为什么明明 IPhone6 的分辨率为 1334 750（物理像素），而将 DIV 元素的宽度设置成 300px 后，其几乎占满了水平屏幕的原因。上例在 IPhone 中的渲染效果也可以理解为：在分辨率为 667 325（设备宽度不变），设备像素比为 1 的设备上显示 300px 宽度的 DIV 的效果。既然设备像素比为 1，那么也可以这么理解：上例在 IPhone6 中的显示效果相当于在 667 325 的 Chrome 浏览器下的显示效果。Galaxy S5 的设备像素比为 3，因此在 Galaxy S5 中的显示效果可以理解为在 660 * 360 的 Chrome 浏览器下的显示效果。这也解释了为什么不同分辨率的设备，对于 300px 宽度的 DIV 展示效果基本一致的情况。 window.devicePixelRatiowindow 对象有个 devicePixelRatio 属性，其中也保存了设备像素比的值，因此我们不必经过上面的公式计算，就可以直接获取到设备像素比的值。注意：你可以为这个 window.devicePixelRatio 重新赋值，但并不会对最终的显示造成任何的影响 12window.devicePixelRatio = 10window.devicePixelRatio // 10 上面重新设置了 window.devicePixelRatio 的值，但不会影响浏览器的显示效果，也就是说，手动设置 window.devicePixelRatio 是没有任何用处的。 注意我们需要记住一点：1px 的 CSS 像素并不一定等于 1px 的物理像素，不同的设备会根据其对应设备像素比决定使用多少个物理像素显示 1px 的 CSS 像素。另外，在移动端不建议使用 px 作为布局单位，而是应该使用 rem 或者百分比作为布局单位。]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>devicePixelRatio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端 1px 像素问题及解决办法]]></title>
    <url>%2F2019%2F06%2F04%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%201px%20%E5%83%8F%E7%B4%A0%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[## 移动端1px变粗的原因 为什么移动端css里面写了1px, 实际看起来比1px粗. 其实原因很好理解:这2个’px’的含义是不一样的. 移动端html的header总会有一句 1&lt;meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"&gt; 这句话定义了本页面的viewport的宽度为设备宽度,初始缩放值和最大缩放值都为1,并禁止了用户缩放. viewport通俗的讲是浏览器上可用来显示页面的区域, 这个区域是可能比屏幕大的. 根据这篇文章http://www.cnblogs.com/2050/p/3877280.html的分析, 手机存在一个能完美适配的理想viewport, 分辨率相差很大的手机的理想viewport的宽度可能是一样的, 这样做的目的是为了保证同样的css在不同屏幕下的显示效果是一致的, 上面的meta实际上是设置了ideal viewport的宽度. 以实际举例: iphone3和iphone4的屏幕宽度分别是320px,640px, 但是它们的ideal viewport的宽度都是320px, 设置了设备宽度后, 320px宽的元素都能100%的填充满屏幕宽. 不同手机的ideal viewport宽度是不一样的, 常见的有320px, 360px, 384px. iphone系列的这个值在6之前都是320px, 控制viewport的好处就在于一套css可以适配多个机型. 看懂的人应该已经明白 1px变粗的原因了, viewport的设置和屏幕物理分辨率是按比例而不是相同的. 移动端window对象有个devicePixelRatio属性, 它表示设备物理像素和css像素的比例, 在retina屏的iphone手机上, 这个值为2或3, css里写的1px长度映射到物理像素上就有2px或3px那么长. 对于设备像素比（devicePixelRatio）不了解的可以看看这篇文章：理解设备像素比devicePixelRatio 1px解决方案1、 媒体查询利用设备像素比缩放，设置小数像素优点：简单，好理解缺点：兼容性差，目前之余IOS8+才支持，在IOS7及其以下、安卓系统都是显示0px。 IOS8下已经支持带小数的px值, media query对应devicePixelRatio有个查询值-webkit-min-device-pixel-ratio, css可以写成这样 1234567.border &#123; border: 1px solid #999 &#125;@media screen and (-webkit-min-device-pixel-ratio: 2) &#123; .border &#123; border: 0.5px solid #999 &#125;&#125;@media screen and (-webkit-min-device-pixel-ratio: 3) &#123; .border &#123; border: 0.333333px solid #999 &#125;&#125; 如果使用less/sass的话只是加了1句mixin 2.设置 border-image 方案缺点：需要制作图片，圆角可能出现模糊这样的1张6X6的图片, 9宫格等分填充border-image, 这样元素的4个边框宽度都只有1px 123456@media screen and (-webkit-min-device-pixel-ratio: 2)&#123; .border&#123; border: 1px solid transparent; border-image: url(border.gif) 2 repeat; &#125;&#125; 图片可以用gif, png, base64多种格式, 以上是上下左右四条边框的写法, 需要单一边框只要定义单一边框的border, 代码比较直观. 3、background-image 渐变实现除了使用图片外，当然也能使用纯css来实现，百度糯米团就是采用的这种方案。缺点：因为每个边框都是线性渐变颜色实现，因此无法实现圆角。 12345678910.border &#123; background-image:linear-gradient(180deg, red, red 50%, transparent 50%), linear-gradient(270deg, red, red 50%, transparent 50%), linear-gradient(0deg, red, red 50%, transparent 50%), linear-gradient(90deg, red, red 50%, transparent 50%); background-size: 100% 1px,1px 100% ,100% 1px, 1px 100%; background-repeat: no-repeat; background-position: top, right top, bottom, left top; padding: 10px;&#125; 原理：将原本1个物理像素的边框大小利用线性渐变分割成几个部分（百分比控制），实现小于1像素效果。 linear-gradient：指定线性渐变，接受大于等于3个参数，第一个为渐变旋转角度，第二个开始为渐变的颜色和到哪个位置（百分比）全部变为该颜色，该例子中，第一句就是，渐变方向旋转180度，即从上往下（默认为0度从下往上），从红色开始渐变，到50%的位置还是红色，再渐变为继承父元素颜色。 4、box-shadow利用阴影也可以实现，优点是没有圆角问题，缺点是颜色不好控制 123div &#123; -webkit-box-shadow: 0 1px 1px -1px rgba(0, 0, 0, 0.5);&#125; box-shadow属性的用法：box-shadow: h-shadow v-shadow [blur] [spread] [color] [inset] 参数分别表示: 水平阴影位置，垂直阴影位置，模糊距离， 阴影尺寸，阴影颜色，将外部阴影改为内部阴影，后四个可选。该例中为何将阴影尺寸设置为负数？设置成-1px 是为了让阴影尺寸稍小于div元素尺寸，这样左右两边的阴影就不会暴露出来，实现只有底部一边有阴影的效果。从而实现分割线效果（单边边框）。 5、viewport + rem该方案是对上述方案的优化，整体思路就是利用viewport + rem + js 动态的修改页面的缩放比例，实现小于1像素的显示。缺点：以为缩放涉及全局的rem单位，比较适合新项目，对于老项目可能要涉及到比较多的改动。 在页面初始化时，在头部引入原始默认状态如下： 1&lt;meta name="viewport" id="WebViewport" content="initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"&gt; 接下来的任务就是js的动态修改缩放比 以及 实现rem根元素字体大小的设置。 12345678910111213var viewport = document.querySelector("meta[name=viewport]")if (window.devicePixelRatio == 1) &#123; viewport.setAttribute('content', 'width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no')&#125; if (window.devicePixelRatio == 2) &#123; viewport.setAttribute('content', 'width=device-width, initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no')&#125; if (window.devicePixelRatio == 3) &#123; viewport.setAttribute('content', 'width=device-width, initial-scale=0.333333333, maximum-scale=0.333333333, minimum-scale=0.333333333, user-scalable=no')&#125; var docEl = document.documentElement;var fontsize = 10 * (docEl.clientWidth / 320) + 'px';docEl.style.fontSize = fontsize; 6、transform: scale(0.5) 方案 - 推荐: 很灵活 1.) 设置height: 1px，根据媒体查询结合transform缩放为相应尺寸。 1234567div &#123; height:1px; background:#000; -webkit-transform: scaleY(0.5); -webkit-transform-origin:0 0; overflow: hidden;&#125; 2.) 用::after和::befor,设置border-bottom：1px solid #000,然后在缩放-webkit-transform: scaleY(0.5);可以实现两根边线的需求 12345div::after&#123; content:'';width:100%; border-bottom:1px solid #000; transform: scaleY(0.5);&#125; 3.) 用::after设置border：1px solid #000; width:200%; height:200%,然后再缩放scaleY(0.5); 优点可以实现圆角，京东就是这么实现的，缺点是按钮添加active比较麻烦。 12345678910111213.div::after &#123; content: ''; width: 200%; height: 200%; position: absolute; top: 0; left: 0; border: 1px solid #bfbfbf; border-radius: 4px; -webkit-transform: scale(0.5,0.5); transform: scale(0.5,0.5); -webkit-transform-origin: top left;&#125; 7、媒体查询 + transfrom 对方案1的优化1234567891011121314/* 2倍屏 */@media only screen and (-webkit-min-device-pixel-ratio: 2.0) &#123; .border-bottom::after &#123; -webkit-transform: scaleY(0.5); transform: scaleY(0.5); &#125;&#125;/* 3倍屏 */@media only screen and (-webkit-min-device-pixel-ratio: 3.0) &#123; .border-bottom::after &#123; -webkit-transform: scaleY(0.33); transform: scaleY(0.33); &#125;&#125;]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>移动端1px像素</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git常用命令]]></title>
    <url>%2F2019%2F06%2F04%2Fgit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[@[toc] 一般配置git –version //查看git的版本信息git config –global user.email //获取当前登录的用户git config –global user.email //获取当前登录用户的邮箱 登录gitgit config –global user.email ‘userName’ //设置git账户，userName为你的git账号git config –global user.email ‘email’ git常用命令git init在本地新建一个repo,进入一个项目目录,执行git init,会初始化一个repo,并在当前文件夹下创建一个.git文件夹. git clone一般的格式是git clone [url].获取一个url对应的远程Git repo, 创建一个local copy.clone下来的repo会以url最后一个斜线后面的名称命名,创建一个文件夹,如果想要指定特定的名称,可以git clone [url] newname指定. git status查询repo的状态.git status:显示工作目录和暂存区的状态git status -s: -s表示short, -s的输出标记会有两列,第一列是对staging区域而言,第二列是对working目录而言. git log show commit history of a branch. git log –oneline –number: 每条log只显示一行,显示number条. git log –oneline –graph: 可以图形化地表示出分支合并历史. git log branchname可以显示特定分支的log. git log –oneline branch1 \^branch2,可以查看在分支1,却不在分支2中的提交.\^表示排除这个分支(Window下可能要给^branch2加上引号). git log –decorate会显示出tag信息. git log –author=[author name] 可以指定作者的提交历史. git log –since –before –until –after 根据提交时间筛选log. –no-merges可以将merge的commits排除在外. git log –grep 根据commit信息过滤log: git log –grep=keywords 默认情况下, git log –grep –author是OR的关系,即满足一条即被返回,如果你想让它们是AND的关系,可以加上–all-match的option. git log -S: filter by introduced diff. 比如: git log -SmethodName (注意S和后面的词之间没有等号分隔). git log -p: show patch introduced at each commit. 每一个提交都是一个快照(snapshot),Git会把每次提交的diff计算出来,作为一个patch显示给你看. 另一种方法是git show [SHA]. git log –stat: show diffstat of changes introduced at each commit. 同样是用来看改动的相对信息的,–stat比-p的输出更简单一些. git add在提交之前,Git有一个暂存区(staging area),可以放入新添加的文件或者加入新的改动. commit时提交的改动是上一次加入到staging area中的改动,而不是我们disk上的改动. git add . 会递归地添加当前工作目录中的所有文件. git diff不加参数的git diff: show diff of unstaged changes. 此命令比较的是工作目录中当前文件和暂存区域快照之间的差异,也就是修改之后还没有暂存起来的变化内容. 若要看已经暂存起来的文件和上次提交时的快照之间的差异,可以用: git diff –cached 命令. show diff of staged changes. (Git 1.6.1 及更高版本还允许使用 git diff –staged，效果是相同的). git diff HEAD show diff of all staged or unstated changes. 也即比较woking directory和上次提交之间所有的改动. 如果想看自从某个版本之后都改动了什么,可以用: git diff [version tag] 跟log命令一样,diff也可以加上–stat参数来简化输出. git diff [branchA] [branchB]可以用来比较两个分支. 它实际上会返回一个由A到B的patch,不是我们想要的结果. 一般我们想要的结果是两个分支分开以后各自的改动都是什么,是由命令: git diff [branchA]…[branchB]给出的. 实际上它是:git diff $(git merge-base [branchA] [branchB]) [branchB]的结果. git commit提交已经被add进来的改动. git commit -m “the commit message” git commit -a 会先把所有已经track的文件的改动add进来,然后提交(有点像svn的一次提交,不用先暂存). 对于没有track的文件,还是需要git add一下. git commit –amend 增补提交. 会使用与当前提交节点相同的父节点进行一次新的提交,旧的提交将会被取消. git resetundo changes and commits. 这里的HEAD关键字指的是当前分支最末梢最新的一个提交.也就是版本库中该分支上的最新版本. git reset HEAD: unstage files from index and reset pointer to HEAD 这个命令用来把不小心add进去的文件从staged状态取出来,可以单独针对某一个文件操作: git reset HEAD - - filename, 这个- - 也可以不加. git reset –soft move HEAD to specific commit reference, index and staging are untouched. git reset –hard unstage files AND undo any changes in the working directory since last commit. 使用git reset —hard HEAD进行reset,即上次提交之后,所有staged的改动和工作目录的改动都会消失,还原到上次提交的状态. 这里的HEAD可以被写成任何一次提交的SHA-1. 不带soft和hard参数的git reset,实际上带的是默认参数mixed. 总结: git reset –mixed id,是将git的HEAD变了(也就是提交记录变了),但文件并没有改变，(也就是working tree并没有改变). 取消了commit和add的内容. git reset –soft id. 实际上，是git reset –mixed id 后,又做了一次git add.即取消了commit的内容. git reset –hard id.是将git的HEAD变了,文件也变了. 按改动范围排序如下: soft (commit) &lt; mixed (commit + add) &lt; hard (commit + add + local working) git revert反转撤销提交.只要把出错的提交(commit)的名字(reference)作为参数传给命令就可以了. git revert HEAD: 撤销最近的一个提交. git revert会创建一个反向的新提交,可以通过参数-n来告诉Git先不要提交. git rmgit rm file: 从staging区移除文件,同时也移除出工作目录. git rm –cached: 从staging区移除文件,但留在工作目录中. git rm –cached从功能上等同于git reset HEAD,清除了缓存区,但不动工作目录树. git cleangit clean是从工作目录中移除没有track的文件. 通常的参数是git clean -df: -d表示同时移除目录,-f表示force,因为在git的配置文件中, clean.requireForce=true,如果不加-f,clean将会拒绝执行. git mvgit rm - - cached orig; mv orig new; git add new git stash 把当前的改动压入一个栈. git stash将会把当前目录和index中的所有改动(但不包括未track的文件)压入一个栈,然后留给你一个clean的工作状态,即处于上一次最新提交处. git stash list会显示这个栈的list. git stash apply:取出stash中的上一个项目(stash@{0}),并且应用于当前的工作目录. 也可以指定别的项目,比如git stash apply stash@{1}. 如果你在应用stash中项目的同时想要删除它,可以用git stash pop 删除stash中的项目: git stash drop: 删除上一个,也可指定参数删除指定的一个项目. git stash clear: 删除所有项目. git branch git branch可以用来列出分支,创建分支和删除分支. git branch -v可以看见每一个分支的最后一次提交. git branch: 列出本地所有分支,当前分支会被星号标示出. git branch (branchname): 创建一个新的分支(当你用这种方式创建分支的时候,分支是基于你的上一次提交建立的). git branch -d (branchname): 删除一个分支. 删除remote的分支: git push (remote-name) :(branch-name): delete a remote branch. 这个是因为完整的命令形式是: git push remote-name local-branch:remote-branch 而这里local-branch的部分为空,就意味着删除了remote-branch git checkout git checkout (branchname) 切换到一个分支. git checkout -b (branchname): 创建并切换到新的分支. 这个命令是将git branch newbranch和git checkout newbranch合在一起的结果. checkout还有另一个作用:替换本地改动: git checkout –\ 此命令会使用HEAD中的最新内容替换掉你的工作目录中的文件.已添加到暂存区的改动以及新文件都不会受到影响. 注意:git checkout filename会删除该文件中所有没有暂存和提交的改动,这个操作是不可逆的. git merge把一个分支合并进当前的分支. git merge [alias]/[branch] 把远程分支merge到当前分支. 如果出现冲突,需要手动修改,可以用git mergetool. 解决冲突的时候可以用到git diff,解决完之后用git add添加,即表示冲突已经被resolved. git tag tag a point in history as import. 会在一个提交上建立永久性的书签,通常是发布一个release版本或者ship了什么东西之后加tag. 比如: git tag v1.0 git tag -a v1.0, -a参数会允许你添加一些信息,即make an annotated tag. 当你运行git tag -a命令的时候,Git会打开一个编辑器让你输入tag信息. 我们可以利用commit SHA来给一个过去的提交打tag: git tag -a v0.9 XXXX push的时候是不包含tag的,如果想包含,可以在push时加上–tags参数. fetch的时候,branch HEAD可以reach的tags是自动被fetch下来的, tags that aren’t reachable from branch heads will be skipped.如果想确保所有的tags都被包含进来,需要加上–tags选项. git remotelist, add and delete remote repository aliases. 因为不需要每次都用完整的url,所以Git为每一个remote repo的url都建立一个别名,然后用git remote来管理这个list. git remote: 列出remote aliases. 如果你clone一个project,Git会自动将原来的url添加进来,别名就叫做:origin. git remote -v:可以看见每一个别名对应的实际url. git remote add [alias] [url]: 添加一个新的remote repo. git remote rm [alias]: 删除一个存在的remote alias. git remote rename [old-alias] [new-alias]: 重命名. git remote set-url [alias] [url]:更新url. 可以加上—push和fetch参数,为同一个别名set不同的存取地址. git fetchdownload new branches and data from a remote repository. 可以git fetch [alias]取某一个远程repo,也可以git fetch –all取到全部repo fetch将会取到所有你本地没有的数据,所有取下来的分支可以被叫做remote branches,它们和本地分支一样(可以看diff,log等,也可以merge到其他分支),但是Git不允许你checkout到它们. git pull fetch from a remote repo and try to merge into the current branch. pull == fetch + merge FETCH_HEAD git pull会首先执行git fetch,然后执行git merge,把取来的分支的head merge到当前分支.这个merge操作会产生一个新的commit. 如果使用–rebase参数,它会执行git rebase来取代原来的git merge. git rebase –rebase不会产生合并的提交,它会将本地的所有提交临时保存为补丁(patch),放在”.git/rebase”目录中,然后将当前分支更新到最新的分支尖端,最后把保存的补丁应用到分支上. rebase的过程中,也许会出现冲突,Git会停止rebase并让你解决冲突,在解决完冲突之后,用git add去更新这些内容,然后无需执行commit,只需要: git rebase –continue就会继续打余下的补丁. git rebase –abort将会终止rebase,当前分支将会回到rebase之前的状态. git pushpush your new branches and data to a remote repository. git push [alias] [branch] 将会把当前分支merge到alias上的[branch]分支.如果分支已经存在,将会更新,如果不存在,将会添加这个分支. 如果有多个人向同一个remote repo push代码, Git会首先在你试图push的分支上运行git log,检查它的历史中是否能看到server上的branch现在的tip,如果本地历史中不能看到server的tip,说明本地的代码不是最新的,Git会拒绝你的push,让你先fetch,merge,之后再push,这样就保证了所有人的改动都会被考虑进来. git refloggit reflog是对reflog进行管理的命令,reflog是git用来记录引用变化的一种机制,比如记录分支的变化或者是HEAD引用的变化. 当git reflog不指定引用的时候,默认列出HEAD的reflog. HEAD@{0}代表HEAD当前的值,HEAD@{3}代表HEAD在3次变化之前的值. git会将变化记录到HEAD对应的reflog文件中,其路径为.git/logs/HEAD, 分支的reflog文件都放在.git/logs/refs目录下的子目录中. 特殊符号: \^代表父提交,当一个提交有多个父提交时,可以通过在\^后面跟上一个数字,表示第几个父提交: ^相当于\^1. ~\相当于连续的\个^. Git常用命令速查表]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webStrom_phpStrom使用箭头函数报错解决方法]]></title>
    <url>%2F2019%2F06%2F04%2FwebStrom_phpStrom%E4%BD%BF%E7%94%A8%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[### webStrom/phpStrom使用箭头函数报错 在webStrom/phpStrom下写箭头函数会出现代码爆红，但执行并不会出错。像这样: 解决方法 点击窗口左上角File-&gt;Setttings-&gt;Languages &amp; FrameWorks-&gt;JavaScript 在右边找到JavaScript Language version下拉框中版本改为ECMAScript6 将\改写成\这个时候就不会在报错了。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于webpack命令提示安装webpack-cli，安装了以后又显示“Cannot find module 'webpack'”的解决方法]]></title>
    <url>%2F2019%2F06%2F04%2F%E5%85%B3%E4%BA%8Ewebpack%E5%91%BD%E4%BB%A4%E6%8F%90%E7%A4%BA%E5%AE%89%E8%A3%85webpack-cli%EF%BC%8C%E5%AE%89%E8%A3%85%E4%BA%86%E4%BB%A5%E5%90%8E%E5%8F%88%E6%98%BE%E7%A4%BA%E2%80%9CCannot%20find%20module%20'webpack'%E2%80%9D%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[## webpack 初次安装只有webpack遇到了许多问题，记录以下，分享给其他遇到相同问题的小伙伴。 问题一：We will use “npm” to install the CLI via “npm install -D”.12345678BlinkdeMacBook-Pro:05-01 blink$ webpackOne CLI for webpack must be installed. These are recommended choices, delivered as separate packages: - webpack-cli (https://github.com/webpack/webpack-cli) The original webpack full-featured CLI. - webpack-command (https://github.com/webpack-contrib/webpack-command) A lightweight, opinionated webpack CLI.We will use "npm" to install the CLI via "npm install -D".Which one do you like to install (webpack-cli/webpack-command): 在使用npm i webpack -g安装了webpack以后，使用时出现了这个，让我们去安装webpack-cli。 解决方案直接安装webpack-cli就是了,需要注意的是后面记得加 -g进行全局安装 1cnpm install webpack-cli -g 问题二：Cannot find module ‘webpack这就很奇怪了，前面刚刚安装了咋显示找不到，然后找了好几种解决方案好像都不行了，不过倒腾了一会发现是webpack4这个版本的原因，那就好解决了，换一个版本安装就是了。 解决方案安装webpack3的版本就行了，我安装的是3.6.01cnpm install webpack@3.6.0 -g]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git出现Unable to create 'E__xxx_.git_index.lock'_ File exists.的解决办法]]></title>
    <url>%2F2019%2F06%2F04%2FGit%E5%87%BA%E7%8E%B0Unable%20to%20create%20'E__xxx_.git_index.lock'_%20File%20exists.%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[在使用git时，在执行完”git add readme.txt”命令后，在执行commit时，由于命令写错，没有写提交日志，再次更正提交就出现上述错误：Unable to create ‘E:/xxx/.git/index.lock’: File exists 解决方案：在.git同级目录，执行rm -f .git/index.lock 将文件删除即可提交成功]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git Filename too long解决方案]]></title>
    <url>%2F2019%2F06%2F04%2Fgit%20Filename%20too%20long%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[## 问题 git clone代码时提示Filename too long，一般是在windows下出现的问题。 解决方法用管理员打开命令窗口，输入git config –system core.longpaths true解决。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue.js - day1]]></title>
    <url>%2F2019%2F06%2F04%2FVue.js%20-%20Day1%2F</url>
    <content type="text"><![CDATA[# Vue.js - Day1 笔记配套源码 @[toc] 什么是Vue.js Vue.js 是目前最火的一个前端框架，React是最流行的一个前端框架（React除了开发网站，还可以开发手机App， Vue语法也是可以用于进行手机App开发的，需要借助于Weex） Vue.js 是前端的主流框架之一，和Angular.js、React.js 一起，并成为前端三大主流框架！ Vue.js 是一套构建用户界面的框架，只关注视图层，它不仅易于上手，还便于与第三方库或既有项目整合。（Vue有配套的第三方类库，可以整合起来做大型项目的开发） 前端的主要工作？主要负责MVC中的V这一层；主要工作就是和界面打交道，来制作前端页面效果； 为什么要学习流行框架 企业为了提高开发效率：在企业中，时间就是效率，效率就是金钱； 企业中，使用框架，能够提高开发的效率； 提高开发效率的发展历程：原生JS -&gt; Jquery之类的类库 -&gt; 前端模板引擎 -&gt; Angular.js / Vue.js（能够帮助我们减少不必要的DOM操作；提高渲染效率；双向数据绑定的概念【通过框架提供的指令，我们前端程序员只需要关心数据的业务逻辑，不再关心DOM是如何渲染的了】） 在Vue中，一个核心的概念，就是让用户不再操作DOM元素，解放了用户的双手，让程序员可以更多的时间去关注业务逻辑； 增强自己就业时候的竞争力 人无我有，人有我优 你平时不忙的时候，都在干嘛？ 框架和库的区别 框架：是一套完整的解决方案；对项目的侵入性较大，项目如果需要更换框架，则需要重新架构整个项目。 node 中的 express； 库（插件）：提供某一个小功能，对项目的侵入性较小，如果某个库无法完成某些需求，可以很容易切换到其它库实现需求。 从Jquery 切换到 Zepto 从 EJS 切换到 art-template Node（后端）中的 MVC 与 前端中的 MVVM 之间的区别 MVC 是后端的分层开发概念； MVVM是前端视图层的概念，主要关注于 视图层分离，也就是说：MVVM把前端的视图层，分为了 三部分 Model, View , VM ViewModel 为什么有了MVC还要有MVVM Vue.js 基本代码 和 MVVM 之间的对应关系Vue之 - 基本的代码结构和插值表达式、v-cloakVue指令之v-text和v-htmlVue指令之v-bind的三种用法 直接使用指令v-bind 使用简化指令: 在绑定的时候，拼接绑定内容：:title=&quot;btnTitle + &#39;, 这是追加的内容&#39;&quot; Vue指令之v-on和跑马灯效果跑马灯效果 HTML结构： 12345678910&lt;div id="app"&gt; &lt;p&gt;&#123;&#123;info&#125;&#125;&lt;/p&gt; &lt;input type="button" value="开启" v-on:click="go"&gt; &lt;input type="button" value="停止" v-on:click="stop"&gt; &lt;/div&gt; Vue实例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; info: '猥琐发育，别浪~！', intervalId: null &#125;, methods: &#123; go() &#123; // 如果当前有定时器在运行，则直接return if (this.intervalId != null) &#123; return; &#125; // 开始定时器 this.intervalId = setInterval(() =&gt; &#123; this.info = this.info.substring(1) + this.info.substring(0, 1); &#125;, 500); &#125;, stop() &#123; clearInterval(this.intervalId); &#125; &#125; &#125;); Vue指令之v-on的缩写和事件修饰符事件修饰符： .stop 阻止冒泡 .prevent 阻止默认事件 .capture 添加事件侦听器时使用事件捕获模式 .self 只当事件在该元素本身（比如不是子元素）触发时触发回调 .once 事件只触发一次 Vue指令之v-model和双向数据绑定简易计算器案例 HTML 代码结构 123456789101112131415161718192021222324&lt;div id="app"&gt; &lt;input type="text" v-model="n1"&gt; &lt;select v-model="opt"&gt; &lt;option value="0"&gt;+&lt;/option&gt; &lt;option value="1"&gt;-&lt;/option&gt; &lt;option value="2"&gt;*&lt;/option&gt; &lt;option value="3"&gt;÷&lt;/option&gt; &lt;/select&gt; &lt;input type="text" v-model="n2"&gt; &lt;input type="button" value="=" v-on:click="getResult"&gt; &lt;input type="text" v-model="result"&gt;&lt;/div&gt; Vue实例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; n1: 0, n2: 0, result: 0, opt: '0' &#125;, methods: &#123; getResult() &#123; switch (this.opt) &#123; case '0': this.result = parseInt(this.n1) + parseInt(this.n2); break; case '1': this.result = parseInt(this.n1) - parseInt(this.n2); break; case '2': this.result = parseInt(this.n1) * parseInt(this.n2); break; case '3': this.result = parseInt(this.n1) / parseInt(this.n2); break; &#125; &#125; &#125; &#125;); 在Vue中使用样式使用class样式 数组 1&lt;h1 :class="['red', 'thin']"&gt;这是一个邪恶的H1&lt;/h1&gt; 数组中使用三元表达式 1&lt;h1 :class="['red', 'thin', isactive?'active':'']"&gt;这是一个邪恶的H1&lt;/h1&gt; 数组中嵌套对象 1&lt;h1 :class="['red', 'thin', &#123;'active': isactive&#125;]"&gt;这是一个邪恶的H1&lt;/h1&gt; 直接使用对象 1&lt;h1 :class="&#123;red:true, italic:true, active:true, thin:true&#125;"&gt;这是一个邪恶的H1&lt;/h1&gt; 使用内联样式 直接在元素上通过 :style 的形式，书写样式对象 1&lt;h1 :style="&#123;color: 'red', 'font-size': '40px'&#125;"&gt;这是一个善良的H1&lt;/h1&gt; 将样式对象，定义到 data 中，并直接引用到 :style 中 在data上定义样式： 123data: &#123; h1StyleObj: &#123; color: 'red', 'font-size': '40px', 'font-weight': '200' &#125;&#125; 在元素中，通过属性绑定的形式，将样式对象应用到元素中： 1&lt;h1 :style="h1StyleObj"&gt;这是一个善良的H1&lt;/h1&gt; 在 :style 中通过数组，引用多个 data 上的样式对象 在data上定义样式： 1234data: &#123; h1StyleObj: &#123; color: 'red', 'font-size': '40px', 'font-weight': '200' &#125;, h1StyleObj2: &#123; fontStyle: 'italic' &#125;&#125; 在元素中，通过属性绑定的形式，将样式对象应用到元素中： 1&lt;h1 :style="[h1StyleObj, h1StyleObj2]"&gt;这是一个善良的H1&lt;/h1&gt; Vue指令之v-for和key属性 迭代数组 123&lt;ul&gt; &lt;li v-for="(item, i) in list"&gt;索引：&#123;&#123;i&#125;&#125; --- 姓名：&#123;&#123;item.name&#125;&#125; --- 年龄：&#123;&#123;item.age&#125;&#125;&lt;/li&gt;&lt;/ul&gt; 迭代对象中的属性 1234&lt;!-- 循环遍历对象身上的属性 --&gt; &lt;div v-for="(val, key, i) in userInfo"&gt;&#123;&#123;val&#125;&#125; --- &#123;&#123;key&#125;&#125; --- &#123;&#123;i&#125;&#125;&lt;/div&gt; 迭代数字 12&lt;p v-for="i in 10"&gt;这是第 &#123;&#123;i&#125;&#125; 个P标签&lt;/p&gt; 2.2.0+ 的版本里，当在组件中使用 v-for 时，key 现在是必须的。 当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用 “就地复用” 策略。如果数据项的顺序被改变，Vue将不是移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。 为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性。 Vue指令之v-if和v-show 一般来说，v-if 有更高的切换消耗而 v-show 有更高的初始渲染消耗。因此，如果需要频繁切换 v-show 较好，如果在运行时条件不大可能改变 v-if 较好。 品牌管理案例添加新品牌删除品牌根据条件筛选品牌 1.x 版本中的filterBy指令，在2.x中已经被废除： filterBy - 指令 12345678910111213141516&lt;tr v-for="item in list | filterBy searchName in 'name'"&gt; &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.ctime&#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;a href="#" @click.prevent="del(item.id)"&gt;删除&lt;/a&gt; &lt;/td&gt;&lt;/tr&gt; 在2.x版本中手动实现筛选的方式： 筛选框绑定到 VM 实例中的 searchName 属性： 1234&lt;hr&gt; 输入筛选名称：&lt;input type="text" v-model="searchName"&gt; 在使用 v-for 指令循环每一行数据的时候，不再直接 item in list，而是 in 一个 过滤的methods 方法，同时，把过滤条件searchName传递进去： 1234567891011121314151617181920&lt;tbody&gt; &lt;tr v-for="item in search(searchName)"&gt; &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.ctime&#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;a href="#" @click.prevent="del(item.id)"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; search 过滤方法中，使用 数组的 filter 方法进行过滤： 12345678910search(name) &#123; return this.list.filter(x =&gt; &#123; return x.name.indexOf(name) != -1; &#125;);&#125; Vue调试工具vue-devtools的安装步骤和使用Vue.js devtools - 翻墙安装方式 - 推荐 过滤器概念：Vue.js 允许你自定义过滤器，可被用作一些常见的文本格式化。过滤器可以用在两个地方：mustache 插值和 v-bind 表达式。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符指示； 私有过滤器 HTML元素： 12&lt;td&gt;&#123;&#123;item.ctime | dataFormat('yyyy-mm-dd')&#125;&#125;&lt;/td&gt; 私有 filters 定义方式： 1234567891011121314151617181920212223242526272829303132333435363738394041424344filters: &#123; // 私有局部过滤器，只能在 当前 VM 对象所控制的 View 区域进行使用 dataFormat(input, pattern = "") &#123; // 在参数列表中 通过 pattern="" 来指定形参默认值，防止报错 var dt = new Date(input); // 获取年月日 var y = dt.getFullYear(); var m = (dt.getMonth() + 1).toString().padStart(2, '0'); var d = dt.getDate().toString().padStart(2, '0'); // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日 // 否则，就返回 年-月-日 时：分：秒 if (pattern.toLowerCase() === 'yyyy-mm-dd') &#123; return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;`; &#125; else &#123; // 获取时分秒 var hh = dt.getHours().toString().padStart(2, '0'); var mm = dt.getMinutes().toString().padStart(2, '0'); var ss = dt.getSeconds().toString().padStart(2, '0'); return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;`; &#125; &#125; &#125; 使用ES6中的字符串新方法 String.prototype.padStart(maxLength, fillString=’’) 或 String.prototype.padEnd(maxLength, fillString=’’)来填充字符串； 全局过滤器123456789101112131415161718192021222324252627282930313233343536373839404142// 定义一个全局过滤器Vue.filter('dataFormat', function (input, pattern = '') &#123; var dt = new Date(input); // 获取年月日 var y = dt.getFullYear(); var m = (dt.getMonth() + 1).toString().padStart(2, '0'); var d = dt.getDate().toString().padStart(2, '0'); // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日 // 否则，就返回 年-月-日 时：分：秒 if (pattern.toLowerCase() === 'yyyy-mm-dd') &#123; return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;`; &#125; else &#123; // 获取时分秒 var hh = dt.getHours().toString().padStart(2, '0'); var mm = dt.getMinutes().toString().padStart(2, '0'); var ss = dt.getSeconds().toString().padStart(2, '0'); return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;`; &#125;&#125;); 注意：当有局部和全局两个名称相同的过滤器时候，会以就近原则进行调用，即：局部过滤器优先于全局过滤器被调用！ 键盘修饰符以及自定义键盘修饰符1.x中自定义键盘修饰符【了解即可】12Vue.directive('on').keyCodes.f2 = 113; 2.x中自定义键盘修饰符 通过Vue.config.keyCodes.名称 = 按键值来自定义案件修饰符的别名： 12Vue.config.keyCodes.f2 = 113; 使用自定义的按键修饰符： 12&lt;input type="text" v-model="name" @keyup.f2="add"&gt; 自定义指令 自定义全局和局部的 自定义指令： 123456789101112131415161718192021222324252627282930313233343536// 自定义全局指令 v-focus，为绑定的元素自动获取焦点：Vue.directive('focus', &#123; inserted: function (el) &#123; // inserted 表示被绑定元素插入父节点时调用 el.focus(); &#125;&#125;);// 自定义局部指令 v-color 和 v-font-weight，为绑定的元素设置指定的字体颜色 和 字体粗细： directives: &#123; color: &#123; // 为元素设置指定的字体颜色 bind(el, binding) &#123; el.style.color = binding.value; &#125; &#125;, 'font-weight': function (el, binding2) &#123; // 自定义指令的简写形式，等同于定义了 bind 和 update 两个钩子函数 el.style.fontWeight = binding2.value; &#125; &#125; 自定义指令的使用方式： 12&lt;input type="text" v-model="searchName" v-focus v-color="'red'" v-font-weight="900"&gt; Vue 1.x 中 自定义元素指令【已废弃,了解即可】12345Vue.elementDirective('red-color', &#123; bind: function () &#123; this.el.style.color = 'red'; &#125;&#125;); 使用方式：1&lt;red-color&gt;1232&lt;/red-color&gt; 相关文章 vue.js 1.x 文档 vue.js 2.x 文档 String.prototype.padStart(maxLength, fillString) js 里面的键盘事件对应的键码 Vue.js双向绑定的实现原理]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue.js - day2]]></title>
    <url>%2F2019%2F06%2F04%2FVue.js%20-%20Day2%2F</url>
    <content type="text"><![CDATA[[TOC] Vue.js - Day2品牌管理案例添加新品牌删除品牌根据条件筛选品牌 1.x 版本中的filterBy指令，在2.x中已经被废除： filterBy - 指令 12345678910111213141516&lt;tr v-for="item in list | filterBy searchName in 'name'"&gt; &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.ctime&#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;a href="#" @click.prevent="del(item.id)"&gt;删除&lt;/a&gt; &lt;/td&gt;&lt;/tr&gt; 在2.x版本中手动实现筛选的方式： 筛选框绑定到 VM 实例中的 searchName 属性： 1234&lt;hr&gt; 输入筛选名称：&lt;input type="text" v-model="searchName"&gt; 在使用 v-for 指令循环每一行数据的时候，不再直接 item in list，而是 in 一个 过滤的methods 方法，同时，把过滤条件searchName传递进去： 1234567891011121314151617181920&lt;tbody&gt; &lt;tr v-for="item in search(searchName)"&gt; &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.ctime&#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;a href="#" @click.prevent="del(item.id)"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; search 过滤方法中，使用 数组的 filter 方法进行过滤： 12345678910search(name) &#123; return this.list.filter(x =&gt; &#123; return x.name.indexOf(name) != -1; &#125;);&#125; Vue调试工具vue-devtools的安装步骤和使用Vue.js devtools - 翻墙安装方式 - 推荐 过滤器概念：Vue.js 允许你自定义过滤器，可被用作一些常见的文本格式化。过滤器可以用在两个地方：mustache 插值和 v-bind 表达式。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符指示； 私有过滤器 HTML元素： 12&lt;td&gt;&#123;&#123;item.ctime | dataFormat('yyyy-mm-dd')&#125;&#125;&lt;/td&gt; 私有 filters 定义方式： 1234567891011121314151617181920212223242526272829303132333435363738394041424344filters: &#123; // 私有局部过滤器，只能在 当前 VM 对象所控制的 View 区域进行使用 dataFormat(input, pattern = "") &#123; // 在参数列表中 通过 pattern="" 来指定形参默认值，防止报错 var dt = new Date(input); // 获取年月日 var y = dt.getFullYear(); var m = (dt.getMonth() + 1).toString().padStart(2, '0'); var d = dt.getDate().toString().padStart(2, '0'); // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日 // 否则，就返回 年-月-日 时：分：秒 if (pattern.toLowerCase() === 'yyyy-mm-dd') &#123; return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;`; &#125; else &#123; // 获取时分秒 var hh = dt.getHours().toString().padStart(2, '0'); var mm = dt.getMinutes().toString().padStart(2, '0'); var ss = dt.getSeconds().toString().padStart(2, '0'); return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;`; &#125; &#125; &#125; 使用ES6中的字符串新方法 String.prototype.padStart(maxLength, fillString=’’) 或 String.prototype.padEnd(maxLength, fillString=’’)来填充字符串； 全局过滤器123456789101112131415161718192021222324252627282930313233343536373839404142// 定义一个全局过滤器Vue.filter('dataFormat', function (input, pattern = '') &#123; var dt = new Date(input); // 获取年月日 var y = dt.getFullYear(); var m = (dt.getMonth() + 1).toString().padStart(2, '0'); var d = dt.getDate().toString().padStart(2, '0'); // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日 // 否则，就返回 年-月-日 时：分：秒 if (pattern.toLowerCase() === 'yyyy-mm-dd') &#123; return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;`; &#125; else &#123; // 获取时分秒 var hh = dt.getHours().toString().padStart(2, '0'); var mm = dt.getMinutes().toString().padStart(2, '0'); var ss = dt.getSeconds().toString().padStart(2, '0'); return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;`; &#125;&#125;); 注意：当有局部和全局两个名称相同的过滤器时候，会以就近原则进行调用，即：局部过滤器优先于全局过滤器被调用！ 键盘修饰符以及自定义键盘修饰符1.x中自定义键盘修饰符【了解即可】12Vue.directive('on').keyCodes.f2 = 113; 2.x中自定义键盘修饰符 通过Vue.config.keyCodes.名称 = 按键值来自定义案件修饰符的别名： 12Vue.config.keyCodes.f2 = 113; 使用自定义的按键修饰符： 12&lt;input type="text" v-model="name" @keyup.f2="add"&gt; 自定义指令 自定义全局和局部的 自定义指令： 123456789101112131415161718192021222324252627282930313233343536// 自定义全局指令 v-focus，为绑定的元素自动获取焦点：Vue.directive('focus', &#123; inserted: function (el) &#123; // inserted 表示被绑定元素插入父节点时调用 el.focus(); &#125;&#125;);// 自定义局部指令 v-color 和 v-font-weight，为绑定的元素设置指定的字体颜色 和 字体粗细： directives: &#123; color: &#123; // 为元素设置指定的字体颜色 bind(el, binding) &#123; el.style.color = binding.value; &#125; &#125;, 'font-weight': function (el, binding2) &#123; // 自定义指令的简写形式，等同于定义了 bind 和 update 两个钩子函数 el.style.fontWeight = binding2.value; &#125; &#125; 自定义指令的使用方式： 12&lt;input type="text" v-model="searchName" v-focus v-color="'red'" v-font-weight="900"&gt; Vue 1.x 中 自定义元素指令【已废弃,了解即可】12345Vue.elementDirective('red-color', &#123; bind: function () &#123; this.el.style.color = 'red'; &#125;&#125;); 使用方式：1&lt;red-color&gt;1232&lt;/red-color&gt; vue实例的生命周期 什么是生命周期：从Vue实例创建、运行、到销毁期间，总是伴随着各种各样的事件，这些事件，统称为生命周期！ 生命周期钩子：就是生命周期事件的别名而已； 生命周期钩子 = 生命周期函数 = 生命周期事件 主要的生命周期函数分类： 创建期间的生命周期函数： beforeCreate：实例刚在内存中被创建出来，此时，还没有初始化好 data 和 methods 属性 created：实例已经在内存中创建OK，此时 data 和 methods 已经创建OK，此时还没有开始 编译模板 beforeMount：此时已经完成了模板的编译，但是还没有挂载到页面中 mounted：此时，已经将编译好的模板，挂载到了页面指定的容器中显示 运行期间的生命周期函数： beforeUpdate：状态更新之前执行此函数， 此时 data 中的状态值是最新的，但是界面上显示的 数据还是旧的，因为此时还没有开始重新渲染DOM节点 updated：实例更新完毕之后调用此函数，此时 data 中的状态值 和 界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了！ 销毁期间的生命周期函数： beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。 destroyed：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 vue-resource 实现 get, post, jsonp请求除了 vue-resource 之外，还可以使用 axios 的第三方包实现实现数据的请求 之前的学习中，如何发起数据请求？ 常见的数据请求类型？ get post jsonp 测试的URL请求资源地址： get请求地址： http://vue.studyit.io/api/getlunbo post请求地址：http://vue.studyit.io/api/post jsonp请求地址：http://vue.studyit.io/api/jsonp JSONP的实现原理 由于浏览器的安全性限制，不允许AJAX访问 协议不同、域名不同、端口号不同的 数据接口，浏览器认为这种访问不安全； 可以通过动态创建script标签的形式，把script标签的src属性，指向数据接口的地址，因为script标签不存在跨域限制，这种数据获取方式，称作JSONP（注意：根据JSONP的实现原理，知晓，JSONP只支持Get请求）； 具体实现过程： 先在客户端定义一个回调方法，预定义对数据的操作； 再把这个回调方法的名称，通过URL传参的形式，提交到服务器的数据接口； 服务器数据接口组织好要发送给客户端的数据，再拿着客户端传递过来的回调方法名称，拼接出一个调用这个方法的字符串，发送给客户端去解析执行； 客户端拿到服务器返回的字符串之后，当作Script脚本去解析执行，这样就能够拿到JSONP的数据了； 带大家通过 Node.js ，来手动实现一个JSONP的请求例子；1234567891011121314151617181920212223242526272829303132333435const http = require('http');// 导入解析 URL 地址的核心模块const urlModule = require('url');const server = http.createServer();// 监听 服务器的 request 请求事件，处理每个请求server.on('request', (req, res) =&gt; &#123; const url = req.url; // 解析客户端请求的URL地址 var info = urlModule.parse(url, true); // 如果请求的 URL 地址是 /getjsonp ，则表示要获取JSONP类型的数据 if (info.pathname === '/getjsonp') &#123; // 获取客户端指定的回调函数的名称 var cbName = info.query.callback; // 手动拼接要返回给客户端的数据对象 var data = &#123; name: 'zs', age: 22, gender: '男', hobby: ['吃饭', '睡觉', '运动'] &#125; // 拼接出一个方法的调用，在调用这个方法的时候，把要发送给客户端的数据，序列化为字符串，作为参数传递给这个调用的方法： var result = `$&#123;cbName&#125;($&#123;JSON.stringify(data)&#125;)`; // 将拼接好的方法的调用，返回给客户端去解析执行 res.end(result); &#125; else &#123; res.end('404'); &#125;&#125;);server.listen(3000, () =&gt; &#123; console.log('server running at http://127.0.0.1:3000');&#125;); vue-resource 的配置步骤： 直接在页面中，通过script标签，引入 vue-resource 的脚本文件； 注意：引用的先后顺序是：先引用 Vue 的脚本文件，再引用 vue-resource 的脚本文件； 发送get请求： 12345getInfo() &#123; // get 方式获取数据 this.$http.get('http://127.0.0.1:8899/api/getlunbo').then(res =&gt; &#123; console.log(res.body); &#125;)&#125; 发送post请求： 12345678910postInfo() &#123; var url = 'http://127.0.0.1:8899/api/post'; // post 方法接收三个参数： // 参数1： 要请求的URL地址 // 参数2： 要发送的数据对象 // 参数3： 指定post提交的编码类型为 application/x-www-form-urlencoded this.$http.post(url, &#123; name: 'zs' &#125;, &#123; emulateJSON: true &#125;).then(res =&gt; &#123; console.log(res.body); &#125;);&#125; 发送JSONP请求获取数据： 123456jsonpInfo() &#123; // JSONP形式从服务器获取数据 var url = 'http://127.0.0.1:8899/api/jsonp'; this.$http.jsonp(url).then(res =&gt; &#123; console.log(res.body); &#125;);&#125; 配置本地数据库和数据接口API 先解压安装 PHPStudy; 解压安装 Navicat 这个数据库可视化工具，并激活； 打开 Navicat 工具，新建空白数据库，名为 dtcmsdb4; 双击新建的数据库，连接上这个空白数据库，在新建的数据库上右键 -&gt; 运行SQL文件，选择并执行 dtcmsdb4.sql 这个数据库脚本文件；如果执行不报错，则数据库导入完成； 进入文件夹 vuecms3_nodejsapi 内部，执行 npm i 安装所有的依赖项； 先确保本机安装了 nodemon, 没有安装，则运行 npm i nodemon -g 进行全局安装，安装完毕后，进入到 vuecms3_nodejsapi目录 -&gt; src目录 -&gt; 双击运行 start.bat 如果API启动失败，请检查 PHPStudy 是否正常开启，同时，检查 app.js 中第 14行 中数据库连接配置字符串是否正确；PHPStudy 中默认的 用户名是root，默认的密码也是root 品牌管理改造展示品牌列表添加品牌数据删除品牌数据Vue中的动画为什么要有动画：动画能够提高用户的体验，帮助用户更好的理解页面中的功能； 使用过渡类名 HTML结构： 1234567&lt;div id="app"&gt; &lt;input type="button" value="动起来" @click="myAnimate"&gt; &lt;!-- 使用 transition 将需要过渡的元素包裹起来 --&gt; &lt;transition name="fade"&gt; &lt;div v-show="isshow"&gt;动画哦&lt;/div&gt; &lt;/transition&gt; &lt;/div&gt; VM 实例： 123456789101112// 创建 Vue 实例，得到 ViewModelvar vm = new Vue(&#123; el: '#app', data: &#123; isshow: false &#125;, methods: &#123; myAnimate() &#123; this.isshow = !this.isshow; &#125; &#125;&#125;); 定义两组类样式： 12345678910111213/* 定义进入和离开时候的过渡状态 */ .fade-enter-active, .fade-leave-active &#123; transition: all 0.2s ease; position: absolute; &#125; /* 定义进入过渡的开始状态 和 离开过渡的结束状态 */ .fade-enter, .fade-leave-to &#123; opacity: 0; transform: translateX(100px); &#125; 使用第三方 CSS 动画库 导入动画类库： 1&lt;link rel="stylesheet" type="text/css" href="./lib/animate.css"&gt; 定义 transition 及属性： 123456&lt;transition enter-active-class="fadeInRight" leave-active-class="fadeOutRight" :duration="&#123; enter: 500, leave: 800 &#125;"&gt; &lt;div class="animated" v-show="isshow"&gt;动画哦&lt;/div&gt;&lt;/transition&gt; 使用动画钩子函数 定义 transition 组件以及三个钩子函数： 123456789&lt;div id="app"&gt; &lt;input type="button" value="切换动画" @click="isshow = !isshow"&gt; &lt;transition @before-enter="beforeEnter" @enter="enter" @after-enter="afterEnter"&gt; &lt;div v-if="isshow" class="show"&gt;OK&lt;/div&gt; &lt;/transition&gt; &lt;/div&gt; 定义三个 methods 钩子方法： 12345678910111213methods: &#123; beforeEnter(el) &#123; // 动画进入之前的回调 el.style.transform = 'translateX(500px)'; &#125;, enter(el, done) &#123; // 动画进入完成时候的回调 el.offsetWidth; el.style.transform = 'translateX(0px)'; done(); &#125;, afterEnter(el) &#123; // 动画进入完成之后的回调 this.isshow = !this.isshow; &#125; &#125; 定义动画过渡时长和样式： 123.show&#123; transition: all 0.4s ease; &#125; v-for 的列表过渡 定义过渡样式： 123456789101112&lt;style&gt; .list-enter, .list-leave-to &#123; opacity: 0; transform: translateY(10px); &#125; .list-enter-active, .list-leave-active &#123; transition: all 0.3s ease; &#125;&lt;/style&gt; 定义DOM结构，其中，需要使用 transition-group 组件把v-for循环的列表包裹起来： 1234567&lt;div id="app"&gt; &lt;input type="text" v-model="txt" @keyup.enter="add"&gt; &lt;transition-group tag="ul" name="list"&gt; &lt;li v-for="(item, i) in list" :key="i"&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/transition-group&gt;&lt;/div&gt; 定义 VM中的结构： 1234567891011121314// 创建 Vue 实例，得到 ViewModelvar vm = new Vue(&#123; el: '#app', data: &#123; txt: '', list: [1, 2, 3, 4] &#125;, methods: &#123; add() &#123; this.list.push(this.txt); this.txt = ''; &#125; &#125;&#125;); 列表的排序过渡&lt;transition-group&gt; 组件还有一个特殊之处。不仅可以进入和离开动画，还可以改变定位。要使用这个新功能只需了解新增的 v-move 特性，它会在元素的改变定位的过程中应用。 v-move 和 v-leave-active 结合使用，能够让列表的过渡更加平缓柔和：123456.v-move&#123; transition: all 0.8s ease;&#125;.v-leave-active&#123; position: absolute;&#125; 相关文章 vue.js 1.x 文档 vue.js 2.x 文档 String.prototype.padStart(maxLength, fillString) js 里面的键盘事件对应的键码 pagekit/vue-resource navicat如何导入sql文件和导出sql文件 贝塞尔在线生成器]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue.js - day3]]></title>
    <url>%2F2019%2F06%2F04%2FVue.js%20-%20Day3%2F</url>
    <content type="text"><![CDATA[@[toc] Vue.js - Day3定义Vue组件什么是组件： 组件的出现，就是为了拆分Vue实例的代码量的，能够让我们以不同的组件，来划分不同的功能模块，将来我们需要什么样的功能，就可以去调用对应的组件即可；组件化和模块化的不同： 模块化： 是从代码逻辑的角度进行划分的；方便代码分层开发，保证每个功能模块的职能单一； 组件化： 是从UI界面的角度进行划分的；前端的组件化，方便UI组件的重用；全局组件定义的三种方式 使用 Vue.extend 配合 Vue.component 方法：1234var login = Vue.extend(&#123; template: '&lt;h1&gt;登录&lt;/h1&gt;' &#125;); Vue.component('login', login); 直接使用 Vue.component 方法： 123Vue.component('register', &#123; template: '&lt;h1&gt;注册&lt;/h1&gt;' &#125;); 将模板字符串，定义到script标签种： 123&lt;script id="tmpl" type="x-template"&gt; &lt;div&gt;&lt;a href="#"&gt;登录&lt;/a&gt; | &lt;a href="#"&gt;注册&lt;/a&gt;&lt;/div&gt; &lt;/script&gt; 同时，需要使用 Vue.component 来定义组件：123Vue.component('account', &#123; template: '#tmpl' &#125;); 注意： 组件中的DOM结构，有且只能有唯一的根元素（Root Element）来进行包裹！ 组件中展示数据和响应事件 在组件中，data需要被定义为一个方法，例如： 12345678910111213Vue.component('account', &#123; template: '#tmpl', data() &#123; return &#123; msg: '大家好！' &#125; &#125;, methods:&#123; login()&#123; alert('点击了登录按钮'); &#125; &#125; &#125;); 在子组件中，如果将模板字符串，定义到了script标签中，那么，要访问子组件身上的data属性中的值，需要使用this来访问； 【重点】为什么组件中的data属性必须定义为一个方法并返回一个对象 通过计数器案例演示 使用components属性定义局部子组件 组件实例定义方式： 123456789101112131415161718&lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125;, components: &#123; // 定义子组件 account: &#123; // account 组件 template: '&lt;div&gt;&lt;h1&gt;这是Account组件&#123;&#123;name&#125;&#125;&lt;/h1&gt;&lt;login&gt;&lt;/login&gt;&lt;/div&gt;', // 在这里使用定义的子组件 components: &#123; // 定义子组件的子组件 login: &#123; // login 组件 template: "&lt;h3&gt;这是登录组件&lt;/h3&gt;" &#125; &#125; &#125; &#125; &#125;); &lt;/script&gt; 引用组件： 123&lt;div id="app"&gt; &lt;account&gt;&lt;/account&gt; &lt;/div&gt; 使用flag标识符结合v-if和v-else切换组件 页面结构： 12345&lt;div id="app"&gt; &lt;input type="button" value="toggle" @click="flag=!flag"&gt; &lt;my-com1 v-if="flag"&gt;&lt;/my-com1&gt; &lt;my-com2 v-else="flag"&gt;&lt;/my-com2&gt; &lt;/div&gt; Vue实例定义： 123456789101112131415161718&lt;script&gt; Vue.component('myCom1', &#123; template: '&lt;h3&gt;奔波霸&lt;/h3&gt;' &#125;) Vue.component('myCom2', &#123; template: '&lt;h3&gt;霸波奔&lt;/h3&gt;' &#125;) // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; flag: true &#125;, methods: &#123;&#125; &#125;); &lt;/script&gt; 使用:is属性来切换不同的子组件,并添加切换动画 组件实例定义方式： 12345678910111213141516171819202122// 登录组件 const login = Vue.extend(&#123; template: `&lt;div&gt; &lt;h3&gt;登录组件&lt;/h3&gt; &lt;/div&gt;` &#125;); Vue.component('login', login); // 注册组件 const register = Vue.extend(&#123; template: `&lt;div&gt; &lt;h3&gt;注册组件&lt;/h3&gt; &lt;/div&gt;` &#125;); Vue.component('register', register); // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; comName: 'login' &#125;, methods: &#123;&#125; &#125;); 使用component标签，来引用组件，并通过:is属性来指定要加载的组件： 12345678&lt;div id="app"&gt; &lt;a href="#" @click.prevent="comName='login'"&gt;登录&lt;/a&gt; &lt;a href="#" @click.prevent="comName='register'"&gt;注册&lt;/a&gt; &lt;hr&gt; &lt;transition mode="out-in"&gt; &lt;component :is="comName"&gt;&lt;/component&gt; &lt;/transition&gt;&lt;/div&gt; 添加切换样式： 1234567891011121314151617&lt;style&gt; .v-enter, .v-leave-to &#123; opacity: 0; transform: translateX(30px); &#125; .v-enter-active, .v-leave-active &#123; position: absolute; transition: all 0.3s ease; &#125; h3&#123; margin: 0; &#125;&lt;/style&gt; 父组件向子组件传值 组件实例定义方式，注意：一定要使用props属性来定义父组件传递过来的数据 123456789101112131415&lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; msg: '这是父组件中的消息' &#125;, components: &#123; son: &#123; template: '&lt;h1&gt;这是子组件 --- &#123;&#123;finfo&#125;&#125;&lt;/h1&gt;', props: ['finfo'] &#125; &#125; &#125;); &lt;/script&gt; 使用v-bind或简化指令，将数据传递到子组件中： 123&lt;div id="app"&gt; &lt;son :finfo="msg"&gt;&lt;/son&gt; &lt;/div&gt; 子组件向父组件传值 原理：父组件将方法的引用，传递到子组件内部，子组件在内部调用父组件传递过来的方法，同时把要发送给父组件的数据，在调用方法的时候当作参数传递进去； 父组件将方法的引用传递给子组件，其中，getMsg是父组件中methods中定义的方法名称，func是子组件调用传递过来方法时候的方法名称 1&lt;son @func="getMsg"&gt;&lt;/son&gt; 子组件内部通过this.$emit(&#39;方法名&#39;, 要传递的数据)方式，来调用父组件中的方法，同时把数据传递给父组件使用 12345678910111213141516171819202122232425262728293031323334&lt;div id="app"&gt; &lt;!-- 引用父组件 --&gt; &lt;son @func="getMsg"&gt;&lt;/son&gt; &lt;!-- 组件模板定义 --&gt; &lt;script type="x-template" id="son"&gt; &lt;div&gt; &lt;input type="button" value="向父组件传值" @click="sendMsg" /&gt; &lt;/div&gt; &lt;/script&gt; &lt;/div&gt; &lt;script&gt; // 子组件的定义方式 Vue.component('son', &#123; template: '#son', // 组件模板Id methods: &#123; sendMsg() &#123; // 按钮的点击事件 this.$emit('func', 'OK'); // 调用父组件传递过来的方法，同时把数据传递出去 &#125; &#125; &#125;); // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123; getMsg(val)&#123; // 子组件中，通过 this.$emit() 实际调用的方法，在此进行定义 alert(val); &#125; &#125; &#125;); &lt;/script&gt; 评论列表案例目标：主要练习父子组件之间传值 使用 this.$refs 来获取元素和组件123456789101112131415161718192021222324252627282930313233343536&lt;div id="app"&gt; &lt;div&gt; &lt;input type="button" value="获取元素内容" @click="getElement" /&gt; &lt;!-- 使用 ref 获取元素 --&gt; &lt;h1 ref="myh1"&gt;这是一个大大的H1&lt;/h1&gt; &lt;hr&gt; &lt;!-- 使用 ref 获取子组件 --&gt; &lt;my-com ref="mycom"&gt;&lt;/my-com&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; Vue.component('my-com', &#123; template: '&lt;h5&gt;这是一个子组件&lt;/h5&gt;', data() &#123; return &#123; name: '子组件' &#125; &#125; &#125;); // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123; getElement() &#123; // 通过 this.$refs 来获取元素 console.log(this.$refs.myh1.innerText); // 通过 this.$refs 来获取组件 console.log(this.$refs.mycom.name); &#125; &#125; &#125;);&lt;/script&gt; 什么是路由 对于普通的网站，所有的超链接都是URL地址，所有的URL地址都对应服务器上对应的资源； 对于单页面应用程序来说，主要通过URL中的hash(#号)来实现不同页面之间的切换，同时，hash有一个特点：HTTP请求中不会包含hash相关的内容；所以，单页面程序中的页面跳转主要用hash实现； 在单页面应用程序中，这种通过hash改变来切换页面的方式，称作前端路由（区别于后端路由）； 在 vue 中使用 vue-router 导入 vue-router 组件类库： 12&lt;!-- 1. 导入 vue-router 组件类库 --&gt; &lt;script src="./lib/vue-router-2.7.0.js"&gt;&lt;/script&gt; 使用 router-link 组件来导航 123&lt;!-- 2. 使用 router-link 组件来导航 --&gt;&lt;router-link to="/login"&gt;登录&lt;/router-link&gt;&lt;router-link to="/register"&gt;注册&lt;/router-link&gt; 使用 router-view 组件来显示匹配到的组件 12&lt;!-- 3. 使用 router-view 组件来显示匹配到的组件 --&gt;&lt;router-view&gt;&lt;/router-view&gt; 创建使用Vue.extend创建组件 123456789// 4.1 使用 Vue.extend 来创建登录组件var login = Vue.extend(&#123; template: '&lt;h1&gt;登录组件&lt;/h1&gt;'&#125;);// 4.2 使用 Vue.extend 来创建注册组件var register = Vue.extend(&#123; template: '&lt;h1&gt;注册组件&lt;/h1&gt;'&#125;); 创建一个路由 router 实例，通过 routers 属性来定义路由匹配规则 1234567// 5. 创建一个路由 router 实例，通过 routers 属性来定义路由匹配规则 var router = new VueRouter(&#123; routes: [ &#123; path: '/login', component: login &#125;, &#123; path: '/register', component: register &#125; ] &#125;); 使用 router 属性来使用路由规则 12345// 6. 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', router: router // 使用 router 属性来使用路由规则 &#125;); 设置路由高亮设置路由切换动效在路由规则中定义参数 在规则中定义参数： 1&#123; path: '/register/:id', component: register &#125; 通过 this.$route.params来获取路由中的参数： 123var register = Vue.extend(&#123; template: '&lt;h1&gt;注册组件 --- &#123;&#123;this.$route.params.id&#125;&#125;&lt;/h1&gt;' &#125;); 使用 children 属性实现路由嵌套1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;div id="app"&gt; &lt;router-link to="/account"&gt;Account&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;&lt;script&gt; // 父路由中的组件 const account = Vue.extend(&#123; template: `&lt;div&gt; 这是account组件 &lt;router-link to="/account/login"&gt;login&lt;/router-link&gt; | &lt;router-link to="/account/register"&gt;register&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;` &#125;); // 子路由中的 login 组件 const login = Vue.extend(&#123; template: '&lt;div&gt;登录组件&lt;/div&gt;' &#125;); // 子路由中的 register 组件 const register = Vue.extend(&#123; template: '&lt;div&gt;注册组件&lt;/div&gt;' &#125;); // 路由实例 var router = new VueRouter(&#123; routes: [ &#123; path: '/', redirect: '/account/login' &#125;, // 使用 redirect 实现路由重定向 &#123; path: '/account', component: account, children: [ // 通过 children 数组属性，来实现路由的嵌套 &#123; path: 'login', component: login &#125;, // 注意，子路由的开头位置，不要加 / 路径符 &#123; path: 'register', component: register &#125; ] &#125; ] &#125;); // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125;, components: &#123; account &#125;, router: router &#125;);&lt;/script&gt; 命名视图实现经典布局 标签代码结构： 1234567&lt;div id="app"&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;div class="content"&gt; &lt;router-view name="a"&gt;&lt;/router-view&gt; &lt;router-view name="b"&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt; JS代码： 12345678910111213141516171819202122232425262728293031323334&lt;script&gt; var header = Vue.component('header', &#123; template: '&lt;div class="header"&gt;header&lt;/div&gt;' &#125;); var sidebar = Vue.component('sidebar', &#123; template: '&lt;div class="sidebar"&gt;sidebar&lt;/div&gt;' &#125;); var mainbox = Vue.component('mainbox', &#123; template: '&lt;div class="mainbox"&gt;mainbox&lt;/div&gt;' &#125;); // 创建路由对象 var router = new VueRouter(&#123; routes: [ &#123; path: '/', components: &#123; default: header, a: sidebar, b: mainbox &#125; &#125; ] &#125;); // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125;, router &#125;); &lt;/script&gt; CSS 样式： 12345678910111213141516171819&lt;style&gt; .header &#123; border: 1px solid red; &#125; .content&#123; display: flex; &#125; .sidebar &#123; flex: 2; border: 1px solid green; height: 500px; &#125; .mainbox&#123; flex: 8; border: 1px solid blue; height: 500px; &#125;&lt;/style&gt; watch属性的使用考虑一个问题：想要实现 名 和 姓 两个文本框的内容改变，则全名的文本框中的值也跟着改变；（用以前的知识如何实现？？？） 监听data中属性的改变： 1234567891011121314151617181920212223242526&lt;div id="app"&gt; &lt;input type="text" v-model="firstName"&gt; + &lt;input type="text" v-model="lastName"&gt; = &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; firstName: 'jack', lastName: 'chen', fullName: 'jack - chen' &#125;, methods: &#123;&#125;, watch: &#123; 'firstName': function (newVal, oldVal) &#123; // 第一个参数是新数据，第二个参数是旧数据 this.fullName = newVal + ' - ' + this.lastName; &#125;, 'lastName': function (newVal, oldVal) &#123; this.fullName = this.firstName + ' - ' + newVal; &#125; &#125; &#125;); &lt;/script&gt; 监听路由对象的改变： 1234567891011121314151617181920212223242526272829303132333435363738&lt;div id="app"&gt; &lt;router-link to="/login"&gt;登录&lt;/router-link&gt; &lt;router-link to="/register"&gt;注册&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script&gt; var login = Vue.extend(&#123; template: '&lt;h1&gt;登录组件&lt;/h1&gt;' &#125;); var register = Vue.extend(&#123; template: '&lt;h1&gt;注册组件&lt;/h1&gt;' &#125;); var router = new VueRouter(&#123; routes: [ &#123; path: "/login", component: login &#125;, &#123; path: "/register", component: register &#125; ] &#125;); // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125;, router: router, watch: &#123; '$route': function (newVal, oldVal) &#123; if (newVal.path === '/login') &#123; console.log('这是登录组件'); &#125; &#125; &#125; &#125;); &lt;/script&gt; computed计算属性的使用 默认只有getter的计算属性： 12345678910111213141516171819202122&lt;div id="app"&gt; &lt;input type="text" v-model="firstName"&gt; + &lt;input type="text" v-model="lastName"&gt; = &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; firstName: 'jack', lastName: 'chen' &#125;, methods: &#123;&#125;, computed: &#123; // 计算属性； 特点：当计算属性中所以来的任何一个 data 属性改变之后，都会重新触发 本计算属性 的重新计算，从而更新 fullName 的值 fullName() &#123; return this.firstName + ' - ' + this.lastName; &#125; &#125; &#125;); &lt;/script&gt; 定义有getter和setter的计算属性： 123456789101112131415161718192021222324252627282930313233343536&lt;div id="app"&gt; &lt;input type="text" v-model="firstName"&gt; &lt;input type="text" v-model="lastName"&gt; &lt;!-- 点击按钮重新为 计算属性 fullName 赋值 --&gt; &lt;input type="button" value="修改fullName" @click="changeName"&gt; &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; firstName: 'jack', lastName: 'chen' &#125;, methods: &#123; changeName() &#123; this.fullName = 'TOM - chen2'; &#125; &#125;, computed: &#123; fullName: &#123; get: function () &#123; return this.firstName + ' - ' + this.lastName; &#125;, set: function (newVal) &#123; var parts = newVal.split(' - '); this.firstName = parts[0]; this.lastName = parts[1]; &#125; &#125; &#125; &#125;); &lt;/script&gt; watch、computed和methods之间的对比 computed属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。主要当作属性来使用； methods方法表示一个具体的操作，主要书写业务逻辑； watch一个对象，键是需要观察的表达式，值是对应回调函数。主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作；可以看作是computed和methods的结合体； nrm的安装使用作用：提供了一些最常用的NPM包镜像地址，能够让我们快速的切换安装包时候的服务器地址；什么是镜像：原来包刚一开始是只存在于国外的NPM服务器，但是由于网络原因，经常访问不到，这时候，我们可以在国内，创建一个和官网完全一样的NPM服务器，只不过，数据都是从人家那里拿过来的，除此之外，使用方式完全一样； 运行npm i nrm -g全局安装nrm包； 使用nrm ls查看当前所有可用的镜像源地址以及当前所使用的镜像源地址； 使用nrm use npm或nrm use taobao切换不同的镜像源地址； 相关文件 URL中的hash（井号）]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue.js - day4]]></title>
    <url>%2F2019%2F06%2F04%2FVue.js%20-%20Day4%2F</url>
    <content type="text"><![CDATA[@[toc] Vue.js - Day4父组件向子组件传值 组件实例定义方式，注意：一定要使用props属性来定义父组件传递过来的数据 123456789101112131415&lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; msg: '这是父组件中的消息' &#125;, components: &#123; son: &#123; template: '&lt;h1&gt;这是子组件 --- &#123;&#123;finfo&#125;&#125;&lt;/h1&gt;', props: ['finfo'] &#125; &#125; &#125;); &lt;/script&gt; 使用v-bind或简化指令，将数据传递到子组件中： 123&lt;div id="app"&gt; &lt;son :finfo="msg"&gt;&lt;/son&gt; &lt;/div&gt; 子组件向父组件传值 原理：父组件将方法的引用，传递到子组件内部，子组件在内部调用父组件传递过来的方法，同时把要发送给父组件的数据，在调用方法的时候当作参数传递进去； 父组件将方法的引用传递给子组件，其中，getMsg是父组件中methods中定义的方法名称，func是子组件调用传递过来方法时候的方法名称 1&lt;son @func="getMsg"&gt;&lt;/son&gt; 子组件内部通过this.$emit(&#39;方法名&#39;, 要传递的数据)方式，来调用父组件中的方法，同时把数据传递给父组件使用 12345678910111213141516171819202122232425262728293031323334&lt;div id="app"&gt; &lt;!-- 引用父组件 --&gt; &lt;son @func="getMsg"&gt;&lt;/son&gt; &lt;!-- 组件模板定义 --&gt; &lt;script type="x-template" id="son"&gt; &lt;div&gt; &lt;input type="button" value="向父组件传值" @click="sendMsg" /&gt; &lt;/div&gt; &lt;/script&gt; &lt;/div&gt; &lt;script&gt; // 子组件的定义方式 Vue.component('son', &#123; template: '#son', // 组件模板Id methods: &#123; sendMsg() &#123; // 按钮的点击事件 this.$emit('func', 'OK'); // 调用父组件传递过来的方法，同时把数据传递出去 &#125; &#125; &#125;); // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123; getMsg(val)&#123; // 子组件中，通过 this.$emit() 实际调用的方法，在此进行定义 alert(val); &#125; &#125; &#125;); &lt;/script&gt; 组件中data和props的区别评论列表案例目标：主要练习父子组件之间传值 使用 this.$refs 来获取元素和组件123456789101112131415161718192021222324252627282930313233343536&lt;div id="app"&gt; &lt;div&gt; &lt;input type="button" value="获取元素内容" @click="getElement" /&gt; &lt;!-- 使用 ref 获取元素 --&gt; &lt;h1 ref="myh1"&gt;这是一个大大的H1&lt;/h1&gt; &lt;hr&gt; &lt;!-- 使用 ref 获取子组件 --&gt; &lt;my-com ref="mycom"&gt;&lt;/my-com&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; Vue.component('my-com', &#123; template: '&lt;h5&gt;这是一个子组件&lt;/h5&gt;', data() &#123; return &#123; name: '子组件' &#125; &#125; &#125;); // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123; getElement() &#123; // 通过 this.$refs 来获取元素 console.log(this.$refs.myh1.innerText); // 通过 this.$refs 来获取组件 console.log(this.$refs.mycom.name); &#125; &#125; &#125;);&lt;/script&gt; 什么是路由 后端路由：对于普通的网站，所有的超链接都是URL地址，所有的URL地址都对应服务器上对应的资源； 前端路由：对于单页面应用程序来说，主要通过URL中的hash(#号)来实现不同页面之间的切换，同时，hash有一个特点：HTTP请求中不会包含hash相关的内容；所以，单页面程序中的页面跳转主要用hash实现； 在单页面应用程序中，这种通过hash改变来切换页面的方式，称作前端路由（区别于后端路由）； 在 vue 中使用 vue-router 导入 vue-router 组件类库： 12&lt;!-- 1. 导入 vue-router 组件类库 --&gt; &lt;script src="./lib/vue-router-2.7.0.js"&gt;&lt;/script&gt; 使用 router-link 组件来导航 123&lt;!-- 2. 使用 router-link 组件来导航 --&gt;&lt;router-link to="/login"&gt;登录&lt;/router-link&gt;&lt;router-link to="/register"&gt;注册&lt;/router-link&gt; 使用 router-view 组件来显示匹配到的组件 12&lt;!-- 3. 使用 router-view 组件来显示匹配到的组件 --&gt;&lt;router-view&gt;&lt;/router-view&gt; 创建使用Vue.extend创建组件 123456789// 4.1 使用 Vue.extend 来创建登录组件var login = Vue.extend(&#123; template: '&lt;h1&gt;登录组件&lt;/h1&gt;'&#125;);// 4.2 使用 Vue.extend 来创建注册组件var register = Vue.extend(&#123; template: '&lt;h1&gt;注册组件&lt;/h1&gt;'&#125;); 创建一个路由 router 实例，通过 routers 属性来定义路由匹配规则 1234567// 5. 创建一个路由 router 实例，通过 routers 属性来定义路由匹配规则 var router = new VueRouter(&#123; routes: [ &#123; path: '/login', component: login &#125;, &#123; path: '/register', component: register &#125; ] &#125;); 使用 router 属性来使用路由规则 12345// 6. 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', router: router // 使用 router 属性来使用路由规则 &#125;); 使用tag属性指定router-link渲染的标签类型设置路由重定向设置路由高亮设置路由切换动效在路由规则中定义参数 在规则中定义参数： 1&#123; path: '/register/:id', component: register &#125; 通过 this.$route.params来获取路由中的参数： 123var register = Vue.extend(&#123; template: '&lt;h1&gt;注册组件 --- &#123;&#123;this.$route.params.id&#125;&#125;&lt;/h1&gt;' &#125;); 使用 children 属性实现路由嵌套1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;div id="app"&gt; &lt;router-link to="/account"&gt;Account&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;&lt;script&gt; // 父路由中的组件 const account = Vue.extend(&#123; template: `&lt;div&gt; 这是account组件 &lt;router-link to="/account/login"&gt;login&lt;/router-link&gt; | &lt;router-link to="/account/register"&gt;register&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;` &#125;); // 子路由中的 login 组件 const login = Vue.extend(&#123; template: '&lt;div&gt;登录组件&lt;/div&gt;' &#125;); // 子路由中的 register 组件 const register = Vue.extend(&#123; template: '&lt;div&gt;注册组件&lt;/div&gt;' &#125;); // 路由实例 var router = new VueRouter(&#123; routes: [ &#123; path: '/', redirect: '/account/login' &#125;, // 使用 redirect 实现路由重定向 &#123; path: '/account', component: account, children: [ // 通过 children 数组属性，来实现路由的嵌套 &#123; path: 'login', component: login &#125;, // 注意，子路由的开头位置，不要加 / 路径符 &#123; path: 'register', component: register &#125; ] &#125; ] &#125;); // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125;, components: &#123; account &#125;, router: router &#125;);&lt;/script&gt; 命名视图实现经典布局 标签代码结构： 1234567&lt;div id="app"&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;div class="content"&gt; &lt;router-view name="a"&gt;&lt;/router-view&gt; &lt;router-view name="b"&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt; JS代码： 12345678910111213141516171819202122232425262728293031323334&lt;script&gt; var header = Vue.component('header', &#123; template: '&lt;div class="header"&gt;header&lt;/div&gt;' &#125;); var sidebar = Vue.component('sidebar', &#123; template: '&lt;div class="sidebar"&gt;sidebar&lt;/div&gt;' &#125;); var mainbox = Vue.component('mainbox', &#123; template: '&lt;div class="mainbox"&gt;mainbox&lt;/div&gt;' &#125;); // 创建路由对象 var router = new VueRouter(&#123; routes: [ &#123; path: '/', components: &#123; default: header, a: sidebar, b: mainbox &#125; &#125; ] &#125;); // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125;, router &#125;); &lt;/script&gt; CSS 样式： 12345678910111213141516171819&lt;style&gt; .header &#123; border: 1px solid red; &#125; .content&#123; display: flex; &#125; .sidebar &#123; flex: 2; border: 1px solid green; height: 500px; &#125; .mainbox&#123; flex: 8; border: 1px solid blue; height: 500px; &#125;&lt;/style&gt; watch属性的使用考虑一个问题：想要实现 名 和 姓 两个文本框的内容改变，则全名的文本框中的值也跟着改变；（用以前的知识如何实现？？？） 监听data中属性的改变： 1234567891011121314151617181920212223242526&lt;div id="app"&gt; &lt;input type="text" v-model="firstName"&gt; + &lt;input type="text" v-model="lastName"&gt; = &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; firstName: 'jack', lastName: 'chen', fullName: 'jack - chen' &#125;, methods: &#123;&#125;, watch: &#123; 'firstName': function (newVal, oldVal) &#123; // 第一个参数是新数据，第二个参数是旧数据 this.fullName = newVal + ' - ' + this.lastName; &#125;, 'lastName': function (newVal, oldVal) &#123; this.fullName = this.firstName + ' - ' + newVal; &#125; &#125; &#125;); &lt;/script&gt; 监听路由对象的改变： 1234567891011121314151617181920212223242526272829303132333435363738&lt;div id="app"&gt; &lt;router-link to="/login"&gt;登录&lt;/router-link&gt; &lt;router-link to="/register"&gt;注册&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script&gt; var login = Vue.extend(&#123; template: '&lt;h1&gt;登录组件&lt;/h1&gt;' &#125;); var register = Vue.extend(&#123; template: '&lt;h1&gt;注册组件&lt;/h1&gt;' &#125;); var router = new VueRouter(&#123; routes: [ &#123; path: "/login", component: login &#125;, &#123; path: "/register", component: register &#125; ] &#125;); // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125;, router: router, watch: &#123; '$route': function (newVal, oldVal) &#123; if (newVal.path === '/login') &#123; console.log('这是登录组件'); &#125; &#125; &#125; &#125;); &lt;/script&gt; computed计算属性的使用 默认只有getter的计算属性： 12345678910111213141516171819202122&lt;div id="app"&gt; &lt;input type="text" v-model="firstName"&gt; + &lt;input type="text" v-model="lastName"&gt; = &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; firstName: 'jack', lastName: 'chen' &#125;, methods: &#123;&#125;, computed: &#123; // 计算属性； 特点：当计算属性中所以来的任何一个 data 属性改变之后，都会重新触发 本计算属性 的重新计算，从而更新 fullName 的值 fullName() &#123; return this.firstName + ' - ' + this.lastName; &#125; &#125; &#125;); &lt;/script&gt; 定义有getter和setter的计算属性： 123456789101112131415161718192021222324252627282930313233343536&lt;div id="app"&gt; &lt;input type="text" v-model="firstName"&gt; &lt;input type="text" v-model="lastName"&gt; &lt;!-- 点击按钮重新为 计算属性 fullName 赋值 --&gt; &lt;input type="button" value="修改fullName" @click="changeName"&gt; &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; firstName: 'jack', lastName: 'chen' &#125;, methods: &#123; changeName() &#123; this.fullName = 'TOM - chen2'; &#125; &#125;, computed: &#123; fullName: &#123; get: function () &#123; return this.firstName + ' - ' + this.lastName; &#125;, set: function (newVal) &#123; var parts = newVal.split(' - '); this.firstName = parts[0]; this.lastName = parts[1]; &#125; &#125; &#125; &#125;); &lt;/script&gt; watch、computed和methods之间的对比 computed属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。主要当作属性来使用； methods方法表示一个具体的操作，主要书写业务逻辑； watch一个对象，键是需要观察的表达式，值是对应回调函数。主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作；可以看作是computed和methods的结合体； nrm的安装使用作用：提供了一些最常用的NPM包镜像地址，能够让我们快速的切换安装包时候的服务器地址；什么是镜像：原来包刚一开始是只存在于国外的NPM服务器，但是由于网络原因，经常访问不到，这时候，我们可以在国内，创建一个和官网完全一样的NPM服务器，只不过，数据都是从人家那里拿过来的，除此之外，使用方式完全一样； 运行npm i nrm -g全局安装nrm包； 使用nrm ls查看当前所有可用的镜像源地址以及当前所使用的镜像源地址； 使用nrm use npm或nrm use taobao切换不同的镜像源地址； 相关文件 URL中的hash（井号）]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue.js - day5]]></title>
    <url>%2F2019%2F06%2F04%2FVue.js%20-%20Day5%20-%20Webpack%2F</url>
    <content type="text"><![CDATA[@[toc] Vue.js - Day5 - Webpack在网页中会引用哪些常见的静态资源？ JS .js .jsx .coffee .ts（TypeScript 类 C# 语言） CSS .css .less .sass .scss Images .jpg .png .gif .bmp .svg 字体文件（Fonts） .svg .ttf .eot .woff .woff2 模板文件 .ejs .jade .vue【这是在webpack中定义组件的方式，推荐这么用】 网页中引入的静态资源多了以后有什么问题？？？ 网页加载速度慢， 因为 我们要发起很多的二次请求； 要处理错综复杂的依赖关系 如何解决上述两个问题 合并、压缩、精灵图、图片的Base64编码 可以使用之前学过的requireJS、也可以使用webpack可以解决各个包之间的复杂依赖关系； 什么是webpack?webpack 是前端的一个项目构建工具，它是基于 Node.js 开发出来的一个前端工具； 如何完美实现上述的2种解决方案 使用Gulp， 是基于 task 任务的； 使用Webpack， 是基于整个项目进行构建的； 借助于webpack这个前端自动化构建工具，可以完美实现资源的合并、打包、压缩、混淆等诸多功能。 根据官网的图片介绍webpack打包的过程 webpack官网 webpack安装的两种方式 运行npm i webpack -g全局安装webpack，这样就能在全局使用webpack的命令 在项目根目录中运行npm i webpack --save-dev安装到项目依赖中 初步使用webpack打包构建列表隔行变色案例 运行npm init初始化项目，使用npm管理项目中的依赖包 创建项目基本的目录结构 使用cnpm i jquery --save安装jquery类库 创建main.js并书写各行变色的代码逻辑： 1234567// 导入jquery类库 import $ from 'jquery' // 设置偶数行背景色，索引从0开始，0是偶数 $('#list li:even').css('backgroundColor','lightblue'); // 设置奇数行背景色 $('#list li:odd').css('backgroundColor','pink'); 直接在页面上引用main.js会报错，因为浏览器不认识import这种高级的JS语法，需要使用webpack进行处理，webpack默认会把这种高级的语法转换为低级的浏览器能识别的语法； 运行webpack 入口文件路径 输出文件路径对main.js进行处理：1webpack src/js/main.js dist/bundle.js 使用webpack的配置文件简化打包时候的命令 在项目根目录中创建webpack.config.js 由于运行webpack命令的时候，webpack需要指定入口文件和输出文件的路径，所以，我们需要在webpack.config.js中配置这两个路径：1234567891011// 导入处理路径的模块var path = require('path');// 导出一个配置对象，将来webpack在启动的时候，会默认来查找webpack.config.js，并读取这个文件中导出的配置对象，来进行打包处理module.exports = &#123; entry: path.resolve(__dirname, 'src/js/main.js'), // 项目入口文件 output: &#123; // 配置输出选项 path: path.resolve(__dirname, 'dist'), // 配置输出的路径 filename: 'bundle.js' // 配置输出的文件名 &#125;&#125; 实现webpack的实时打包构建 由于每次重新修改代码之后，都需要手动运行webpack打包的命令，比较麻烦，所以使用webpack-dev-server来实现代码实时打包编译，当修改代码之后，会自动进行打包构建。 运行cnpm i webpack-dev-server --save-dev安装到开发依赖 安装完成之后，在命令行直接运行webpack-dev-server来进行打包，发现报错，此时需要借助于package.json文件中的指令，来进行运行webpack-dev-server命令，在scripts节点下新增&quot;dev&quot;: &quot;webpack-dev-server&quot;指令，发现可以进行实时打包，但是dist目录下并没有生成bundle.js文件，这是因为webpack-dev-server将打包好的文件放在了内存中 把bundle.js放在内存中的好处是：由于需要实时打包编译，所以放在内存中速度会非常快 这个时候访问webpack-dev-server启动的http://localhost:8080/网站，发现是一个文件夹的面板，需要点击到src目录下，才能打开我们的index首页，此时引用不到bundle.js文件，需要修改index.html中script的src属性为:&lt;script src=&quot;../bundle.js&quot;&gt;&lt;/script&gt; 为了能在访问http://localhost:8080/的时候直接访问到index首页，可以使用--contentBase src指令来修改dev指令，指定启动的根目录：1"dev": "webpack-dev-server --contentBase src" 同时修改index页面中script的src属性为&lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt; 使用html-webpack-plugin插件配置启动页面由于使用--contentBase指令的过程比较繁琐，需要指定启动的目录，同时还需要修改index.html中script标签的src属性，所以推荐大家使用html-webpack-plugin插件配置启动页面. 运行cnpm i html-webpack-plugin --save-dev安装到开发依赖 修改webpack.config.js配置文件如下： 123456789101112131415161718// 导入处理路径的模块var path = require('path');// 导入自动生成HTMl文件的插件var htmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; entry: path.resolve(__dirname, 'src/js/main.js'), // 项目入口文件 output: &#123; // 配置输出选项 path: path.resolve(__dirname, 'dist'), // 配置输出的路径 filename: 'bundle.js' // 配置输出的文件名 &#125;, plugins:[ // 添加plugins节点配置插件 new htmlWebpackPlugin(&#123; template:path.resolve(__dirname, 'src/index.html'),//模板路径 filename:'index.html'//自动生成的HTML文件的名称 &#125;) ]&#125; 修改package.json中script节点中的dev指令如下： 1"dev": "webpack-dev-server" 将index.html中script标签注释掉，因为html-webpack-plugin插件会自动把bundle.js注入到index.html页面中！ 实现自动打开浏览器、热更新和配置浏览器的默认端口号注意：热更新在JS中表现的不明显，可以从一会儿要讲到的CSS身上进行介绍说明！ 方式1： 修改package.json的script节点如下，其中--open表示自动打开浏览器，--port 4321表示打开的端口号为4321，--hot表示启用浏览器热更新：1"dev": "webpack-dev-server --hot --port 4321 --open" 方式2： 修改webpack.config.js文件，新增devServer节点如下： 12345devServer:&#123; hot:true, open:true, port:4321 &#125; 在头部引入webpack模块： 1var webpack = require('webpack'); 在plugins节点下新增： 1new webpack.HotModuleReplacementPlugin() 使用webpack打包css文件 运行cnpm i style-loader css-loader --save-dev 修改webpack.config.js这个配置文件： 12345module: &#123; // 用来配置第三方loader模块的 rules: [ // 文件的匹配规则 &#123; test: /\.css$/, use: ['style-loader', 'css-loader'] &#125;//处理css文件的规则 ] &#125; 注意：use表示使用哪些模块来处理test所匹配到的文件；use中相关loader模块的调用顺序是从后向前调用的； 使用webpack打包less文件 运行cnpm i less-loader less -D 修改webpack.config.js这个配置文件：1&#123; test: /\.less$/, use: ['style-loader', 'css-loader', 'less-loader'] &#125;, 使用webpack打包sass文件 运行cnpm i sass-loader node-sass --save-dev 在webpack.config.js中添加处理sass文件的loader模块：1&#123; test: /\.scss$/, use: ['style-loader', 'css-loader', 'sass-loader'] &#125; 使用webpack处理css中的路径 运行cnpm i url-loader file-loader --save-dev 在webpack.config.js中添加处理url路径的loader模块： 1&#123; test: /\.(png|jpg|gif)$/, use: 'url-loader' &#125; 可以通过limit指定进行base64编码的图片大小；只有小于指定字节（byte）的图片才会进行base64编码： 1&#123; test: /\.(png|jpg|gif)$/, use: 'url-loader?limit=43960' &#125;, 使用babel处理高级JS语法 运行cnpm i babel-core babel-loader babel-plugin-transform-runtime --save-dev安装babel的相关loader包 运行cnpm i babel-preset-es2015 babel-preset-stage-0 --save-dev安装babel转换的语法 在webpack.config.js中添加相关loader模块，其中需要注意的是，一定要把node_modules文件夹添加到排除项： 1&#123; test: /\.js$/, use: 'babel-loader', exclude: /node_modules/ &#125; 在项目根目录中添加.babelrc文件，并修改这个配置文件如下： 1234&#123; "presets":["es2015", "stage-0"], "plugins":["transform-runtime"]&#125; 注意：语法插件babel-preset-es2015可以更新为babel-preset-env，它包含了所有的ES相关的语法； 相关文章babel-preset-env：你需要的唯一Babel插件Runtime transform 运行时编译es6]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue.js - day6]]></title>
    <url>%2F2019%2F06%2F04%2FVue.js%20-%20day6%2F</url>
    <content type="text"><![CDATA[[TOC] Vue.js - day6注意：有时候使用npm i node-sass -D装不上，这时候，就必须使用 cnpm i node-sass -D 在普通页面中使用render函数渲染组件在webpack中配置.vue组件页面的解析 运行cnpm i vue -S将vue安装为运行依赖； 运行cnpm i vue-loader vue-template-compiler -D将解析转换vue的包安装为开发依赖； 运行cnpm i style-loader css-loader -D将解析转换CSS的包安装为开发依赖，因为.vue文件中会写CSS样式； 在webpack.config.js中，添加如下module规则： 123456789101112module: &#123; rules: [ &#123; test: /\.css$/, use: ['style-loader', 'css-loader'] &#125;, &#123; test: /\.vue$/, use: 'vue-loader' &#125; ] &#125; 创建App.js组件页面： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;template&gt; &lt;!-- 注意：在 .vue 的组件中，template 中必须有且只有唯一的根元素进行包裹，一般都用 div 当作唯一的根元素 --&gt; &lt;div&gt; &lt;h1&gt;这是APP组件 - &#123;&#123;msg&#125;&#125;&lt;/h1&gt; &lt;h3&gt;我是h3&lt;/h3&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// 注意：在 .vue 的组件中，通过 script 标签来定义组件的行为，需要使用 ES6 中提供的 export default 方式，导出一个vue实例对象export default &#123; data() &#123; return &#123; msg: 'OK' &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;h1 &#123; color: red;&#125;&lt;/style&gt; 创建main.js入口文件： 12345678910111213141516171819202122// 导入 Vue 组件import Vue from 'vue'// 导入 App组件import App from './components/App.vue'// 创建一个 Vue 实例，使用 render 函数，渲染指定的组件var vm = new Vue(&#123; el: '#app', render: c =&gt; c(App)&#125;); 在使用webpack构建的Vue项目中使用模板对象？ 在webpack.config.js中添加resolve属性：12345resolve: &#123; alias: &#123; 'vue$': 'vue/dist/vue.esm.js' &#125; &#125; ES6中语法使用总结 使用 export default 和 export 导出模块中的成员; 对应ES5中的 module.exports 和 export 使用 import ** from ** 和 import &#39;路径&#39; 还有 import {a, b} from &#39;模块标识&#39; 导入其他模块 使用箭头函数：(a, b)=&gt; { return a-b; } 在vue组件页面中，集成vue-router路由模块vue-router官网 导入路由模块： 12import VueRouter from 'vue-router' 安装路由模块： 12Vue.use(VueRouter); 导入需要展示的组件: 1234import login from './components/account/login.vue'import register from './components/account/register.vue' 创建路由对象: 1234567891011121314var router = new VueRouter(&#123; routes: [ &#123; path: '/', redirect: '/login' &#125;, &#123; path: '/login', component: login &#125;, &#123; path: '/register', component: register &#125; ]&#125;); 将路由对象，挂载到 Vue 实例上: 12345678910111213141516var vm = new Vue(&#123; el: '#app', // render: c =&gt; &#123; return c(App) &#125; render(c) &#123; return c(App); &#125;, router // 将路由对象，挂载到 Vue 实例上&#125;); 改造App.vue组件，在 template 中，添加router-link和router-view： 12345678&lt;router-link to="/login"&gt;登录&lt;/router-link&gt;&lt;router-link to="/register"&gt;注册&lt;/router-link&gt;&lt;router-view&gt;&lt;/router-view&gt; 组件中的css作用域问题抽离路由为单独的模块使用 饿了么的 MintUI 组件Github 仓储地址 Mint-UI官方文档 导入所有MintUI组件： 12import MintUI from 'mint-ui' 导入样式表： 12import 'mint-ui/lib/style.css' 在 vue 中使用 MintUI： 12Vue.use(MintUI) 使用的例子： 12&lt;mt-button type="primary" size="large"&gt;primary&lt;/mt-button&gt; 使用 MUI 组件官网首页 文档地址 导入 MUI 的样式表： 12import '../lib/mui/css/mui.min.css' 在webpack.config.js中添加新的loader规则： 12&#123; test: /\.(png|jpg|gif|ttf)$/, use: 'url-loader' &#125; 根据官方提供的文档和example，尝试使用相关的组件 将项目源码托管到oschina中 点击头像 -&gt; 修改资料 -&gt; SSH公钥 如何生成SSH公钥 创建自己的空仓储，使用 git config --global user.name &quot;用户名&quot; 和 git config --global user.email ***@**.com 来全局配置提交时用户的名称和邮箱 使用 git init 在本地初始化项目 使用 touch README.md 和 touch .gitignore 来创建项目的说明文件和忽略文件； 使用 git add . 将所有文件托管到 git 中 使用 git commit -m &quot;init project&quot; 将项目进行本地提交 使用 git remote add origin 仓储地址将本地项目和远程仓储连接，并使用origin最为远程仓储的别名 使用 git push -u origin master 将本地代码push到仓储中 App.vue 组件的基本设置 头部的固定导航栏使用 Mint-UI 的 Header 组件； 底部的页签使用 mui 的 tabbar; 购物车的图标，使用 icons-extra 中的 mui-icon-extra mui-icon-extra-cart，同时，应该把其依赖的字体图标文件 mui-icons-extra.ttf，复制到 fonts 目录下！ 将底部的页签，改造成 router-link 来实现单页面的切换； Tab Bar 路由激活时候设置高亮的两种方式： 全局设置样式如下： 123456.router-link-active&#123; color:#007aff !important; &#125; 或者在 new VueRouter 的时候，通过 linkActiveClass 来指定高亮的类： 1234567891011121314// 创建路由对象 var router = new VueRouter(&#123; routes: [ &#123; path: '/', redirect: '/home' &#125; ], linkActiveClass: 'mui-active' &#125;); 实现 tabbar 页签不同组件页面的切换 将 tabbar 改造成 router-link 形式，并指定每个连接的 to 属性； 在入口文件中导入需要展示的组件，并创建路由对象： 12345678910111213141516171819202122232425262728293031323334// 导入需要展示的组件import Home from './components/home/home.vue'import Member from './components/member/member.vue'import Shopcar from './components/shopcar/shopcar.vue'import Search from './components/search/search.vue'// 创建路由对象var router = new VueRouter(&#123; routes: [ &#123; path: '/', redirect: '/home' &#125;, &#123; path: '/home', component: Home &#125;, &#123; path: '/member', component: Member &#125;, &#123; path: '/shopcar', component: Shopcar &#125;, &#123; path: '/search', component: Search &#125; ], linkActiveClass: 'mui-active'&#125;); 使用 mt-swipe 轮播图组件 假数据： 12345678910lunbo: [ 'http://www.itcast.cn/images/slidead/BEIJING/2017440109442800.jpg', 'http://www.itcast.cn/images/slidead/BEIJING/2017511009514700.jpg', 'http://www.itcast.cn/images/slidead/BEIJING/2017421414422600.jpg' ] 引入轮播图组件： 123456789101112131415161718&lt;!-- Mint-UI 轮播图组件 --&gt; &lt;div class="home-swipe"&gt; &lt;mt-swipe :auto="4000"&gt; &lt;mt-swipe-item v-for="(item, i) in lunbo" :key="i"&gt; &lt;img :src="item" alt=""&gt; &lt;/mt-swipe-item&gt; &lt;/mt-swipe&gt; &lt;/div&gt; &lt;/div&gt; 在.vue组件中使用vue-resource获取数据 运行cnpm i vue-resource -S安装模块 导入 vue-resource 组件 12import VueResource from 'vue-resource' 在vue中使用 vue-resource 组件 12Vue.use(VueResource);]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue.js - day9]]></title>
    <url>%2F2019%2F06%2F04%2Fvue.js%20-%20day.9%2F</url>
    <content type="text"><![CDATA[概念：vuex 是 Vue 配套的 公共数据管理工具，它可以把一些共享的数据，保存到 vuex 中，方便 整个程序中的任何组件直接获取或修改我们的公共数据；]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue.js--day8]]></title>
    <url>%2F2019%2F06%2F04%2Fvue.js%20-%20day8%2F</url>
    <content type="text"><![CDATA[day8使用mui的tab-top-webview-main完成分类滑动栏兼容问题 和 App.vue 中的 router-link 身上的类名 mui-tab-item 存在兼容性问题，导致tab栏失效，可以把mui-tab-item改名为mui-tab-item1，并复制相关的类样式，来解决这个问题； 123456789101112131415161718192021222324252627282930.mui-bar-tab .mui-tab-item1.mui-active &#123; color: #007aff;&#125;.mui-bar-tab .mui-tab-item1 &#123; display: table-cell; overflow: hidden; width: 1%; height: 50px; text-align: center; vertical-align: middle; white-space: nowrap; text-overflow: ellipsis; color: #929292;&#125;.mui-bar-tab .mui-tab-item1 .mui-icon &#123; top: 3px; width: 24px; height: 24px; padding-top: 0; padding-bottom: 0;&#125;.mui-bar-tab .mui-tab-item1 .mui-icon~.mui-tab-label &#123; font-size: 11px; display: block; overflow: hidden; text-overflow: ellipsis;&#125; tab-top-webview-main组件第一次显示到页面中的时候，无法被滑动的解决方案： 先导入 mui 的JS文件: 1import mui from '../../../lib/mui/js/mui.min.js' 在 组件的 mounted 事件钩子中，注册 mui 的滚动事件： 123456mounted() &#123; // 需要在组件的 mounted 事件钩子中，注册 mui 的 scroll 滚动事件 mui('.mui-scroll-wrapper').scroll(&#123; deceleration: 0.0005 //flick 减速系数，系数越大，滚动速度越慢，滚动距离越小，默认值0.0006 &#125;); &#125; 滑动的时候报警告：Unable to preventDefault inside passive event listener due to target being treated as passive. See https://www.chromestatus.com/features/5093566007214080 1解决方法，可以加上* &#123; touch-action: none; &#125; 这句样式去掉。 原因：（是chrome为了提高页面的滑动流畅度而新折腾出来的一个东西） http://www.cnblogs.com/pearl07/p/6589114.htmlhttps://developer.mozilla.org/zh-CN/docs/Web/CSS/touch-action 移除严格模式babel-plugin-transform-remove-strict-mode vue-preview一个Vue集成PhotoSwipe图片预览插件]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue.js - day10]]></title>
    <url>%2F2019%2F06%2F04%2Fvue.js%20-%20day10%2F</url>
    <content type="text"><![CDATA[[TOC] Day10开启Apache的gzip压缩要让apache支持gzip功能，要用到deflate_Module和headers_Module。打开apache的配置文件httpd.conf，大约在105行左右，找到以下两行内容：（这两行不是连续在一起的）12#LoadModule deflate_module modules/mod_deflate.so#LoadModule headers_module modules/mod_headers.so 然后将其前面的“#”注释删掉，表示开启gzip压缩功能。开启以后还需要进行相关配置。在httpd.conf文件的最后添加以下内容即可：12345&lt;IfModule deflate_module&gt; #必须的，就像一个开关一样，告诉apache对传输到浏览器的内容进行压缩 SetOutputFilter DEFLATE DeflateCompressionLevel 9&lt;/IfModule&gt; 最少需要加上以上内容，才可以生gzip功能生效。由于没有做其它的额外配置，所以其它相关的配置均使用Apache的默认设置。这里说一下参数“DeflateCompressionLevel”，它表示压缩级别，值从1到9，值越大表示压缩的越厉害。 使用ngrok将本机映射为一个外网的Web服务器注意：由于默认使用的美国的服务器进行中间转接，所以访问速度炒鸡慢，访问时可启用FQ软件，提高网页打开速度！]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue.js - day7]]></title>
    <url>%2F2019%2F06%2F04%2Fvue.js%20-%20day7%2F</url>
    <content type="text"><![CDATA[[TOC] day7使用mui的tab-top-webview-main完成分类滑动栏兼容问题 和 App.vue 中的 router-link 身上的类名 mui-tab-item 存在兼容性问题，导致tab栏失效，可以把mui-tab-item改名为mui-tab-item1，并复制相关的类样式，来解决这个问题； 123456789101112131415161718192021222324252627282930.mui-bar-tab .mui-tab-item1.mui-active &#123; color: #007aff;&#125;.mui-bar-tab .mui-tab-item1 &#123; display: table-cell; overflow: hidden; width: 1%; height: 50px; text-align: center; vertical-align: middle; white-space: nowrap; text-overflow: ellipsis; color: #929292;&#125;.mui-bar-tab .mui-tab-item1 .mui-icon &#123; top: 3px; width: 24px; height: 24px; padding-top: 0; padding-bottom: 0;&#125;.mui-bar-tab .mui-tab-item1 .mui-icon~.mui-tab-label &#123; font-size: 11px; display: block; overflow: hidden; text-overflow: ellipsis;&#125; tab-top-webview-main组件第一次显示到页面中的时候，无法被滑动的解决方案： 先导入 mui 的JS文件: 1import mui from '../../../lib/mui/js/mui.min.js' 在 组件的 mounted 事件钩子中，注册 mui 的滚动事件： 123456mounted() &#123; // 需要在组件的 mounted 事件钩子中，注册 mui 的 scroll 滚动事件 mui('.mui-scroll-wrapper').scroll(&#123; deceleration: 0.0005 //flick 减速系数，系数越大，滚动速度越慢，滚动距离越小，默认值0.0006 &#125;); &#125; 滑动的时候报警告：Unable to preventDefault inside passive event listener due to target being treated as passive. See https://www.chromestatus.com/features/5093566007214080 1解决方法，可以加上* &#123; touch-action: none; &#125; 这句样式去掉。 原因：（是chrome为了提高页面的滑动流畅度而新折腾出来的一个东西） http://www.cnblogs.com/pearl07/p/6589114.htmlhttps://developer.mozilla.org/zh-CN/docs/Web/CSS/touch-action 移除严格模式babel-plugin-transform-remove-strict-mode vue-preview一个Vue集成PhotoSwipe图片预览插件]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js 第6天]]></title>
    <url>%2F2019%2F06%2F04%2FNode.js%20%E7%AC%AC6%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[## 知识点 多人社区案例 复习 MongoDB 数据库 灵活 不用设计数据表 业务的改动不需要关心数据表结构 DBA 架构师 级别的工程师都需要掌握这项技能 设计 维护 分布式计算 mongoose mongodb 官方包也可以操作 MongoDB 数据库 第三方包：WordPress 项目开发团队 设计 Schema 发布 Model（得到模型构造函数） 查询 增加 修改 删除 Promise http://es6.ruanyifeng.com/#docs/promise callback hell 回调地狱 回调函数中套了回调函数 Promise(EcmaScript 6 中新增了一个语法 API) 容器 异步任务（pending） resolve reject then 方法获取容器的结果（成功的，失败的） then 方法支持链式调用 可以在 then 方法中返回一个 promise 对象，然后在后面的 then 方法中获取上一个 then 返回的 promise 对象的状态结果 上午总结下午总结总结 path 模块 dirname 和 filename 动态的 获取当前文件或者文件所处目录的绝对路径 用来解决文件操作路劲的相对路径问题 因为在文件操作中，相对路径相对于执行 node 命令所处的目录 所以为了尽量避免这个问题，都建议文件操作的相对路劲都转为：动态的绝对路径 方式：path.join(__dirname, &#39;文件名&#39;) art-template 模板引擎(include、block、extend) include extend block 表单同步提交和异步提交区别 以前没有 ajax 都是这么干的，甚至有些直接就是渲染了提示信息出来了 异步提交页面不会刷新，交互方式更灵活 Express 中配置使用 express-session 插件 概述案例中注册-登陆-退出的前后端交互实现流程 path 模块 dirname 和 filename 动态的 获取当前文件或者文件所处目录的绝对路径 用来解决文件操作路劲的相对路径问题 因为在文件操作中，相对路径相对于执行 node 命令所处的目录 所以为了尽量避免这个问题，都建议文件操作的相对路劲都转为：动态的绝对路径 方式：path.join(__dirname, &#39;文件名&#39;) art-template 模板引擎(include、block、extend) include extend block 动手写一写 表单同步提交和异步提交区别 字符串交互 请求（报文、具有一定格式的字符串） HTTP 就是 Web 中的沟通语言 服务器响应（字符串） 01 服务器端重定向针对异步请求无效 Express 中配置使用 express-session 插件 插件也是工具 你只需要明确你的目标就可以了 我们最终的目标就是使用 Session 来帮我们管理一些敏感信息数据状态，例如保存登陆状态 写 Session req.session.xxx = xx 读 Session req.session.xxx 删除 Session req.session.xxx = null 更严谨的做法是 delete 语法 delete req.session.xxx 概述案例中注册-登陆-退出的前后端交互实现流程]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>node学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js 第5天 --- MongoDB]]></title>
    <url>%2F2019%2F06%2F04%2FNode.js%20%E7%AC%AC5%E5%A4%A9%20---%20MongoDB%2F</url>
    <content type="text"><![CDATA[## 知识点 Express MongoDB 项目 一天半的时间 复习 文件路径中的 / 和模块标识中的 / Express 中配置使用 art-template 模板引擎 Express 中配置使用 body-parser Express 中配置处理静态资源 CRUD 案例中单独提取路由模块 上午总结 回调函数 异步编程 如果需要得到一个函数内部异步操作的结果，这是时候必须通过回调函数来获取 在调用的位置传递一个函数进来 在封装的函数内部调用传递进来的函数 find、findIndex、forEach 数组的遍历方法，都是对函数作为参数一种运用 every some includes map reduce package-lock.json 文件的作用 下载速度快了 锁定版本 JavaScript 模块化 Node 中的 CommonJS 浏览器中的 AMD require.js CMD sea.js EcmaScript 官方在 EcmaScript 6 中增加了官方支持 EcmaScript 6 后面我们会学，编译工具 MongoDB 数据库 MongoDB 的数据存储结构 数据库 集合（表） 文档（表记录） MongoDB 官方有一个 mongodb 的包可以用来操作 MongoDB 数据库 这个确实和强大，但是比较原始，麻烦，所以咱们不使用它 mongoose 真正在公司进行开发，使用的是 mongoose 这个第三方包 它是基于 MongoDB 官方的 mongodb 包进一步做了封装 可以提高开发效率 让你操作 MongoDB 数据库更方便 掌握使用 mongoose 对数据集合进行基本的 CRUD 把之前的 crud 案例改为了 MongoDB 数据库版本 使用 Node 操作 mysql 数据库 下午总结目标]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>node学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js 第4天 --- express]]></title>
    <url>%2F2019%2F06%2F04%2FNode.js%20%E7%AC%AC4%E5%A4%A9%20---%20express%2F</url>
    <content type="text"><![CDATA[## 知识点 Express 基于文件做一套 CRUD 复习 jQuery 的 each 和 原生的 JavaScript 方法 forEach 301 和 302 的区别 模块中导出单个成员和导出多个成员的方式 module.exports = xxx 通过多次：exports.xxx = xxx 导出多个也可以：moudle.exports = {多个成员} module.exports 和 exports 的区别 exports 只是 module.exports 的一个引用而已，目的只是为了简化写法 每个模块最终 return 的是 module.exports require 方法加载规则 优先从缓存加载 核心模块 路径形式的模块 ./xxx ../xxxx /xxxx / 在这里表示的是磁盘根路径 c:/xxx 第三方模块 第三方模块的标识就是第三方模块的名称（不可能有第三方模块和核心模块的名字一致） npm 开发人员可以把写好的框架、库发布到 npm 上 使用者在使用的时候就可以很方便的通过 npm 来下载 使用方式：var 名字 = require(&#39;npm install 的那个包名&#39;) node_modules node_modules/express node_modules/express/package.json node_modules/express/package.json main 如果 package.json 或者 package.json main 不成立，则查找备选项：index.js 如果以上条件都不成立，则继续进入上一级目录中的 node_modules 按照上面的规则继续查找 如果直到当前文件模块所属磁盘根目录都找不到，最后报错：can not find module xxx package.json 包描述文件 就是产品的说明书 dependencies 属性，用来保存项目的第三方包依赖项信息 所以建议每个项目都要有且只有一个 package.json (存放在项目的根目录) 我们可以通过 npm init [--yes] 来生成 package.json 文件 同样的，为了保存依赖项信息，我们每次安装第三方包的时候都要加上：--save 选项。 npm 常用命令 install uninstall Express 基本使用 模块标识中的 / 和文件操作路径中的 /上午总结 文件路径中的 / 和模块标识中的 / nodemon Express art-template 模板引擎的配置 body-parser 解析表单 POST 请求体 详解了 express 静态服务 API app.use(‘/public/‘, express.static(‘./public’)) crud 下午总结目标 文件路径中的 / 和模块标识中的 / Express 中配置使用 art-template 模板引擎 Express 中配置使用 body-parser Express 中配置处理静态资源 CRUD 案例中单独提取路由模块]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>node学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js 第3天 --- exports 和 module.exports ,each和forEach的区别]]></title>
    <url>%2F2019%2F06%2F04%2FNode.js%20%E7%AC%AC3%E5%A4%A9%20---%20exports%20%E5%92%8C%20module.exports%20%2Ceach%E5%92%8CforEach%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[知识点 增删改查 登陆 注册 头像 服务端图片 水印 图片水印 找回密码 密码修改 模块系统 核心模块 第三方模块 自己写的模块 加载规则以及加载机制 循环加载 npm package.json Express 第三方 Web 开发框架 高度封装了 http 模块 更加专注于业务，而非底层细节 知其所以然 增删改查 使用文件来保存数据（锻炼异步编码） MongoDB （所有方法都封装好了） 复习 网站开发模型 黑盒子、哑巴 写代码让它变得更智能 按照你设计好的套路供用户使用 在 Node 中使用 art-template 模板引擎 安装 加载 template.render() 客户端渲染和服务端渲染的区别 最少两次请求，发起 ajax 在客户端使用模板引擎渲染 客户端拿到的就是服务端已经渲染好的 处理留言本案例首页数据列表渲染展示 处理留言本案例发表留言功能 路径 设计好的请求路径 $GET 直接或查询字符串数据 Node 中需要咱们自己动手来解析 url.parse() /pinglun?name=jack&amp;message=hello split(‘?’) name=jack&amp;message=hello split(‘&amp;’) name=jack message=hello forEach() name=jack.split(‘=’) 0 key 1 value 掌握如何解析请求路径中的查询字符串 url.parse() 如何在 Node 中实现服务器重定向 header(‘location’) 301 永久重定向 浏览器会记住 a.com b.com a 浏览器不会请求 a 了 直接去跳到 b 了 302 临时重定向 浏览器不记忆 a.com b.com a.com 还会请求 a a 告诉浏览器你往 b Node 中的 Console（REPL）使用 上午总结 jQuery 的 each 和 原生的 JavaScript 方法 forEach EcmaScript 5 提供的 不兼容 IE 8 jQuery 的 each 由 jQuery 这个第三方库提供 jQuery 2 以下的版本是兼容 IE 8 的 它的 each 方法主要用来遍历 jQuery 实例对象（伪数组） 同时它也可以作为低版本浏览器中 forEach 替代品 jQuery 的实例对象不能使用 forEach 方法，如果想要使用必须转为数组才可以使用 [].slice.call(jQuery实例对象) 模块中导出多个成员和导出单个成员 301 和 302 状态码区别 301 永久重定向，浏览器会记住 302 临时重定向 exports 和 module.exports 的区别 每个模块中都有一个 module 对象 module 对象中有一个 exports 对象 我们可以把需要导出的成员都挂载到 module.exports 接口对象中 也就是：moudle.exports.xxx = xxx 的方式 但是每次都 moudle.exports.xxx = xxx 很麻烦，点儿的太多了 所以 Node 为了你方便，同时在每一个模块中都提供了一个成员叫：exports exports === module.exports 结果为 trues 所以对于：moudle.exports.xxx = xxx 的方式 完全可以：expots.xxx = xxx 当一个模块需要导出单个成员的时候，这个时候必须使用：module.exports = xxx 的方式 不要使用 exports = xxx 不管用 因为每个模块最终向外 return 的是 module.exports 而 exports 只是 module.exports 的一个引用 所以即便你为 exports = xx 重新赋值，也不会影响 module.exports 但是有一种赋值方式比较特殊：exports = module.exports 这个用来重新建立引用关系的 之所以让大家明白这个道理，是希望可以更灵活的去用它 Node 是一个比肩 Java、PHP 的一个平台 JavaScript 既能写前端也能写服务端 12345678moudle.exports = &#123; a: 123&#125;// 重新建立 exports 和 module.exports 之间的引用关系exports = module.exportsexports.foo = 'bar' 12345678910111213141516171819202122232425262728Array.prototype.mySlice = function () &#123; var start = 0 var end = this.length if (arguments.length === 1) &#123; start = arguments[0] &#125; else if (arguments.length === 2) &#123; start = arguments[0] end = arguments[1] &#125; var tmp = [] for (var i = start; i &lt; end; i++) &#123; // fakeArr[0] // fakeArr[1] // fakeArr[2] tmp.push(this[i]) &#125; return tmp&#125;var fakeArr = &#123; 0: 'abc', 1: 'efg', 2: 'haha', length: 3&#125;// 所以你就得到了真正的数组。 [].mySlice.call(fakeArr) 下午总结 jQuery 的 each 和 原生的 JavaScript 方法 forEach 301 和 302 的区别 模块中导出单个成员和导出多个成员的方式 module.exports 和 exports 的区别 require 方法加载规则 优先从缓存加载 核心模块 路径形式的模块 第三方模块 node_modules package.json 包描述文件 dependencies 选项的作用:依赖 npm 常用命令 Express 基本使用]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>node学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js 第2天 ---代码风格，服务端渲染]]></title>
    <url>%2F2019%2F06%2F04%2FNode.js%20%E7%AC%AC2%E5%A4%A9%20---%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%EF%BC%8C%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93%2F</url>
    <content type="text"><![CDATA[### 代码风格 12345678910111213141516var foo = 'bar'var foo ='bar'var foo= 'bar'var foo = "bar"if (true) &#123; console.log('hello') &#125;if (true) &#123; console.log('hello') &#125;if (true )&#123; console.log('hello') &#125; 为了约定大家的代码风格，所以在社区中诞生了一些比较规范的代码风格规范：dnsajkndkjsabnjkdnjksandjknsajkdnjkasnjkdnjksandjknsajkdnjksajkdnas 推荐的两种代码风格 JavaScript Standard Style Airbnb JavaScript Style 总结 代码风格 无分号 ( [ ` 最好前面补分号，避免一些问题 《编写可维护的 JavaScript》 不仅是功能，还要写的漂亮 服务端渲染 说白了就是在服务端使用模板引擎 模板引擎最早诞生于服务端，后来才发展到了前端 服务端渲染和客户端渲染的区别 客户端渲染不利于 SEO 搜索引擎优化 服务端渲染是可以被爬虫抓取到的，客户端异步渲染是很难被爬虫抓取到的 所以你会发现真正的网站既不是纯异步也不是纯服务端渲染出来的 而是两者结合来做的 例如京东的商品列表就采用的是服务端渲染，目的是为了 SEO 搜索引擎优化 而它的商品评论列表为了用户体验，而且也不需要 SEO 优化，所以采用是客户端渲染]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>node学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js 第1天 --- 模块系统，HTTP]]></title>
    <url>%2F2019%2F06%2F04%2FNode.js%20%E7%AC%AC1%E5%A4%A9%20---%20%E6%A8%A1%E5%9D%97%E7%B3%BB%E7%BB%9F%EF%BC%8CHTTP%2F</url>
    <content type="text"><![CDATA[### 上午总结 基本网站开发能力 服务端 前端 运维部署 Node.js 是什么 JavaScript 运行时环境 既不是语言，也不是框架，它是一个平台 简单来讲就是Node.js可以解析和执行JavaScript代码 以前只有浏览器可以解析和执行JavaScript代码 也就是说现在的JavaScript完全可以脱离浏览器来运行，一切都归功于：Node.js Node.js 中的 JavaScript 没有 BOM、DOM EcmaScript 只有基本的 JavaScript 语言部分 在 Node 中为 JavaScript 提供了一些服务器级别的 API 文件操作的能力 网络服务的构建 网络通信 http服务器 等处理….. 构建于Chrome的V8引擎之上 代码只是具有特定格式的字符串而已 引擎可以认识它，引擎可以帮你去解析和执行 Google Chrome的V8引擎是目前公认的解析执行JavaScript代码最快的 Node.js的作者把Google Chrome中的V8引擎移植了出来，开发了一个独立的JavaScript运行时环境 Node.js能做什么 web服务后台啊 命令行工具 npm(node) git(c语言) hexo(node) 。。。 下午总结 Node 中的 JavaScript EcmaScript 变量 方法 数据类型 内置对象 Array Object Date Math 模块系统 在 Node 中没有全局作用域的概念 在 Node 中，只能通过 require 方法来加载执行多个 JavaScript 脚本文件 require 加载只能是执行其中的代码，文件与文件之间由于是模块作用域，所以不会有污染的问题 模块完全是封闭的 外部无法访问内部 内部也无法访问外部 模块作用域固然带来了一些好处，可以加载执行多个文件，可以完全避免变量命名冲突污染的问题 但是某些情况下，模块与模块是需要进行通信的 在每个模块中，都提供了一个对象：exports 该对象默认是一个空对象 你要做的就是把需要被外部访问使用的成员手动的挂载到 exports 接口对象中 然后谁来 require 这个模块，谁就可以得到模块内部的 exports 接口对象 还有其它的一些规则，具体后面讲，以及如何在项目中去使用这种编程方式，会通过后面的案例来处理 核心模块 核心模块是由 Node 提供的一个个的具名的模块，它们都有自己特殊的名称标识，例如 fs 文件操作模块 http 网络服务构建模块 os 操作系统信息模块 path 路径处理模块 。。。。 所有核心模块在使用的时候都必须手动的先使用 require 方法来加载，然后才可以使用，例如： var fs = require(&#39;fs&#39;) http require 端口号 ip 地址定位计算机 端口号定位具体的应用程序 Content-Type 服务器最好把每次响应的数据是什么内容类型都告诉客户端，而且要正确的告诉 不同的资源对应的 Content-Type 是不一样，具体参照：http://tool.oschina.net/commons 对于文本类型的数据，最好都加上编码，目的是为了防止中文解析乱码问题 通过网络发送文件 发送的并不是文件，本质上来讲发送是文件的内容 当浏览器收到服务器响应内容之后，就会根据你的 Content-Type 进行对应的解析处理]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>node学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[H5新增表单属性]]></title>
    <url>%2F2019%2F06%2F04%2FH5%E6%96%B0%E5%A2%9E%E8%A1%A8%E5%8D%95%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[### H5新增的input类型 1234567891011121314&lt;form&gt; 邮箱：&lt;input type="email"&gt;&lt;br/&gt; 数量：&lt;input type="number" value="20" max="25" min="18"&gt;&lt;br/&gt; 电话：&lt;input type="tel"&gt;&lt;br/&gt; 网址：&lt;input type="url"&gt;&lt;br/&gt; 范围：&lt;input type="range" max="100" min="0"&gt;&lt;br/&gt; 颜色：&lt;input type="color"&gt;&lt;br/&gt; 时间:&lt;input type="time"&gt;&lt;br/&gt; 日期：&lt;input type="date"&gt;&lt;br/&gt; 日期时间：&lt;input type="datetime-local"&gt;&lt;br/&gt; 月份：&lt;input type="month"&gt;&lt;br/&gt; 星期：&lt;input type="week"&gt;&lt;br/&gt; 提交：&lt;input type="submit"&gt; &lt;/form&gt; 在H5新增input类型帮我们省去了许多原来需要自己实现的功能。 email帮我们自动校验了格式。 tel由于全球号码格式不一样，格式不太好校验不过帮我们在移动端点击该输入框会切换到数字键盘。 url帮我们校验了格式不过需要注意的是网址前面需要加上：http://。 number 类型用于应该包含数值的输入域。还能设置输入数字的范围 range 类型用于应该包含一定范围内数字值的输入域。range 类型显示为滑动条。还能够设定数字的限定： 效果图： 浏览器支持需要注意的是新增的类型不是所有浏览器都兼容，部分兼容的呈现出来的效果也不一样。 表单其他新增属性placeholder:占位符，提示文本 autofocus:自动获取焦点 autocomplete:自动完成，on打开,off关闭 1.必须成功提交过 2.必须有name属性 required:必须输入，如果没有输入会阻止提交 pattern:正则表达式的验证 multiple:允许选择多个文件,在邮箱中允许输入多个邮箱地址，用,分割 1234567891011121314&lt;form action=""&gt; &lt;!--placeholder占位符，提示文本 --&gt; &lt;!-- autofocus自动获取焦点--&gt; &lt;!--autocomplete自动完成，on打开,off关闭 1.必须成功提交过 2.必须有name属性--&gt; 用户名：&lt;input type="text" name="userName" placeholder="请输入用户名" autofocus autocomplete="on"&gt;&lt;br/&gt; &lt;!-- tel并不会进行验证，只是会在移动端打开数字键盘--&gt; &lt;!-- required必须输入，如果没有输入会阻止提交--&gt; &lt;!-- pattern正则表达式的验证--&gt; 手机号:&lt;input type="tel" required pattern="^(\+86)?1\d&#123;10&#125;$"&gt;&lt;br/&gt; &lt;!-- multiple允许选择多个文件,在邮箱中允许输入多个邮箱地址，用,分割--&gt; 文件：&lt;input type="file" name="photo" multiple&gt;&lt;br/&gt; 邮箱：&lt;input type="email" multiple name="email"&gt; &lt;input type="submit"&gt; &lt;/form&gt; 效果图：]]></content>
      <categories>
        <category>H5/C3</category>
      </categories>
      <tags>
        <tag>h5表单属性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[H5多媒体标签--视频video和音频audio]]></title>
    <url>%2F2019%2F06%2F04%2FH5%E5%A4%9A%E5%AA%92%E4%BD%93%E6%A0%87%E7%AD%BE--%E8%A7%86%E9%A2%91video%E5%92%8C%E9%9F%B3%E9%A2%91audio%2F</url>
    <content type="text"><![CDATA[### audio–音频标签 标签属性 contrils:播放器的控制面板 autoplay:自动播放 loop:循环播放 src：文件地址 preload用来缓存大的文件其中有三个值可选 none：不缓存 auto：缓存(默认) metadata:缓存文件元信息 案例：1&lt;audio src="年少有为.mp3" controls autoplay loop&gt;浏览器不支持该标签时，才显示这部分文字&lt;/audio&gt; 效果图： video视频标签标签属性src:表示文件地址 contrils:播放器的控制面板 autoplay:自动播放 loop:循环播放 width:宽度 height:高度 preload用来缓存大的文件其中有三个值可选 none：不缓存 auto：缓存(默认) metadata:缓存文件元信息 poster:当前视频还没有完全下载，或者用户还没有点击播放前的默认显示封面。默认显示当前视频文件第一帧画面 注意事项：当设置宽高的时候，一般情况下只会设置宽度或高度，让其等比例缩放。如果同时设置宽度和高度，那么视频并不会真正调整到设置的宽高。 案例：1&lt;video src="李荣浩%20-%20年少有为.mp4" poster="1.jpg" controls width="800"&gt;&lt;/video&gt; 效果图： 重点说明source的使用因为不同浏览器支持的视频格式不一样，所以我们在进行视频添加的时候，需要考虑到浏览器是否支持。我们可以准备多个格式的视频文件，让浏览器自动选择 12345&lt;video&gt; &lt;source src="李荣浩%20-%20年少有为.mp4" type="video/mp4"&gt; &lt;source src="李荣浩%20-%20年少有为.flv" type="video/flv"&gt; 您的浏览器不支持当前的视频播放&lt;/video&gt; 浏览器视频格式兼容性参考图如下:]]></content>
      <categories>
        <category>H5/C3</category>
      </categories>
      <tags>
        <tag>video,autio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[H5全屏显示方法及浏览器兼容解决方案]]></title>
    <url>%2F2019%2F06%2F04%2FH5%E5%85%A8%E5%B1%8F%E6%98%BE%E7%A4%BA%E6%96%B9%E6%B3%95%E5%8F%8A%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[### 全屏操作的主要方法和属性 1.requestFullScreen():开启全屏显示 克服兼容性：不同浏览器需要添加不同的前缀: chrom:webkit firefox:moz ie:ms opera: o123456789101112131415/*添加三个按钮的点击事件*//*全屏操作*/document.querySelector("#full").onclick= function () &#123; /*使用能力测试添加不同浏览器下的前缀*/ if(div.requestFullScreen)&#123; div.requestFullScreen(); &#125;else if(div.webkitRequestFullScreen)&#123; div.webkitRequestFullScreen(); &#125; else if(div.mozRequestFullScreen)&#123; div.mozRequestFullScreen(); &#125;else if(div.msRequestFullScreen)&#123; div.msRequestFullScreen(); &#125;&#125; 2.cancelFullScreen():退出全屏显示 也添加前缀，在不同的浏览器下，退出全屏只能使用document来实现（整个文档退出） 1234567891011121314 /*退出全屏*/document.querySelector("#cancelFull").onclick= function () &#123; /*使用能力测试添加不同浏览器下的前缀*/ if(document.cancelFullScreen)&#123; document.cancelFullScreen(); &#125;else if(document.webkitCancelFullScreen)&#123; document.webkitCancelFullScreen(); &#125; else if(document.mozCancelFullScreen)&#123; document.mozCancelFullScreen(); &#125;else if(document.msCancelFullScreen)&#123; document.msCancelFullScreen(); &#125;&#125; 3.fullScreenElement:是否是全屏状态 添加前缀，要使用document进行判断 12345678document.querySelector("#isfull").onclick= function () &#123; /*两个细节:使用document判断 能力测试*/ if(document.fullscreenElement || document.webkitFullScreenElement || document.mozFullScreenElement || document.msFullScreenElement)&#123; alert(true); &#125;else&#123; alert(false); &#125;&#125; 效果图：]]></content>
      <categories>
        <category>H5/C3</category>
      </categories>
      <tags>
        <tag>H5全屏显示</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3---文本阴影]]></title>
    <url>%2F2019%2F06%2F04%2FCSS3---%E6%96%87%E6%9C%AC%E9%98%B4%E5%BD%B1%2F</url>
    <content type="text"><![CDATA[### CSS3 text-shadow 属性 实例基础的文本阴影效果： 123h1&#123; text-shadow: 5px 5px 5px #FF0000;&#125; 效果图： 语法text-shadow: h-shadow v-shadow blur color; 注释：text-shadow 属性向文本添加一个或多个阴影。该属性是逗号分隔的阴影列表，每个阴影有两个或三个长度值和一个可选的颜色值进行规定。省略的长度是 0。 值 描述 h-shadow 必需。水平阴影的位置。允许负值。 v-shadow 必需。垂直阴影的位置。允许负值。 blur 可选。模糊的距离。 color 可选。阴影的颜色。 小案例：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .demo&#123; font-size: 80px; background-color: #808080; width: 800px; margin: 30px auto; text-align: center; color: white; font-weight: bolder; &#125; .demo1&#123; text-shadow: -2px -2px 8px red; &#125; .demo2&#123; text-shadow: 0px 0px 30px #fff; &#125; .demo3&#123; text-shadow: 0px 0px 30px #fff,0px 0px 50px red; &#125; .demo4&#123; color: black; text-shadow: 0px 1px 0px #fff; &#125; .demo5&#123; color: white; text-shadow: -1px -1px 0px #eee,-2px -2px 0px #ddd ,-3px -3px 0px #ccc ,-4px -4px 0px #bbb; &#125; .demo6&#123; color: transparent; text-shadow: 0px 0px 8px hsla(30,100%,30%,1); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="demo demo1"&gt;好好学习，天天向上&lt;/div&gt;&lt;div class="demo demo2"&gt;好好学习，天天向上&lt;/div&gt;&lt;div class="demo demo3"&gt;好好学习，天天向上&lt;/div&gt;&lt;div class="demo demo4"&gt;好好学习，天天向上&lt;/div&gt;&lt;div class="demo demo5"&gt;好好学习，天天向上&lt;/div&gt;&lt;div class="demo demo6"&gt;好好学习，天天向上&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果图：]]></content>
      <categories>
        <category>H5/C3</category>
      </categories>
      <tags>
        <tag>text-shadow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3过渡效果transition----附手风琴案例]]></title>
    <url>%2F2019%2F06%2F04%2FCSS3%E8%BF%87%E6%B8%A1%E6%95%88%E6%9E%9Ctransition----%E9%99%84%E6%89%8B%E9%A3%8E%E7%90%B4%E6%A1%88%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[CSS3中新增的transform属性，实现了元素在变化过程中的过渡效果，实现了基本的动画。 定义和用法transition 属性是一个简写属性，用于设置四个过渡属性： transition-property 规定设置过渡效果的 CSS 属性的名称。 transition-duration 规定完成过渡效果需要多少秒或毫秒。 transition-timing-function 规定速度效果的速度曲线。 ①linear：线性过渡。②ease：平滑过渡，这是默认值③ease-in：由慢到快。④ease-out：由快到慢。⑤ease-in-out：由慢到快再到慢。 transition-delay 定义过渡效果何时开始。 浏览器兼容性问题基于webkit内核的私有属性是：-webkit-transition; 基于gecko内核的私有属性是：-moz-transition; 基于prestot内核的私有属性是：-o-transition; 实例：12345678div&#123;width:100px;transition: width 2s;-moz-transition: width 2s; /* Firefox 4 */-webkit-transition: width 2s; /* Safari 和 Chrome */-o-transition: width 2s; /* Opera */&#125; 手风琴案例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; *&#123; text-align: center; margin: 0px; padding: 0px; &#125; li&#123; list-style:none;; height: 30px; &#125; .mennu&#123; height: auto; width: 250px; margin: 50px auto; &#125; .item&#123; width: 100%; height: auto; &#125; .item:hover &gt; .itemBox&#123; height: 120px; &#125; .item &gt; h3&#123; background-color: skyblue; color: orange; height: 40px; line-height: 40px; border-bottom: 2px solid #ccc; &#125; .item &gt;.itemBox&#123; width: 100%; height: 0; overflow: hidden; /*添加过渡效果*/ transition-property: height; transition-duration: 1s; &#125; .item &gt;.itemBox &gt;ul&#123; background-color: yellowgreen; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="mennu"&gt; &lt;div class="item"&gt; &lt;h3&gt;国际新闻&lt;/h3&gt; &lt;div class="itemBox"&gt; &lt;ul&gt; &lt;li&gt;深圳市遇到有史以来最大台风&lt;/li&gt; &lt;li&gt;深圳市遇到有史以来最大台风&lt;/li&gt; &lt;li&gt;深圳市遇到有史以来最大台风&lt;/li&gt; &lt;li&gt;深圳市遇到有史以来最大台风&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;h3&gt;国内新闻&lt;/h3&gt; &lt;div class="itemBox"&gt; &lt;ul&gt; &lt;li&gt;深圳市遇到有史以来最大台风&lt;/li&gt; &lt;li&gt;深圳市遇到有史以来最大台风&lt;/li&gt; &lt;li&gt;深圳市遇到有史以来最大台风&lt;/li&gt; &lt;li&gt;深圳市遇到有史以来最大台风&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;h3&gt;省内新闻&lt;/h3&gt; &lt;div class="itemBox"&gt; &lt;ul&gt; &lt;li&gt;深圳市遇到有史以来最大台风&lt;/li&gt; &lt;li&gt;深圳市遇到有史以来最大台风&lt;/li&gt; &lt;li&gt;深圳市遇到有史以来最大台风&lt;/li&gt; &lt;li&gt;深圳市遇到有史以来最大台风&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;h3&gt;市内新闻&lt;/h3&gt; &lt;div class="itemBox"&gt; &lt;ul&gt; &lt;li&gt;深圳市遇到有史以来最大台风&lt;/li&gt; &lt;li&gt;深圳市遇到有史以来最大台风&lt;/li&gt; &lt;li&gt;深圳市遇到有史以来最大台风&lt;/li&gt; &lt;li&gt;深圳市遇到有史以来最大台风&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果图]]></content>
      <categories>
        <category>H5/C3</category>
      </categories>
      <tags>
        <tag>transition</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3伸缩布局注意点——携程网案例]]></title>
    <url>%2F2019%2F06%2F04%2FCSS3%E4%BC%B8%E7%BC%A9%E5%B8%83%E5%B1%80%E6%B3%A8%E6%84%8F%E7%82%B9%E2%80%94%E2%80%94%E6%90%BA%E7%A8%8B%E7%BD%91%E6%A1%88%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[#### 先贴两张效果图： 要求网页伸缩放大布局会自适应变换 用到的新属性display: flex Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。 flex: 当父元素使用display: flex后，子元素会具有弹性布局，子元素设置flex属性后面接数字，例如：flex:1，表示该子元素在该父元素的所有子元素中大小占一份，就会自适应宽度 box-sizing：border-box 为元素设定的宽度和高度决定了元素的边框盒。就是说，为元素指定的任何内边距和边框都将在已设定的宽度和高度内进行绘制。通过从已设定的宽度和高度分别减去边框和内边距才能得到内容的宽度和高度。 flex-wrap：wrap 让弹性盒元素在必要的时候拆行。使其不再收缩。 携程网案例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; *&#123; padding: 0; margin: 0; &#125; header&#123; width: 100%; display: flex; &#125; header &gt;a&#123; flex: 1; &#125; header &gt;a &gt;img&#123; width: 100%; &#125; main&#123; width: 100%; padding: 0 10px; /*设置盒模型*/ box-sizing: border-box; &#125; main &gt; .item&#123; width: 100%; height: 100px; background-color: #57c3ae; border-radius: 10px; margin-top: 10px; display: flex; &#125; main &gt; .item &gt;.left&#123; flex: 1; &#125; main &gt; .item &gt;.right&#123; flex: 2; /*设置换行显示*/ flex-wrap: wrap; /*设置为伸缩盒子*/ display: flex; &#125; main &gt; .item &gt;.right &gt;a&#123; /*如果想让子元素换行显示，必须为子元素设置宽度*/ box-sizing: border-box; width: 50%; display: block; text-align: center; line-height: 50px; color: #FFFFFF; text-decoration: none; border-left: 1px solid #fff; border-bottom: 1px solid #fff; &#125; main &gt;.item &gt;.right &gt;a:nth-last-child(-n+2)&#123; /*去除下面两个标签的下边框*/ border-bottom: none; &#125; main &gt;.item:nth-of-type(2)&#123; background-color:skyblue; &#125; main &gt;.item:nth-of-type(3)&#123; background-color:pink; &#125; main &gt;.item:nth-of-type(4)&#123; background-color:palegreen; &#125; main &gt;.extra&#123; width: 100%; display: flex; &#125; main &gt;.extra &gt;a&#123; flex: 1; &#125; main &gt;.extra&gt;a&gt;img&#123; width: 100%; &#125; /*底部块样式*/ footer&#123; width: 100%; font-size: 13px; &#125; footer &gt;nav&#123; width: 100%; display: flex; border-top: 1px solid #cccccc; border-bottom: 1px solid #cccccc; &#125; footer &gt;nav &gt;a&#123; flex: 1; line-height: 30px; text-align: center; color: #888; text-decoration: none; &#125; footer &gt;.link&#123; text-align: center; line-height: 25px; margin-top: 10px; &#125; footer .copy&#123; text-align: center; margin-top: 10px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="container"&gt; &lt;header&gt; &lt;a href=""&gt; &lt;img src="banner.jpg" alt=""/&gt; &lt;/a&gt; &lt;/header&gt; &lt;main&gt; &lt;section class="item"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt; &lt;a href=""&gt;海外酒店&lt;/a&gt; &lt;a href=""&gt;团购&lt;/a&gt; &lt;a href=""&gt;特惠酒店&lt;/a&gt; &lt;a href=""&gt;客栈公寓&lt;/a&gt; &lt;/div&gt; &lt;/section&gt; &lt;section class="item"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt; &lt;a href=""&gt;海外酒店&lt;/a&gt; &lt;a href=""&gt;团购&lt;/a&gt; &lt;a href=""&gt;特惠酒店&lt;/a&gt; &lt;a href=""&gt;客栈公寓&lt;/a&gt; &lt;/div&gt; &lt;/section&gt; &lt;section class="item"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt; &lt;a href=""&gt;海外酒店&lt;/a&gt; &lt;a href=""&gt;团购&lt;/a&gt; &lt;a href=""&gt;特惠酒店&lt;/a&gt; &lt;a href=""&gt;客栈公寓&lt;/a&gt; &lt;/div&gt; &lt;/section&gt; &lt;section class="item"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt; &lt;a href=""&gt;海外酒店&lt;/a&gt; &lt;a href=""&gt;团购&lt;/a&gt; &lt;a href=""&gt;特惠酒店&lt;/a&gt; &lt;a href=""&gt;客栈公寓&lt;/a&gt; &lt;/div&gt; &lt;/section&gt; &lt;section class="item"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt; &lt;a href=""&gt;海外酒店&lt;/a&gt; &lt;a href=""&gt;团购&lt;/a&gt; &lt;a href=""&gt;特惠酒店&lt;/a&gt; &lt;a href=""&gt;客栈公寓&lt;/a&gt; &lt;/div&gt; &lt;/section&gt; &lt;section class="extra"&gt; &lt;a href=""&gt; &lt;img src="extra1.png" alt=""/&gt; &lt;/a&gt; &lt;a href=""&gt; &lt;img src="exra2.png" alt=""/&gt; &lt;/a&gt; &lt;/section&gt; &lt;/main&gt; &lt;footer&gt; &lt;nav&gt; &lt;a href=""&gt;电话预定&lt;/a&gt; &lt;a href=""&gt;下载客户端&lt;/a&gt; &lt;a href=""&gt;我的订单&lt;/a&gt; &lt;/nav&gt; &lt;p class="link"&gt; &lt;a href=""&gt;网站地图&lt;/a&gt; &lt;a href=""&gt;ENGLISH&lt;/a&gt; &lt;a href=""&gt;电脑版&lt;/a&gt; &lt;/p&gt; &lt;p class="copy"&gt;&amp;copy;2015携程旅行&lt;/p&gt; &lt;/footer&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>H5/C3</category>
      </categories>
      <tags>
        <tag>flex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flex弹性布局：justify-content]]></title>
    <url>%2F2019%2F06%2F04%2Fflex%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80%EF%BC%9Ajustify-content%2F</url>
    <content type="text"><![CDATA[## 定义和用法 justify-content 用于设置或检索弹性盒子元素在主轴（横轴）方向上的对齐方式。提示：使用 align-content 属性对齐交叉轴上的各项（垂直）。|默认值：| flex-start||–|–|| 继承：| 否||可动画化：|否||版本|css3||JavaScript 语法：|object.style.justifyContent=”space-between” | CSS 语法1justify-content: flex-start|flex-end|center|space-between|space-around|initial|inherit; 属性值 值 描述 测试 flex-start 默认值。项目位于容器的开头。 测试 flex-end 项目位于容器的结尾。 测试 center 项目位于容器的中心。 测试 space-between 项目位于各行之间留有空白的容器内。 测试 space-around 项目位于各行之前、之间、之后都留有空白的容器内。 测试 initial 设置该属性为它的默认值。 测试 inherit 从父元素继承该属性。]]></content>
      <categories>
        <category>H5/C3</category>
      </categories>
      <tags>
        <tag>justify-content</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MVC和MVVM的区别]]></title>
    <url>%2F2019%2F06%2F04%2FMVC%E5%92%8CMVVM%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[@[toc] 前言mvc和mvvm究竟是怎么样子的，这是一个前后端都需要思考的问题。后面我们一步步来阐述mvc和mvvm这样设计的原因以及我们需要明白的一些问题。 MVC解释MVC全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。MVC被独特的发展起来用于映射传统的输入、处理和输出功能在一个逻辑的图形化用户界面的结构中。 几乎所有的App都只干这么一件事：将数据展示给用户看，并处理用户对界面的操作。MVC的思想：一句话描述就是Controller负责将Model的数据用View显示出来，换句话说就是在Controller里面把Model的数据赋值给View。 MModel（模型）：是应用程序中用于处理应用程序数据逻辑的部分。通常模型对象负责在数据库中存取数据。 比如我们人类有一双手，一双眼睛，一个脑袋，没有尾巴，这就是模型，Model定义了这个模块的数据模型。在代码中体现为数据管理者，Model负责对数据进行获取及存放。数据不可能凭空生成的，要么是从服务器上面获取到的数据，要么是本地数据库中的数据，也有可能是用户在UI上填写的表单即将上传到服务器上面存放，所以需要有数据来源。既然Model是数据管理者，则自然由它来负责获取数据。Controller不需要关心Model是如何拿到数据的，只管调用就行了。数据存放的地方是在Model，而使用数据的地方是在Controller，所以Model应该提供接口供controller访问其存放的数据（通常通过.h里面的只读属性） VView（视图）：是应用程序中处理数据显示的部分。通常视图是依据模型数据创建的。 View，视图，简单来说，就是我们在界面上看见的一切。它们有一部分是我们UI定死的，也就是不会根据数据来更新显示的，比如一些Logo图片啊，这里有个按钮啊，那里有个输入框啊，一些显示特定内容label啊等等；有一部分是会根据数据来显示内容的，比如tableView来显示好友列表啊，这个tableView的显示内容肯定是根据数据来显示的。我们使用MVC解决问题的时候，通常是解决这些根据数据来显示内容的视图。 CController（控制器）：是应用程序中处理用户交互的部分。通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。 Controller是MVC中的数据和视图的协调者，也就是在Controller里面把Model的数据赋值给View来显示（或者是View接收用户输入的数据然后由Controller把这些数据传给Model来保存到本地或者上传到服务器）。 综合以上内容，实际上你应该可以通过面向对象的基本思想来推导出controller出现的原因：我们所有的App都是界面和数据的交互，所以需要类来进行界面的绘制，于是出现了View，需要类来管理数据于是出现了Model。我们设计的View应该能显示任意的内容比如UILabel显示的文字应该是任意的而不只是某个特定Model的内容，所以我们不应该在View的实现中去写和Model相关的任何代码，如果这样做了，那么View的可扩展性就相当低了。而Model只是负责处理数据的，它根本不知道数据到时候会拿去干啥，可能拿去作为算法噼里啪啦去了，可能拿去显示给用户了，它既然无法接收用户的交互，它就不应该去管和视图相关的任何信息，所以Model中不应该写任何View相关代码。然而我们的数据和界面应该同步，也就是一定要有个地方要把Model的数据赋值给View，而Model内部和View的内部都不可能去写这样的代码，所以只能新创造一个类出来了，取名为Controller。它被UIKit逐渐完善成了我们现在使用的UIViewController。 下面看这张图斯坦福大学公开课上的这幅图来说明，这可以说是最经典和最规范的MVC标准这张图把MVC分为三个独立的区域，并且中间用了一些线来隔开。很有意思的设计，因为这些线似乎出现在了驾校科目一的内容中，你瞧C和V以及C和M之间的白线，一部分是虚线一部分是实线对吧，这就表明了引用关系：C可以直接引用V和M，而V和M不能直接引用C，至少你不能显式的在V和M的代码中去写和C相关的任何代码，而V和M之间则是双黄线，没错，它们俩谁也不能引用谁，你既不能在M里面写V，也不能在V里面写M。哦，上面的描述有点小小的问题，你不是“不能”这样写，而是“不应该”这样写，没人能阻止你在写代码的时候在一个M里面去写V，但是一旦你这样做了，那么你就违背了MVC的规范，你就不是在使用MVC了，所以这算是MVC的一个必要条件：使用MVC –&gt; M里面没有V的代码。所以M里面没有V的代码就是使用MVC的必要条件。 View和Controller的交互按钮点击事件，是View来接收的，但是处理这个事件的应该是Controller，所以View把这个事件传递给了Controller，如何传递的呢，见图，看到View上面的action没有，这就是事件，看到Controller上面的target没有，这就是靶子，View究竟要把事件传递给谁，它被规定了传递给靶子，Controller实际上就是靶子。只是View只负责传递事件，不负责关心靶子是谁。就像你是一个负责运货的少年，你唯一知道的是你要把货（action）交给上头（开发者）告诉你的那个收货的人（target），至于那个收货的人是警察还是怪兽，你都不需要关心。这是V和C的一种交互方式，叫做target-action。所以你看，这张图简直就是神来之笔，旁边还栩栩如生的画出了V对C的另一种传值：协议-委托。委托有两种：代理和数据源。什么是代理，就是专门处理should、will、did事件的委托，什么是数据源，就是专门处理data、count等等的委托。 Model和Controller的交互M是干嘛的？上面说了，M就是数据管理者，你可以理解为它直接和数据库打交道。这里的数据库可能是本地的，也可能是服务器上的，M会从数据库获取数据，也可能把数据上传给数据库。M也将提供属性或者接口来供C访问其持有的数据。我们就拿一个简单的需求作为例子，假如我想在一个模块中显示一段文字，这段文字是从网上获取下来的。那么使用MVC的话，在C中肯定需要一个UILabel（V）作为属性来显示这段文字，而这段文字由谁来获取呢，肯定是由M来获取了。而获取的地方在哪里呢？通常在C的生命周期里面，所以往往是在C的一个生命周期方法比如viewDidLoad里面调用M获取数据的方法来获取数据。现在问题来了，M获取数据的方法是异步的网络请求，网络请求结束后，C才应该用请求下来的数据重新赋值给V，现在的问题是，C如何知道网络请求结束了？这里我们一定要换一种角度去思考，我们进一步考虑M和V之间的关系：它们应该是一种同步的关系，也就是，不管任何时刻，只要M的值发生改变，V的显示就应该发生改变（显示最新的M的内容）。所以我们可以关注M的值改变，而不用关心M的网络请求是否结束了。实际上C根本不知道M从哪去拿的数据，C的责任是负责把M最新的数据赋值给V。所以C应该关注的事件是：M的值是否发生了变化。 MVVM什么是MVVMMVVM：Model、View、ViewModel。 你会下意识地把它和MVC来对比，你会发现，MVVM多了一个ViewModel而少了Controller。 首先说一下多出来的ViewModel（VM，不是显存）。VM的意义，和Model一样，在于数据。Model负责对数据进行取和存，然而我们对数据的操作除了取和存以外，还有一个非常重要的操作：解析。 MVVM的诞生就像我们之前分析MVC是如何合理分配工作的一样，我们需要数据所以有了M，我们需要界面所以有了V，而我们需要找一个地方把M赋值给V来显示，所以有了C，然而我们忽略了一个很重要的操作：数据解析。在MVC出生的年代，手机APP的数据往往都比较简单，没有现在那么复杂，所以那时的数据解析很可能一步就解决了，所以既然有这样一个问题要处理，而面向对象的思想就是用类和对象来解决问题，显然V和M早就被定义死了，它们都不应该处理“解析数据”的问题，理所应当的，“解析数据”这个问题就交给C来完成了。而现在的手机App功能越来越复杂，数据结构也越来越复杂，所以数据解析也就没那么简单了。如果我们继续按照MVC的设计思路，将数据解析的部分放到了Controller里面，那么Controller就将变得相当臃肿。还有相当重要的一点：Controller被设计出来并不是处理数据解析的。1、管理自己的生命周期；2、处理Controller之间的跳转；3、实现Controller容器。这里面根本没有“数据解析”这一项，所以显然，数据解析也不应该由Controller来完成。那么我们的MVC中，M、V、C都不应该处理数据解析，那么由谁来呢？这个问题实际上在面向对象的时候相当好回答：既然目前没有类能够处理这个问题，那么就创建一个新的类出来解决不就好了？所以我们聪明的开发者们就专门为数据解析创建出了一个新的类：ViewModel。这就是MVVM的诞生。 如何实现MVVM搞清楚了MVVM为什么会出现，将对于你理解如何实现MVVM有极大的帮助。在我们开始着手实现MVVM之前，我先简单提一下之前遗留的一个问题：为什么MVVM这个名字里面，没有Controller的出现（为什么不叫MVCVM，C去哪了）。本来这个问题应该在实现后再来解释，但是我们这里是教学，为了让大家更好的明白我们接下来的思想，所以这里要提前解释一下这个结论：Controller的存在感被完全的降低了。我们在待会实现MVVM的时候你就能体会到了，这里请先把这个结论印在脑海当中：Controller的存在感被完全的降低了、Controller的存在感被完全的降低了、Controller的存在感被完全的降低了。好的，我们终于要开始着手实现MVVM了。如果你已经搞懂了MVC，那么用MVVM实现一个相同的功能将会变得非常简单。你只需要记住两点：1、Controller的存在感被完全的降低了；2、VM的出现就是Controller存在感降低的原因。 Controller存在感降低的原因在MVVM中，Controller不再像MVC那样直接持有Model了。想象Controller是一个Boss，数据是一堆文件（Model），如果现在是MVC，那么数据解析（比如整理文件）需要由Boss亲自完成，然而实际上Boss需要的仅仅是整理好的文件而不是那一堆乱七八糟的整理前的文件。所以Boss招聘了一个秘书，现在Boss就不再需要管理原始数据（整理之前的文件）了，他只需要去找秘书：你帮我把文件整理好后给我。那么这个秘书就首先去拿到文件（原始数据），然后进行整理（数据解析），接下来把整理的结果给Boss。所以秘书就是VM了，并且Controller（Boss）现在只需要直接持有VM而不需要再持有M了。如果再进一步理解C、VM、M之间的关系：因为Controller只需要数据解析的结果而不关心过程，所以就相当于VM把“如何解析Model”给封装起来了，C甚至根本就不需要知道M的存在就能把工作做好，前提它需要持有一个VM。那么我们MVVM中的持有关系就是：C持有VM，VM持有M。这里有一个比较争议的地方：C该不该持有M。我的答案是不该。为什么呢，因为C持有M没有任何意义。就算C直接拿到了M的数据，它还是要去让VM进行数据解析，而数据解析就需要M，那么直接让VM持有M而C直接持有VM就足够了。最后再分享一个我在实现MVVM中的一个技巧，也谈不上是技巧吧，算是一种必要的思想：一旦在实现Controller的过程中遇到任何跟Model（或者数据）相关的问题，就找VM要答案。这个思想待会我们会在实现代码的时候用到。 最后贴图文章参考：https://blog.csdn.net/u013282174/article/details/51220199]]></content>
      <categories>
        <category>框架设计</category>
      </categories>
      <tags>
        <tag>MVC和MVVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6学习笔记]]></title>
    <url>%2F2019%2F06%2F04%2FES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1.变量&emsp;&emsp;var&emsp;重复申明、函数级作用域&emsp;&emsp;let&emsp;不能重复申明、块级作用域、变量&emsp;&emsp;const&emsp;不能重复申明、块级作用域、常量 2.箭头函数&emsp;&emsp;a.方便&emsp;&emsp;&emsp;&emsp;i.如果只有一个参数，（）可以省&emsp;&emsp;&emsp;&emsp;ii.如果只有一个return，{}可以省&emsp;&emsp;b.修正this&emsp;&emsp;this相对正常点 3.参数扩展&emsp;&emsp;收集&emsp;&emsp;扩展 &emsp;&emsp;默认参数&emsp;&emsp;&emsp;&emsp;function show(a,b=5){&emsp;&emsp;&emsp;&emsp;} 4.数组方法&emsp;&emsp;map&emsp;&emsp;&emsp;&emsp;映射&emsp;&emsp;reduce&emsp;&emsp;&emsp;汇总：一堆-&gt;一个&emsp;&emsp;filter&emsp;&emsp;&emsp;&emsp;过滤：一堆-&gt;剩下的&emsp;&emsp;forEach&emsp;&emsp;&ensp;循环 5.字符串&emsp;&emsp;startsWith&emsp;&emsp;以什么开头&emsp;&emsp;endsWith&emsp;&emsp;以什么结尾&emsp;&emsp;字符串模板：`\${a}xxx\${b}` 6.Promise&emsp;&emsp;封装异步的操作 &emsp;&emsp;promise.all([ ]); 7.generator&emsp;&emsp;function *show(){&emsp;&emsp;yield&emsp;&emsp;} 8.JSON&emsp;&emsp;JSON.stringify({a:12,b:5}) =&gt; ‘{“a”:12,”b”:5}’&emsp;&emsp;JSON.parse(‘{“a”:12,”b”:5}’) =&gt; {a:12,b:5} 9.解构赋值&emsp;&emsp;let [a,b,c]=[12,5,8]; &emsp;&emsp;注意点：&emsp;&emsp;&emsp;&emsp;1.左右结构一样&emsp;&emsp;&emsp;&emsp;2.右边是个合法的东西&emsp;&emsp;&emsp;&emsp;3.声明、赋值一次完成 10.面向对象&emsp;&emsp;&emsp;&emsp;对象新写法：&emsp;&emsp;class Test{&emsp;&emsp;&emsp;&emsp;constructor(){&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;this.xxx=&emsp;&emsp;&emsp;&emsp;}&emsp;&emsp;&emsp;&emsp;方法1（）{ &emsp;&emsp;&emsp;&emsp;}&emsp;&emsp;&emsp;&emsp;方法2（）{ &emsp;&emsp;&emsp;&emsp;}&emsp;&emsp;} &emsp;&emsp;&emsp;&emsp;继承：&emsp;&emsp;&emsp;&emsp;class Cs2 extends Cls1{&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;constructor(){&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;super();&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;}&emsp;&emsp;&emsp;&emsp;}]]></content>
      <categories>
        <category>es6</category>
      </categories>
      <tags>
        <tag>es6笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[post大文件上传失败原因]]></title>
    <url>%2F2019%2F06%2F04%2FPHP-post%E5%A4%A7%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%A4%B1%E8%B4%A5%E5%8E%9F%E5%9B%A0%2F</url>
    <content type="text"><![CDATA[## post大文件上传失败原因 今天在使用使用post上传文件的时候发现报错了，原因竟然是因为文件过大。这就很奇怪了，post上传文件不是没有大小限制嘛？这里报错其实并不是代码的问题，错误在于web服务器对于文件上传大小有限制，当你上传的文件大小超过他的限制就会出现这种情况。 解决办法12345678//如果想修改上传文件的限制可以修改php.ini文件file_uploads = On; //是否允许上传文件 On/off 默认是onupload_max_filesize = 2048M; //上传文件最大限制，默认2Mpost_max_size = 2048M // 通过Post提交的最多数据max_execution_time = 30000; //脚本最长的执行事件 单位为秒max_input_time = 30000； //接收提交的数据的时间限制 单位为秒memory_limit = 2048M; //最大内存消耗 在我电脑上文件地址是：H:\wamp\bin\apache\apache2.4.23\bin这个按照你自己电脑安装的位置来就行了找到这个文件用phpstorm打开（不要用记事本打开，会出现格式问题）然后Ctrl+F查找upload_max_filesize 改为2048M（改多少看个人需求了）其他的也一样改就行了，把所有的改完用Ctrl+S保存一下然后把web服务器重启一下就行了。然后测试上传成功。]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>post大文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bootstrap的使用方法及其基本模板]]></title>
    <url>%2F2019%2F06%2F04%2Fbootstrap%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E5%8F%8A%E5%85%B6%E5%9F%BA%E6%9C%AC%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[### 什么是Bootstrap Bootstrap来自 Twitter，是目前很受欢迎的前端框架。Bootstrap 是基于 HTML、CSS、JavaScript 的，它简洁灵活，使得 Web 开发更加快捷。它由Twitter的设计师Mark Otto和Jacob Thornton合作开发，是一个CSS/HTML框架。Bootstrap提供了优雅的HTML和CSS规范，它即是由动态CSS语言Less写成。Bootstrap一经推出后颇受欢迎，一直是GitHub上的热门开源项目，包括NASA的MSNBC（微软全国广播公司）的Breaking News都使用了该项目。 国内一些移动开发者较为熟悉的框架，如WeX5前端开源框架等，也是基于Bootstrap源码进行性能优化而来。 如何使用1.下载bootstrap下载链接：https://v3.bootcss.com/getting-started/下载有三个版本如果仅仅是使用的话下载第一个就行了 2.引入只需要把下载好的文件解压拖入webstrom即可 3.基本模板1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt; &lt;title&gt;使用模板&lt;/title&gt; &lt;!-- Bootstrap地址，使用自己的地址就行了 --&gt; &lt;link href="https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/css/bootstrap.min.css" rel="stylesheet"&gt; &lt;!--兼容IE8--&gt; &lt;script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"&gt;&lt;/script&gt; &lt;/head&gt;&lt;body&gt;&lt;h1&gt;你好，世界！&lt;/h1&gt;&lt;!-- jQuery地址 (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) --&gt;&lt;script src="https://cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"&gt;&lt;/script&gt;&lt;!-- js地址下载文件中有（加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。） --&gt;&lt;script src="https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/js/bootstrap.min.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 模板注意点: 3个meta标签必须放在最前面 引入bootstrap地址 引入jquery文件(Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) 引入下载文件中的js文件（bootstrap.min.js） 4.使用方法1.在bootstrap官网中找到自己想要的功能（bootstrap中文官网：http://www.bootcss.com/）2.把模板复制到想要放置的位置例如：标签页的模板把代码复制到想要放置的地方（我这里是放在了body里）。效果图：3.修改样式，改成自己想要的]]></content>
      <categories>
        <category>bootstrap</category>
      </categories>
      <tags>
        <tag>bootstrap使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于请求报文，响应报文前端需要知道哪些？面试的时候又该如何回答？]]></title>
    <url>%2F2019%2F06%2F04%2F%E5%85%B3%E4%BA%8E%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%EF%BC%8C%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E5%89%8D%E7%AB%AF%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E5%93%AA%E4%BA%9B%EF%BC%9F%E9%9D%A2%E8%AF%95%E7%9A%84%E6%97%B6%E5%80%99%E5%8F%88%E8%AF%A5%E5%A6%82%E4%BD%95%E5%9B%9E%E7%AD%94%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[在学习web前端Ajax时需要进行前端后端交互，这时候我们需要了解什么是请求报文，什么是响应报文，我们前端需要用到哪些？ 1. 请求报文一个HTTP请求报文由请求行（request line）、请求头部（header）和请求主体3个部分组成。 1.1 请求行请求行由三部分组成：请求方法，请求URL（不包括域名），HTTP协议版本请求方法比较多：GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT最常用的是GET和POST。 1.2 请求头请求头部由关键字/值对组成，每行一对 User-Agent : 产生请求的浏览器类型Accept : 客户端希望接受的数据类型，比如 Accept：text/xml（application/json）表示希望接受到的是xml（json）类型Content-Type：发送端发送的实体数据的数据类型。比如，Content-Type：text/html（application/json）表示发送的是html类型。Host : 请求的主机名，允许多个域名同处一个IP地址，即虚拟主机。 1.3 请求主体GET没有请求数据，POST有。 与请求数据相关的最常使用的请求头是 Content-Type 和 Content-Length 。 2. 响应报文HTTP响应报文和请求报文的结构差不多，也是由三个部分组成：状态行，响应头，响应主体 2.1 状态行状态行也由三部分组成：服务器HTTP协议版本，响应状态码，状态码的文本描述格式：HTTP-Version Status-Code Reason-Phrase CRLF比如：HTTP/1.1 200 OK状态码：由3位数字组成，第一个数字定义了响应的类别 1xx：指示信息，表示请求已接收，继续处理2xx：成功，表示请求已被成功接受，处理。3xx：重定向4xx：客户端错误5xx：服务器端错误，服务器未能实现合法的请求 2.2 响应头服务器的一些信息，服务器想要告诉浏览器的一些信息。 2.3 响应主体正常用户看到的内容。 3. 面试时如何回答？请求报文：请求报文包括请求行、请求头、请求主体。主要有：发送的方法、浏览器的信息以及发送的数据。 响应报文：响应报文包括状态行、响应头和响应主体。主要是：请求是否成功，服务器的信息以及浏览器中直接可以看到的内容。]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>请求报文，响应报文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[遮罩层的简单使用分析]]></title>
    <url>%2F2019%2F06%2F04%2F%E9%81%AE%E7%BD%A9%E5%B1%82%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[今天我们来聊聊遮罩层的简单使用。遮罩层是基于以下几个属性来实现的： 1.z-index定义：z-index 属性设置元素的堆叠顺序。拥有更高堆叠顺序的元素总是会处于堆叠顺序较低的元素的前面。简单来说就是谁的z-index属性值高在z轴方向会在更外面。 2.opacity作用：规定不透明度。从 0.0 （完全透明）到 1.0（完全不透明）。 3.display这里我们只需要理解这个属性的两个值：none :此元素不会被显示。block :此元素将显示为块级元素，此元素前后会带有换行符。(简单理解就是显示) 4.position定位，需要这个属性是因为，有了这个属性才可以控制遮罩层放哪（一般在中心位置）。 这些了解以后，看看下面的案例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;遮罩层&lt;/title&gt; &lt;style&gt; html,body &#123; margin:0; height:100%; &#125; #shade&#123; position:absolute; top:0; left:0; z-index:2; /*z-index 属性设置元素的堆叠顺序。拥有更高堆叠顺序的元素总是会处于堆叠顺序较低的元素的前面。*/ width:100%; height:100%; background-color:#000; opacity:0.3; /*opacity透明度*/ /*兼容IE8及以下版本浏览器*/ filter: alpha(opacity=30); display:none; &#125; #modal &#123; position: absolute; z-index:3; top: 0; bottom: 0; left: 0; right: 0; width:200px; height:200px; margin: auto; display:none; background-color:skyblue; &#125;&lt;/style&gt; &lt;script&gt; window.onload=function()&#123; var a1=document.getElementById('a1'); var a2=document.getElementById('a2'); a1.onclick=shield; a2.onclick=cancel_shield; function shield(e)&#123; e.preventDefault();//取消事件的默认动作。 var shade = document.getElementById("shade"); shade.style.display = "block"; var modal = document.getElementById("modal"); modal.style.display = "block"; &#125; function cancel_shield(e)&#123; e.preventDefault();//取消事件的默认动作。 var shade = document.getElementById("shade"); shade.style.display = "none"; var modal = document.getElementById("modal"); modal.style.display = "none"; &#125; &#125;;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;a id="a1" href="#"&gt;打开遮罩&lt;/a&gt;&lt;div id="shade"&gt;&lt;/div&gt;&lt;div id="modal"&gt; &lt;a id="a2" href="#"&gt;关闭&lt;/a&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果图：开始：点击：打开遮罩 总结总的来说，遮罩其实是在原来界面上加上一个半透明的蒙版，然后在外面在加一个你想要实现的效果。注意点：1.z-index的值是大的在外面。2.position属性如果不设置则无法移动位置。]]></content>
      <categories>
        <category>css/html</category>
      </categories>
      <tags>
        <tag>遮罩层</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端学习路线---避免踩坑]]></title>
    <url>%2F2019%2F06%2F04%2F%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF---%E9%81%BF%E5%85%8D%E8%B8%A9%E5%9D%91%EF%BC%8C%E7%9B%B4%E5%87%BB%E5%85%AC%E5%8F%B8%E9%9C%80%E6%B1%82%2F</url>
    <content type="text"><![CDATA[我自己在学习web前端之前对web的学习路线也是很懵，在网上查了查各种学习路线也是有点慌。今天我就自己的学习过程来聊一聊web各个阶段需要学习的内容，以及怎么样就可以去面试了。 初期阶段html+css+javaScript。在我看来html负责网页点基本框架—房梁，毛胚房。css负责网页点美化装饰—房屋的装修。js负责网页的一些特效让其更酷炫—房屋的一些功能性建筑。学完这一部分我们如果可以自己写一个静态页面也就差不多了。学习视频推荐：1.html,css部分：http://yun.itheima.com/course/267.html2.js部分：https://www.bilibili.com/video/av34087791?from=search&amp;seid=2090123722468261815 中级阶段h5,c3,jQuery,Ajax（php基础）这一阶段就需要学以上部分的内容了，php基础如果有时间学完了自然好，不够作为前端，php部分只需要一些基础罢了，因为在学Ajax时，需要前后端交互需要懂一些后端知识，这里推荐一个视频是ajax和php一起学习的 ：https://www.bilibili.com/video/av15657082?from=search&amp;seid=1260798168543389571h5,cs3推荐视频：https://www.bilibili.com/video/av32966342?p=2jQuery推荐视频：https://www.bilibili.com/video/av40716170?from=search&amp;seid=6250929934997451575 学完这些以后已经可以出去找实习了，不过如果想去比较好的公司的话还需要学习一些框架。 高级阶段bootstrap,vue,es6,node.js框架其实有很多为什么选择以上这些框架呢？这是我在各大招聘网站上看那些大公司对实习生的要求汇总选择出来的，也许有部分公司要求不一样，不过以上框架已经可以满足大部分公司的需求了。bootstrap属于一个css部分的ui框架方便我们界面布局，推荐视频：https://www.bilibili.com/video/av10636408?from=search&amp;seid=8826659398424695725vue推荐视频：https://www.bilibili.com/video/av36650577?from=search&amp;seid=13367424259640329646es6推荐视频:https://www.bilibili.com/video/av20327829?from=search&amp;seid=12468498045351456704node.js是属于后端的，那为什么把他写在这呢？现如今许多前端框架都依赖node.js，node.js也使前端工作变的更加轻松，在某一方面改变了前端以前比较尴尬的情况。node.js推荐视频：https://www.bilibili.com/video/av27670326?from=search&amp;seid=16453837271820328900 学无止境做web前端需要有一个意识—学无止境。现如今技术更新换代特别快，几年就出一个新框架，如果一直保守自己懂的那几个老框架，虽然也能完成任务，但久而久之势必会被淘汰。当学完了以上那些东西，web也属于入门了这时候我推荐还是多看一些书籍。这里我推荐几本书籍。推荐书籍：javaScript高级程序设计（第三版）（红宝书），javaScript权威指南（第六版）（犀牛书），javascript DOM编程艺术（第二版）以上推荐的都是原生javaScript的一些书籍，毕竟框架在怎么出新也是在原生javaScript的基础上写出来的，只有基础扎实才能走的更远。 以上是我就自身而谈的一些观点，也许不完全正确，欢迎大家指正。也欢迎对web感兴趣的小伙伴和我交流。]]></content>
      <categories>
        <category>css/html</category>
      </categories>
      <tags>
        <tag>心得分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用css中的border绘制三角形的方法和原理]]></title>
    <url>%2F2019%2F06%2F04%2F%E4%BD%BF%E7%94%A8css%E4%B8%AD%E7%9A%84border%E7%BB%98%E5%88%B6%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E6%96%B9%E6%B3%95%E5%92%8C%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[实现首先看看怎么实现的贴上代码; 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .sjx&#123; width: 0px; height: 0px; border-width: 40px; border-style: solid; border-color: transparent transparent transparent red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="sjx"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果图： 分析代码主要代码就是style中的border样式。首先宽高设为0，border-width就是三角形的高度，border-color（上，右，下，左）这里把前三个设置为透明，第四个设置为红色，所以三角形方向是向右的。为了方便理解，这里把border-color四个颜色都设置出来看看 这里可以这么理解:由于div宽高设置为0，而边框为40px就会出现一个80*80的正方形，上下左右平分则是四个三角形。但如果不设置下边框而设置其他三个边框则会如下图： 从这里可以看出没了下边框就变成了40*80的长方形，所以实质上这个正方形还是4个40*80的矩形拼成的。但是如果只设置左右，或者上下的边框则什么也没有，因为div长宽都为0，则显示不出来，这里之所以会显示是因为上下和左右至少各有一个，会互相赋值，比如上边框高度为40px由于没有宽度则不显示，此时如果设置一个左边框会把左边框的高40px赋值给上边框的框则会显示出来。]]></content>
      <categories>
        <category>css/html</category>
      </categories>
      <tags>
        <tag>border绘制三角形</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css选择器权重及其计算规则]]></title>
    <url>%2F2019%2F06%2F04%2Fcss%E9%80%89%E6%8B%A9%E5%99%A8%E6%9D%83%E9%87%8D%E5%8F%8A%E5%85%B6%E8%AE%A1%E7%AE%97%E8%A7%84%E5%88%99%2F</url>
    <content type="text"><![CDATA[css选择器 @[toc] 选择器类型 ID #id class .class 标签 p 通用 * 属性 [type=”text”] 伪类 ：hover 伪元素 ::first-line 子选择器、相邻选择器 css选择器权重值 选择器 权重 !important 权重 !important Infinity(无限大) 行列样式 1000 Id选择器 0100 Class选择器/属性/伪类 0010 标签选择器 0001 *通配符选择器 0000 (大于默认样式与继承验样式) 继承样式 权重最小(比*通配符还小) 注意：选择器的权重值不是一个确定的值，例如标签选择器的权重值为1，但是这个1是一个256进制数，就是0到255后+1才是1。就是说权重值2和1中间差了255。这表示256个权重值为1的选择器加一起才抵得上一个权重为2的，这在后面权重计算有用。 还有需要注意的是，！important的权重值虽然是正无穷，但其实也是可也计算的，比如正无穷+1或者*1，就是要比正无穷大，在计算机中正无穷的值，都是一个有界的。不是数学上无界的一个慨念！权重计算方法 一般而言，选择器越特殊，它的优先级越高。也就是选择器指向的越准确，它的优先级就越高。单一选择器直接比较权重，多个选择器则需要计算。 复杂的计算方法： 用1表示派生选择器的优先级 用10表示类选择器的优先级 用100标示ID选择器的优先级- div.test1 .span var 优先级 1+10 +10 +1 span#xxx .songs li 优先级1+100 + 10 + 1 #xxx li 优先级 100 +1 案例]]></content>
      <categories>
        <category>css/html</category>
      </categories>
      <tags>
        <tag>选择器权重计算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css控制超出一行内容显示省略号]]></title>
    <url>%2F2019%2F06%2F04%2Fcss%E6%8E%A7%E5%88%B6%E8%B6%85%E5%87%BA%E4%B8%80%E8%A1%8C%E5%86%85%E5%AE%B9%E6%98%BE%E7%A4%BA%E7%9C%81%E7%95%A5%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[前言在前端开发过程中，经常会遇到文字超过一行内容的情况，要求隐藏超出部分并且以省略号显示。像这样： 实现方法主要依赖下面三个属性实现 123456/* 规定段落中的文本不进行换行： */white-space: nowrap;/* 内容会被修剪，并且其余内容是不可见的。 */overflow: hidden;/* 显示省略符号来代表被修剪的文本。 */text-overflow: ellipsis 实例1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body &#123; width: 500px; text-align: center; &#125; div&#123; /* 规定段落中的文本不进行换行： */ white-space: nowrap; /* 内容会被修剪，并且其余内容是不可见的。 */ overflow: hidden; /* 显示省略符号来代表被修剪的文本。 */ text-overflow: ellipsis &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;“世界很复杂，百度更懂你”，百度翻译拥有网页版和手机APP等多种产品形态，此外还针对开发者提供开放云接口服务，日均响应上亿次翻译请求。除文本翻译外，结合用户多样性的翻译需求，推出网页翻译、网络释义、海量例句、权威词典、离线翻译、语音翻译、对话翻译、实用口语、拍照翻译、AR翻译、趣味配音等功能，同时还针对对译文质量要求较高的用户，提供人工翻译服务，让用户畅享每一次翻译体验。&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果如图：]]></content>
      <categories>
        <category>css/html</category>
      </categories>
      <tags>
        <tag>css控制一行显示</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端必备PS技巧]]></title>
    <url>%2F2019%2F06%2F04%2F%E5%89%8D%E7%AB%AF%E5%BF%85%E5%A4%87PS%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[PS在前端主要有两方面的应用：1：测量图像大小、距离 2：切图测量不用说大家平时开发都需要用，而切图也是前端必备技能。我们作为前端会比UI更清楚我们需要的图片，有时候需要修改也可以自己动手，不必处处麻烦UI，也提高了工作效率。 那我们从零开始吧！ 1.下载工具PS在这里分享一下正版PS安装包，内含注册码的，链接失效了可以下方评论。下载链接：链接：https://pan.baidu.com/s/1oIeHrcH2VBGx8ujO2MGiKA提取码：adoz 2. 设置工具为了使用更加方面我们可以先设置一下一些窗口格式。在上面菜单栏点击窗口把：图层，信息，历史记录勾选上在视图窗口把标尺勾选上。 3.测量和取色 【测量宽高】工具：参考线，矩形选框，信息面板。 1 从标尺上拉出参考线（在标尺上按住鼠标左键不松往你想要地方拉，就会出现一根线，上下左右都可以，也可以不拉，拉了会更精确些，选框会自动吸附到参考线上） 2 找到矩形选框，选中你要测量的地方，选中的时候你可以看两个地方：1 鼠标位置有显示宽高 2 信息面板也有显示。不过当你松开鼠标，就只有信息面板有显示信息了，如下。 【取色】：取色器+吸管工具 1 点击取色器，会出现一个面板，这个时候把鼠标放在图片上会发现自动变成了吸管工具，不用专门去找，然后点击你想要取的颜色，面板上就出现你想要的信息。（还可以用取色器检查你的按钮或者背景是不是是纯色） 4.切图 ：切片工具现在工具栏找到切片工具：选取需要切的范围，然后在菜单栏—&gt;文件—&gt;转为web格式然后调整图片格式和质量按自己需求来：然后存储到相应位置使用即可。]]></content>
      <categories>
        <category>css/html</category>
      </categories>
      <tags>
        <tag>ps</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3 @media 查询]]></title>
    <url>%2F2019%2F06%2F04%2FCSS3%40media%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[CSS3 @media 查询 首先贴一个例子： 如果文档宽度小于 300 像素则修改背景颜色(background-color): 12345@media screen and (max-width: 300px) &#123; body &#123; background-color:lightblue; &#125;&#125; 定义和使用使用 @media 查询，你可以针对不同的媒体类型定义不同的样式。 @media 可以针对不同的屏幕尺寸设置不同的样式，特别是如果你需要设置设计响应式的页面，@media 是非常有用的。 当你重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面。 Media所有参数汇总 width:浏览器可视宽度。 height:浏览器可视高度。 device-width:设备屏幕的宽度。 device-height:设备屏幕的高度。 orientation:检测设备目前处于横向还是纵向状态。 aspect-ratio:检测浏览器可视宽度和高度的比例。(例如：aspect-ratio:16/9) device-aspect-ratio:检测设备的宽度和高度的比例。 color:检测颜色的位数。（例如：min-color:32就会检测设备是否拥有32位颜色） color-index:检查设备颜色索引表中的颜色，他的值不能是负数。 monochrome:检测单色楨缓冲区域中的每个像素的位数。（这个太高级，估计咱很少会用的到） resolution:检测屏幕或打印机的分辨率。(例如：min-resolution:300dpi或min-resolution:118dpcm)。 grid：检测输出的设备是网格的还是位图设备。 使用方法 准备工作1：设置Meta标签首先我们在使用Media的时候需要先设置下面这段代码，来兼容移动设备的展示效果： 1&lt;meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"&gt; 这段代码的几个参数解释： width = device-width：宽度等于当前设备的宽度 initial-scale：初始的缩放比例（默认设置为1.0） minimum-scale：允许用户缩放到的最小比例（默认设置为1.0） maximum-scale：允许用户缩放到的最大比例（默认设置为1.0） user-scalable：用户是否可以手动缩放（默认设置为no，因为我们不希望用户放大缩小页面） 准备工作2：加载兼容文件JS因为IE8既不支持HTML5也不支持CSS3 Media，所以我们需要加载两个JS文件，来保证我们的代码实现兼容效果： 1234&lt;!--[if lt IE 9]&gt; &lt;script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"&gt;&lt;/script&gt; &lt;script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"&gt;&lt;/script&gt;&lt;![endif]--&gt; 准备工作3：设置IE渲染方式默认为最高(这部分可以选择添加也可以不添加)现在有很多人的IE浏览器都升级到IE9以上了，所以这个时候就有又很多诡异的事情发生了，例如现在是IE9的浏览器，但是浏览器的文档模式却是IE8: 为了防止这种情况，我们需要下面这段代码来让IE的文档模式永远都是最新的： 1&lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; 案例1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"/&gt;&lt;style&gt;body &#123; background-color:lightgreen;&#125;@media screen and (max-width: 300px) &#123; body &#123; background-color:lightblue; &#125;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;重置浏览器查看大小。当浏览器窗口的宽度小于 300 像素时，背景颜色会变成淡蓝，否则是淡绿色。&lt;input type="button" onclick="resize_window()" value="查看效果"&gt;&lt;/p&gt;&lt;SCRIPT&gt;&lt;!--function resize_window() &#123; window.open ('http://www.w3cschool.cc/try/demo_source/trycss3_media_example1.htm','newwindow','height=299,width=299,top=0,left=0,toolbar=no,menubar=no,scrollbars=no, resizable=no,location=no, status=no')&#125;//写成一行--&gt;&lt;/SCRIPT&gt;&lt;/body&gt;&lt;/html&gt; 效果图参考：http://www.520ued.comhttp://www.runoob.com/cssref/css3-pr-mediaquery.html]]></content>
      <categories>
        <category>H5/C3</category>
      </categories>
      <tags>
        <tag>_@media</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rem、em的区别与使用方法]]></title>
    <url>%2F2019%2F06%2F04%2Frem%E3%80%81em%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[## 前言 我们先来看看比较重要的两点： rem与em的本质区别 rem(root element)是参照html的font-size,em(element)是参照父元素的font-size 使用rem与em的优点 以rem/em为单位比px更方便,屏幕尺寸发生变化时只需要更改html/body基数即可,不需要再重新给每个标签写不同的font-size rem 使用rem为单位,系统处理时(将rem转化为px)只会看html的font-size 在使用media query做响应式布局时(以bootstrap为例)： a.首先要做的是确定rem的基数(即html的font-size),一般都是以10px为基数(方便计算),这个可以根据自己的习惯来. b.确定html基准百分数(rem参照下html的字体大小采取百分数形式),百分数是自己设定的基数除以默认字体大小(16px)的值.比如以10px为基数时,基准百分数就是: 10px/16px=62.5%;即设置html的font-size为62.5%; c.当html的基准百分数设置之后,元素使用rem为单位时就是以基数(a中设置的基数值)为基础单位,换算方式为: 10px=1rem;比如要设置一个p标签的字体大小为20px,用rem表示就是2rem(公式: 以rem为单位的值=想要设置的字体大小(20px)/基数值(10px)=2rem). d.响应式实现: 使用@media 在监测到屏幕尺寸发生变化时只需为html设置不同的基数值即可 如下面例子: 在屏幕宽度小于414px时以8px为基数,非响应式下(415px-1365px)以10px为基数;大于1366px时以12px为基数 12345678910111213141516171819html&#123; font-size: 62.5%; // 以10px为基数,此时class为a的标签字体大小为20px&#125; .a&#123; font-size: 2rem;&#125; @media screen and (max-width: 414px)&#123; html&#123; font-size: 50%; // 以8px为基数,此时class为a的标签字体大小为16px &#125;&#125; @media screen and (min-width: 1366px)&#123; html&#123; font-size: 75%; // 以12px为基数,此时class为a的标签字体大小为24px &#125;&#125; em 使用em为单位,系统处理时(将em转化为px)只会看父元素（本文以body为例）的font-size 使用px为基准此时只需要设置一个基数即可,然后接下来使用时只需要用想要的字体大小除以设置的基数值即为以em为单位的值;如: 设置em基数为10px,要设置一个标签的字体大小为15px,则em=想要设置的值(15px)/基数(10px)=1.5em.例: 12345678910111213141516171819body&#123; font-size: 10px; // 以10px为基数,此时class为a的标签字体大小为20px&#125; .a&#123; font-size: 2em;&#125; @media screen and (max-width: 414px)&#123; body&#123; font-size: 8px; // 以8px为基数,此时class为a的标签字体大小为16px &#125;&#125; @media screen and (min-width: 1366px)&#123; body&#123; font-size: 12px; // 以12px为基数,此时class为a的标签字体大小为24px &#125;&#125; 使用百分比为基准 使用方式同上面以rem为单位的步骤,例: 12345678910111213141516171819body&#123; font-size: 62.5%; // 以10px为基数,此时class为a的标签字体大小为20px&#125; .a&#123; font-size: 2em;&#125; @media screen and (max-width: 414px)&#123; body&#123; font-size: 50%; // 以8px为基数,此时class为a的标签字体大小为16px &#125;&#125; @media screen and (min-width: 1366px)&#123; body&#123; font-size: 75%; // 以12px为基数,此时class为a的标签字体大小为24px &#125;&#125; 说明: 具体使用时其实两者差不多,rem也可以直接以px为基准单位,只是两者参照标签不同,使用时需注意]]></content>
      <categories>
        <category>css/html</category>
      </categories>
      <tags>
        <tag>_rem _em</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端需要了解的JSON---数据读取与转化]]></title>
    <url>%2F2019%2F05%2F10%2F%E5%89%8D%E7%AB%AF%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84JSON---%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%8F%96%E4%B8%8E%E8%BD%AC%E5%8C%96%2F</url>
    <content type="text"><![CDATA[### 学习JSON之前我们需要明白的几点： 12345678/* * 1.json是一种数据的格式 * 2.json跟编程语言没有关系 * 3.json的载体是字符串 * 4.基本上所有的编程语言都支持JSON * 5.语言简洁 基本上所有的编程语言 都提供了对应的方法 来解析JSON * 6.JSON格式的字符串 转换完毕之后 会变成数组 对象 * */ json的写法 – 用来表示对象123456789//对象使用&#123;&#125; //属性名 必须使用""包裹 如果属性值是数值 可以不使用双引号 var JSONObject = '&#123;"name":"刘亦菲","skill":"失忆"&#125;'; console.log(JSONObject); //转化为 对应的 对象（数组） var obj = JSON.parse(JSONObject); console.log(obj); //读取对象属性值 console.log(obj.name+'|'+obj.skill); 结果： JSON的写法 – 用来表示数组1234567var JSONArr = '["绿色的花菜","大蒜","番茄","圣女果"]';console.log(JSONArr);//转化为对应的数组（对象）var arr = JSON.parse(JSONArr);console.log(arr);//读取数组中第三个元素console.log(arr[2]); 结果： JSON的写法 – 对象数组1234567var JSONObjArr = '&#123;"name":"彭林","skill":"约跑","friend":["周琳琳","林立群","....."]&#125;'; console.log(JSONObjArr); //转化为对应的对象数组 var result = JSON.parse(JSONObjArr); console.log(result); //读取对象数组元素 console.log(result.friend[1]); 结果：]]></content>
      <categories>
        <category>json</category>
      </categories>
      <tags>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剖析js原型与原型链]]></title>
    <url>%2F2019%2F05%2F10%2F%E5%89%96%E6%9E%90js%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[## 原型模式 &emsp;&emsp;我们创建的每一个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，而这这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。如果按字面意思来理解，那么prototype就是通过调用构造函数而创建的那个对象实例的原型对象。使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。换句话说，不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中，如下面的例子所示： 原型对象和实例的关系有点像JAVA中父类子类的关系，有些继承的味道。 12345678910111213141516function persion()&#123;&#125;persion.prototype.name = "Nicholas";persion.prototype.age = 29;persion.prototype.job = "Software Engineer";persion.prototype.sayName = function () &#123; alert(this.name);&#125;;var person1 = new persion();person1.sayName(); //"Nicholas"var person2 = new persion();person2.sayName(); //"Nicholas"alert(person1.sayName == person2.sayName); //"true" &emsp;&emsp;在此，我们将sayName（）方法和所有属性直接添加到了person的prototype属性中，构造函数变成了空函数。即使如此，也仍然可以通过调用构造函数来创建新对象，而且新对象还会具有相同的属性和方法。但与构造函数模式不同的是，新对象的这些属性和方法是由所有实例共享的。换句话说，person1和person2访问的都是同一组属性和同一个sayName（）函数。要理解原型模式的工作原理，必须先理解ECMAScript中原型对象的性质。 1.理解原型对象&emsp;&emsp;无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个prototype属性，这个属性指向函数的原型对象。在默认情况下，所有原型对象都会自动获得一个constructor（构造函数）属性，这个属性包含一个指向prototype属性所在函数的指针。就拿前面的例子来说，Person.prototype.constructor 指向person。而通过这个构造函数，我们还可继续为原型对象添加其他属性和方法。&emsp;&emsp;创建了自定义的构造函数之后，其原型对象默认只会取得 constructor属性；至于其他方法，则都是从object继承而来的。当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部属性），指向构造函数的原型对象。ECMA-262第5版中管这个指针叫[[Prototype]]。虽然在脚本中没有标准的方式访问[[Prototype]]，但Firefox、Safari和Chrome在每个对象上都支持一个属性proto；而在其他实现中，这个属性对脚本则是完全不可见的。不过，要明确的真正重要的一点就是，这个连接存在于实例与构造函数的原型对象之间，而不是存在于实例与构造函数之间。&emsp;&emsp;以前面使用Person构造函数和 Person.prototype创建实例的代码为例，图6-1展示了各个对象之间的关系。&emsp;&emsp;图6-1展示了person构造函数、person的原型属性以及person现有的两个实例之间的关系。在此，person.prototype 指向了原型对象，而Person.prototype.constructor又指回了Person。原型对象中除了包含constructor属性之外，还包括后来添加的其他属性。person的每个实例——person1和person2都包含一个内部属性，该属性仅仅指向了person.prototype；换句话说，它们与构造函数没有直接的关系。此外，要格外注意的是，虽然这两个实例都不包含属性和方法，但我们却可以调用person1.sayName（）。这是通过查找对象属性的过程来实现的。 这可以这么理解，构造函数是一个空函数。创建一个实例的代码虽然是构造函数new出来的，可实际上是通过原型对象创建出来的，实例与构造函数并没有直接的关系，实例是基于原型对象创建的，而原型对象的constructor指向构造函数。 &emsp;&emsp;虽然在所有实现中都无法访问到[[Prototype]]，但可以通过isPrototypeOf（）方法来确定对象之间是否存在这种关系。从本质上讲，如果[[Prototype]]指向调用isPrototypeof（）方法的对象（person.prototype），那么这个方法就返回true，如下所示： 12alert(Person.prototype.isPrototypeof(person1));//truealert(Person.prototype.isPrototypeof(person2));//true &emsp;&emsp;这里，我们用原型对象的isPrototypeof（）方法测试了person1和person2。因为它们内部都有一个指向Person.prototype的指针，因此都返回了true。&emsp;&emsp;ECMAScript5增加了一个新方法，叫object.getPrototypeof（），在所有支持的实现中，这个方法返回t[Prototype]]的值。例如： 12alert(Object.getPrototypeof(personl)==Person.prototype);//true alert(Object.getPrototypeof(person1). name);//"Nicholas" &emsp;&emsp;这里的第一行代码只是确定object.getPrototypeof（）返回的对象实际就是这个对象的原型。第二行代码取得了原型对象中name属性的值，也就是“Nicholas”。使用object.getPrototypeof（）可以方便地取得一个对象的原型，而这在利用原型实现继承（本章稍后会讨论）的情况下是非常重要的。支持这个方法的浏览器有IE9+、Firefox 3.5+、Safari 5+、Opera12+和Chrome。&emsp;&emsp;每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性。搜索首先从对象实例本身开始。如果在实例中找到了具有给定名字的属性，则返回该属性的值；如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性。如果在原型对象中找到了这个属性，则返回该属性的值。也就是说，在我们调用person1.sayName（）的时候，会先后执行两次搜索。首先，解析器会问：“实例 person1有sayName属性吗？”答：“没有。”然后，它继续搜索，再问：“person1的原型有sayName属性吗？”答：“有。”于是，它就读取那个保存在原型对象中的函数。当我们调用person2.sayName（）时，将会重现相同的搜索过程，得到相同的结果。而这正是多个对象实例共享原型所保存的属性和方法的基本原理。 搜索首先从对象实例本身开始。如果在实例中找到了具有给定名字的属性，则返回该属性的值；如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性。 &emsp;&emsp;虽然可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值。如果我们在实例中添加了一个属性，而该属性与实例原型中的一个属性同名，那我们就在实例中创建该属性，该属性将会屏蔽原型中的那个属性。来看下面的例子。 123456789101112function Person()&#123;Person. prototype. name="Nicholas"; Person. prototype. age=29; Person. prototype. job="Software Engineer"; Person. prototype, sayName=function()(alert(this. name);&#125;; var personl=new Person();var person2=new Person();peraonl.name =nGreg"；alert（person1.name）；//"Greg"—来自实例alert（person2.name）；//"Nicholaa"——来自原型 &emsp;&emsp;在这个例子中，person1的name 被一个新值给屏蔽了。但无论访问person1.name还是访问person2.name都能够正常地返回值，即分别是“Greg*（来自对象实例）和“wicholas”（来自原型）。当在alert（）中访问 person1.name时，需要读取它的值，因此就会在这个实例上搜索一个名为name的属性。这个属性确实存在，于是就返回它的值而不必再搜索原型了。当以同样的方式访问 person2.name时，并没有在实例上发现该属性，因此就会继续搜索原型，结果在那里找到了name-属性。&emsp;当为对象实例添加一个属性时，这个属性就会屏蔽原型对象中保存的同名属性；换句话说，添加这个属性只会阻止我们访问原型中的那个属性，但不会修改那个属性。即使将这个属性设置为nu11，也只会在实例中设置这个属性，而不会恢复其指向原型的连接。 可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值。如果实例中添加的属性与实例原型中一样则会断开该属性指向原型的连接 不过，使用delete 操作符则可以完全删除实例属性，从而让我们能够重新访问原型中的属性，如下所示。 123456789101112131415161718function Person()&#123;&#125;Person.prototype.name="Nicholas";Person.prototype.age=29;Person.prototype.job="Software Engineer";Person.prototype.sayName=function()&#123;alert（this.name）；&#125;;var personl=new Person();var pexson2=new Person();person1.name="Greg";alert(personl.name);//"Greg“——来自实例alert(person2.name);//"Nicholas“——来自原型delete personl.name;alert(peraonl.name);//"Nicholaa——来自原型 &emsp;&emsp;在这个修改后的例子中，我们使用delete操作符删除了person1.name，之前它保存的“Greg”值屏蔽了同名的原型属性。把它删除以后，就恢复了对原型中name属性的连接。因此，接下来再调用person1.name时，返回的就是原型中name属性的值了。 原型链&emsp;&emsp;ECMAScript中描述了原型链的概念，并将原型链作为实现继承的主要方法。其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。简单回顾一下构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。那么，假如我们让原型对象等于另一个类型的实例，结果会怎么样呢？显然，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立，如此层层递进，就构成了实例与原型的链条。这就是所谓原型链的基本概念。 可以简单理解成一个环套一个环和铁链一样。第一个环里的原型对象是第二个环里的实例，第二个环里的原型对象又是第三环里的实例则一环套一环。 &emsp;&emsp;实现原型链有一种基本模式，其代码大致如下。 123456789101112131415161718192021function SuperType()&#123;this. property=true;&#125;Superrype.prototype.get SuperValue=function（）&#123;return this.property;&#125;;function SubType（）&#123;this.subproperty=false;&#125;//继承了SuperType Subrype.prototype=newSuperlype（）;SubType.prototype.getSubValue=function（）&#123;return this.subproperty;）;var instance=new SubType（）;alert（instance.getSuperValue（））;//true &emsp;&emsp;以上代码定义了两个类型：Superrype和SubType。每个类型分别有一个属性和一个方法。它们的主要区别是Subrype继承了superrype，而继承是通过创建Superrype的实例，并将该实例赋给SubType.prototype实现的。实现的本质是重写原型对象，代之以一个新类型的实例。换句话说，原来存在于Superrype的实例中的所有属性和方法，现在也存在于Sublype.prototype中了。在确立了继承关系之后，我们给SubType.prototype 添加了一个方法，这样就在继承了SuperType的属性和方法的基础上又添加了一个新方法。这个例子中的实例以及构造函数和原型之间的关系如图6-4所示。&emsp;&emsp;在上面的代码中，我们没有使用Subype默认提供的原型，而是给它换了一个新原型；这个新原型就是superrype的实例。于是，新原型不仅具有作为一个Superrype的实例所拥有的全部属性和方法，而且其内部还有一个指针，指向了superrype的原型。最终结果就是这样的：instance指向 Subrype的原型，subrype的原型又指向Superrype的原型。getSupervalue（）方法仍然还在SuperType.prototype中，但property 则位于SubType.prototype中。这是因为property是一个实例属性，而 getSuperValue（）则是一个原型方法。既然 SubType.prototype 现在是Superrype的实例，那么property当然就位于该实例中了。此外，要注意instance.constructor现在指向的是Supertype，这是因为原来subrype.prototype中的 constructor被重写了的缘故。&emsp;&emsp;通过实现原型链，本质上扩展了本章前面介绍的原型搜索机制。读者大概还记得，当以读取模式访问一个实例属性时，首先会在实例中搜索该属性。如果没有找到该属性，则会继续搜索实例的原型。在通过原型链实现继承的情况下，搜索过程就得以沿着原型链继续向上。就拿上面的例子来说，调用instance.getSuperValue（）会经历三个搜索步骤：1）搜索实例；2）搜索Subrype.prototype；3）搜索SuperType.prototype，最后一步才会找到该方法。在找不到属性或方法的情况下，搜索过程总是要一环一环地前行到原型链末端才会停下来。 参考书籍：JavaScript高级程序设计（第三版）]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>原型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[匿名函数、自执行函数，自执行匿名函数和立即执行的函数表达式区别]]></title>
    <url>%2F2019%2F05%2F10%2F%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E3%80%81%E8%87%AA%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0%EF%BC%8C%E8%87%AA%E6%89%A7%E8%A1%8C%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E5%92%8C%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E7%9A%84%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[## 匿名函数、自执行函数，自执行匿名函数和立即执行的函数表达式区别 今天在写代码的时候发现对自执行函数有点懵，便去查询资料。然后紧接着自执行匿名函数，立即执行函数，匿名函数一窝蜂的出来了，借此就好好谈谈这几个函数的区别吧。 匿名函数匿名函数比较好理解，顾名思义就是没有名字的函数 12345678//普通函数:此函数声明了一个名为a的函数。 function a()&#123; return 1; &#125;;//匿名函数:这时你会发现报错了function()&#123; return 1;&#125;; 这时你会发现单独运行一个匿名函数，由于不符合语法要求，会报错。解决方法：只需要用（）把匿名函数包起来即可 123（function()&#123; return 1;&#125;;） 自执行函数，立即执行的函数在介绍这里之前，我们先聊一聊”自执行”这个说法，关于”自执行“每个人理解不一样，有人称他为：自动执行，也有称作：立即调用，在这里我比较认同另一种说法:立即调用的函数表达式。 什么是自执行？ 我们创建了一个匿名的函数，并立即执行它，由于外部无法引用它内部的变量，因此在执行完后很快就会被释放，关键是这种机制不会污染全局对象。 自执行函数，即定义和调用合为一体。 1234567//对于函数表达式，在后面加括号即可以让函数立即执行；例如下面这个函数，至于为什么加了括号就可以立即执行，我们可以这么理解，就是像f()；这样写的话，函数 可以立即执行是没问题的，我们在经常会用到，那么对于函数表达式来说，fn1就是对后面的匿名函数的一个引用，因此在后面的匿名函数后直接加括号，自然也就可以立即执行 var f = function()&#123; console.log("ss"); &#125;(); 自执行函数的其他几种写法我个人推荐第一种写法，好处是，能提醒阅读代码的人，这段代码是一个整体。 1234567891011121314151617//方法1：最前最后加括号(function()&#123; alert(1);&#125;());//方法2：function外面加括号(function()&#123; alert(1);&#125;)();方法3：function前面加运算符，常见的是!与void 。!function()&#123; alert(1);&#125;();void function()&#123; alert(2);&#125;(); 在参考了多个网站总算将这些理念弄清楚一些。 参考网址： http://www.cnblogs.com/TomXu/archive/2011/12/31/2289423.html https://www.cnblogs.com/jessiespur/p/9283101.html https://www.jianshu.com/p/1d52ed86d52c]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>匿名函数 自执行函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基本类型和引用类型的区别以及在内存中的分配]]></title>
    <url>%2F2019%2F05%2F10%2F%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%88%86%E9%85%8D%2F</url>
    <content type="text"><![CDATA[ECMAScript变量可能包含两种不同数据类型的值：基本类型值和引用类型值。基本类型值指的是简单的数据段，而引用类型值指那些可能由多个值构成的对象。 主要区别 基本数据类型 引用数据类型 &lt; 在栈中进行分配 在堆中进行分配 变量名指向具体的数值 变量名指向存数据对象的内存地址,即变量名指向hash值 变量在声明之后java就会立刻分配给他内存空间 它以特殊的方式(类似C指针)指向对象实体（具体的值），这类变量声明时不会分配内存，只是存储了一个内存地址 基本类型之间的赋值是创建新的拷贝 对象之间的赋值只是传递引用 “==”和“!=”是在比较值 “==”和“!=”是在比较两个引用是否相同，需要自己实现equals()方法 基本类型变量创建和销毁很快 类对象需要JVM去销毁 动态的属性定义基本类型值和引用类型值的方法时类似的：创建一个变量并为该变量赋值。但是对于不同类型值可以执行的操作就不一样了。 引用类型值我们可以为其添加属性和方法，也可以改变和删除其属性和方法。请看下面的例子： 123var person = new Object();person.name = "Nicholas";//添加属性并且赋值alert(person.name);//输出Nicholas 上面代码创建了一个对象并将其保存在了变量person中。然后为对象添加了一个名为name的属性并且将字符串“Nicholas”赋给了这个属性。 基本类型值我们不能给基本类型的值添加属性，尽管这样做并不会出错。例如： 123var name = "Nicholas";name.age = 27;alert(name.age); //得到：undefind 在这个例子中，我们为字符串name定义了一个名为age的属性，并且赋值27。但在下面使用alert访问这个属性的时候，发现该属性不存在。这说明基本类型不能动态的添加属性。 复制变量值除了保存方式不同之外，在从一个变量向另一个变量复制基本类型和引用类型值时，也存在不同。 基本类型值如果从一个变量向另一个变量复制基本类型的值，会在变量对象上创建一个新值。然后把改制复制到新变量分配的位置上。看一个小例子： 12var num1 = 5;var num2 = num1; 在此，num1中保存的值时5.当使用num1的值来初始化num2时，num2中也保存了值5.但num2中的5与num1中 的5 是完全独立的。该值只是num1中5的一个副本。这两个变量可以参与任何操作而不会相会影响。 引用类型值当从一个变量向另一个变量复制引用类型的值时，同样也会将存储在变量对象中的值复制一份放到为新变量分配的空间中。不同的是，这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一个对象。复制操作以后，这两个变量实际上将引用同一个对象。因此，改变其中一个变量，就会影响另一个变量。如下面的例子所示： 1234var obj1 = new object();var obj2 = obj1;obj1.name = "Nicholaa";alert(obj2.name);//输出“Nicholas” 首先，变量obj1保存了一个对象的新实例。然后，这个值被复制到了obj2中；换句话说，obj1和obj2都指向同一个对象。这样，当为obj1添加属性name后，可以通过obj2来访问这个属性，因为这两个变量引用都是同一个对象。具体关系可以看下图：参考文献：JavaScript高级程序设计（第3版）]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>基本类型和引用类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中的回调函数callback]]></title>
    <url>%2F2019%2F05%2F10%2FJavaScript%E4%B8%AD%E7%9A%84%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0callback%2F</url>
    <content type="text"><![CDATA[## 解释 A callback is a function that is passed as an argument to another function and is executed after its parent function has completed. 以上callback的英文解释，非常清晰简明，有时候英文理解要比翻译成中文二次理解更清楚。大概意思是：回调是一个函数，它作为参数传递给另一个函数，并在其父函数完成后执行。其实函数也是一种数据类型，既可以当作参数进行传递，也可以当作方法的返回值传递 先明白异步和同步想要理解清楚callback还是需要先把异步async/同步sync概念弄清楚。先写一个异步小例子： 12345678910111213141516function a()&#123; console.log('我是函数a开头') setTimeout(function () &#123; console.log('我是setTimeout') &#125;,1000) console.log('我是函数a结尾')&#125;function b()&#123; console.log('我是函数b')&#125;a()b() 执行结果： 从执行结果可以看出来执行顺序是之上而下执行下来，但setTimeout函数被放在了最后执行。这是一个异步操作，执行的时候并不会等待setTimeout而直接向下执行，等到所有任务执行完成在回过头来执行setTimeout函数。即使setTimeout第二个参数是0也会最后执行，setTimeout第二个参数的数字是表示执行最快时间不是一个确定时间。 理解&emsp;&emsp;回调函数字面上理解下来就是，回调就是一个函数的调用过程。函数a有一个参数，这个参数是个函数b，当函数a执行完以后执行函数b。那么这个过程就叫回调。字面意思也很好理解：回调，回调，就是回头调用的意思。函数a的事先干完，回头再调用函数b。&emsp;&emsp;需要注意的是：所以回调与同步、异步并没有直接的联系，回调只是一种实现方式，既可以有同步回调，也可以有异步回调，还可以有事件处理回调和延迟函数回调，这些在我们工作中有很多的使用场景&emsp;&emsp;所以其实并不是我们不认识回调函数，而是我们都萦绕在了这个“callback“ 这个词上，当你在一个函数中看到它是就会困惑，其实它只是一个形参名字而已。 回调函数其实我们平时都使用过，来看看下面几个经典的： ajax中的回调函数： 点击事件的回调函数： 数组中遍历的回调函数： 作用大多数情况下，callback是用来拿到函数中的数据，这牵扯到闭包的概念，可以看这篇文章：javaScript里的闭包到底是什么？该怎么理解？ 就以Ajax的封装为例吧： 1234567var oReq = new XMLHttpRequest() oReq.onload = function () &#123; console.log(oReq.responseText) &#125; oReq.open("get",url,true) oReq.send() 上面的是为封装的Ajax，我们请求到的数据responseText只能在onload中拿到，想要拿数据进行下一步操作也只能在onload函数中进行。但我们如果要封装给其他人使用，我们并不知道使用者需要拿这数据干什么，因此我们需要把responseText传递出去，这时候就需要使用callback。 1234567891011121314 function get(url,callback)&#123; var oReq = new XMLHttpRequest() oReq.onload = function () &#123;// console.log(oReq.responseText) callback(oReq.responseText) &#125; oReq.open("get",url,true) oReq.send() &#125; get('data.json', function (data) &#123; console.log(data) &#125;) 上面这是封装以后的代码，我们通过callback把responseText传递出去,get方法的第二个参数就是回调函数callback，而data就是callback函数传递出来的responseText数据，通过回调函数拿到数据，使用者需要拿数据干什么都行了。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>callback</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[定时调用和延时调用用法及区别]]></title>
    <url>%2F2019%2F05%2F10%2F%E5%AE%9A%E6%97%B6%E8%B0%83%E7%94%A8%E5%92%8C%E5%BB%B6%E6%97%B6%E8%B0%83%E7%94%A8%E7%94%A8%E6%B3%95%E5%8F%8A%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[定时调用setlnterval()定义和用法setInterval() 方法可按照指定的周期（以毫秒计）来调用函数或计算表达式。 setInterval() 方法会不停地调用函数，直到 clearInterval() 被调用或窗口被关闭。由 setInterval() 返回的 ID 值可用作 clearInterval() 方法的参数。 语法setInterval(code,millisec) 参数 1、code（必需）：回调函数， 每隔一段时间要执行一次的函数 2、millisec（必需）：每次调用间隔时间，单位是ms 返回值 一个可以传递给 Window.clearInterval() 从而取消对 code 的周期性执行的值。 实例 12//每隔6000毫秒执行一次testFunction()函数，执行无数次。setInterval("testFunction()","6000"); 延时调用setTimeout()定义和用法setTimeout() 方法用于在指定的毫秒数后调用函数或计算表达式。 语法setTimeout(code,millisec) 参数 1、回调函数， 需要隔一定时间后执行的函数 2、每次调用间隔时间，单位是ms 提示和注释 提示：setTimeout() 只执行 code 一次。如果要多次调用，请使用 setInterval() 或者让 code 自身再次调用 setTimeout()。 实例 12//每隔6000毫秒执行一次testFunction()函数，执行无数次。setTimeout("testFunction()","6000"); 小案例]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>定时调用和延时调用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaScript正则表达式（内附最全的常用正则表达式）]]></title>
    <url>%2F2019%2F05%2F10%2FjavaScript%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E5%86%85%E9%99%84%E6%9C%80%E5%85%A8%E7%9A%84%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[### JavaScript 正则表达式 正则表达式（英语：Regular Expression，在代码中常简写为regex、regexp或RE）使用单个字符串来描述、匹配一系列符合某个句法规则的字符串搜索模式。 搜索模式可用于文本搜索和文本替换。 什么是正则表达式？正则表达式是由一个字符序列形成的搜索模式。当你在文本中搜索数据时，你可以用搜索模式来描述你要查询的内容。正则表达式可以是一个简单的字符，或一个更复杂的模式。正则表达式可用于所有文本搜索和文本替换的操作。 语法1/pattern/modifiers; 实例1var patt = /hello/i 实例解析： /hello/i 是一个正则表达式。hello 是一个模式 (用于检索匹配关键字)。i 是一个修饰符 (搜索不区分大小写)。 使用字符串方法 在 JavaScript 中，正则表达式通常用于两个字符串方法 : search() 和 replace()。 search() 方法 用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串，并返回子字符串的起始位置。 replace() 方法 用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子字符串。 search() 方法使用使用正则表达式搜索 “make” 字符串，且不区分大小写： 123var str = "Visit make";var n = str.search(/make/i);//结果：6 search 方法可使用字符串作为参数。字符串参数会转换为正则表达式： 123var str = "Visit make";var n = str.search("make");//结果：6 replace() 方法使用使用正则表达式且不区分大小写将字符串中的 Microsoft 替换为 make : 123var str = "Visit Microsoft!";var res = str.replace(/microsoft/i, "make");//结果：Visit make! replace() 方法将接收字符串作为参数： 12var str = "Visit Microsoft!";var res = str.replace("Microsoft", "make"); 正则表达式修饰符修饰符 可以在全局搜索中不区分大小写:正则表达式模式 方括号用于查找某个范围内的字符： 常用正则表达式一、校验数字的表达式12345678910111213141516171819 1 数字：^[0-9]*$ 2 n位的数字：^\d&#123;n&#125;$ 3 至少n位的数字：^\d&#123;n,&#125;$ 4 m-n位的数字：^\d&#123;m,n&#125;$ 5 零和非零开头的数字：^(0|[1-9][0-9]*)$ 6 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]&#123;1,2&#125;)?$ 7 带1-2位小数的正数或负数：^(\-)?\d+(\.\d&#123;1,2&#125;)?$ 8 正数、负数、和小数：^(\-|\+)?\d+(\.\d+)?$ 9 有两位小数的正实数：^[0-9]+(.[0-9]&#123;2&#125;)?$10 有1~3位小数的正实数：^[0-9]+(.[0-9]&#123;1,3&#125;)?$11 非零的正整数：^[1-9]\d*$ 或 ^([1-9][0-9]*)&#123;1,3&#125;$ 或 ^\+?[1-9][0-9]*$12 非零的负整数：^\-[1-9][]0-9"*$ 或 ^-[1-9]\d*$13 非负整数：^\d+$ 或 ^[1-9]\d*|0$14 非正整数：^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$15 非负浮点数：^\d+(\.\d+)?$ 或 ^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$16 非正浮点数：^((-\d+(\.\d+)?)|(0+(\.0+)?))$ 或 ^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$17 正浮点数：^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$ 或 ^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$18 负浮点数：^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$ 或 ^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$19 浮点数：^(-?\d+)(\.\d+)?$ 或 ^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$ 二、校验字符的表达式123456789101112 1 汉字：^[\u4e00-\u9fa5]&#123;0,&#125;$ 2 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]&#123;4,40&#125;$ 3 长度为3-20的所有字符：^.&#123;3,20&#125;$ 4 由26个英文字母组成的字符串：^[A-Za-z]+$ 5 由26个大写英文字母组成的字符串：^[A-Z]+$ 6 由26个小写英文字母组成的字符串：^[a-z]+$ 7 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$ 8 由数字、26个英文字母或者下划线组成的字符串：^\w+$ 或 ^\w&#123;3,20&#125;$ 9 中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0-9_]+$10 中文、英文、数字但不包括下划线等符号：^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]&#123;2,20&#125;$11 可以输入含有^%&amp;',;=?$\"等字符：[^%&amp;',;=?$\x22]+12 禁止输入含有~的字符：[^~\x22]+ 三、特殊需求表达式1234567891011121314151617181920212223242526272829303132331 Email地址：^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$ 2 域名：[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(/.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+/.? 3 InternetURL：[a-zA-z]+://[^\s]* 或 ^http://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=]*)?$ 4 手机号码：^(13[0-9]|14[0-9]|15[0-9]|16[0-9]|17[0-9]|18[0-9]|19[0-9])\d&#123;8&#125;$ (由于工信部放号段不定时，所以建议使用泛解析 ^([1][3,4,5,6,7,8,9])\d&#123;9&#125;$) 5 电话号码("XXX-XXXXXXX"、"XXXX-XXXXXXXX"、"XXX-XXXXXXX"、"XXX-XXXXXXXX"、"XXXXXXX"和"XXXXXXXX)：^(\(\d&#123;3,4&#125;-)|\d&#123;3.4&#125;-)?\d&#123;7,8&#125;$ 6 国内电话号码(0511-4405222、021-87888822)：\d&#123;3&#125;-\d&#123;8&#125;|\d&#123;4&#125;-\d&#123;7&#125; 7 18位身份证号码(数字、字母x结尾)：^((\d&#123;18&#125;)|([0-9x]&#123;18&#125;)|([0-9X]&#123;18&#125;))$ 8 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$ 9 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w&#123;5,17&#125;$10 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).&#123;8,10&#125;$ 11 日期格式：^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;12 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$13 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ 14 钱的输入格式：15 1.有四种钱的表示形式我们可以接受:"10000.00" 和 "10,000.00", 和没有 "分" 的 "10000" 和 "10,000"：^[1-9][0-9]*$ 16 2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符"0"不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$ 17 3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ 18 4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ 19 5.必须说明的是,小数点后面至少应该有1位数,所以"10."是不通过的,但是 "10" 和 "10.2" 是通过的：^[0-9]+(.[0-9]&#123;2&#125;)?$ 20 6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]&#123;1,2&#125;)?$ 21 7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*(.[0-9]&#123;1,2&#125;)?$ 22 8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*)(.[0-9]&#123;1,2&#125;)?$ 23 备注：这就是最终结果了,别忘了"+"可以用"*"替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里24 xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$25 中文字符的正则表达式：[\u4e00-\u9fa5]26 双字节字符：[^\x00-\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))27 空白行的正则表达式：\n\s*\r (可以用来删除空白行)28 HTML标记的正则表达式：&lt;(\S*?)[^&gt;]*&gt;.*?&lt;/\1&gt;|&lt;.*? /&gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)29 首尾空白字符的正则表达式：^\s*|\s*$或(^\s*)|(\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)30 腾讯QQ号：[1-9][0-9]&#123;4,&#125; (腾讯QQ号从10000开始)31 中国邮政编码：[1-9]\d&#123;5&#125;(?!\d) (中国邮政编码为6位数字)32 IP地址：\d+\.\d+\.\d+\.\d+ (提取IP地址时有用)33 IP地址：((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.)&#123;3&#125;(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)) 参考文章：https://www.w3cschool.cn/javascript/js-regexp.htmlhttp://www.cnblogs.com/zxin/archive/2013/01/26/2877765.html]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaScript里的闭包到底是什么？该怎么理解？]]></title>
    <url>%2F2019%2F05%2F10%2FjavaScript%E9%87%8C%E7%9A%84%E9%97%AD%E5%8C%85%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E8%AF%A5%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[关于javaScript里的闭包问题，看了很多答案都不甚理解，在这里我谈谈我理解里的闭包。在理解闭包是什么之前我需要先理解什么是作用域。 全局作用域打开一个 js ，随便写了一行代码，这行代码所在的位置就会是全局作用域（global scope）。比如： 1var i =1;//全局作用域在代码任何位置都可以使用，一篇代码只有一个全局作用域 局部作用域全局作用域只有一个，在全局使用域里面定义的其它的作用域都被称为局部作用域（local scope）。局部作用域是由函数创建的，每个函数都会创建一个局部作用域。 123456789// 作用域 A: 全局作用域（位于函数外部）var nameA = "全局作用域"var a = function() &#123; // 作用域 B：局部作用域(在函数内部) // 这里是的局部作用域是由函数a创建的 var nameB = '局部作用域'&#125; 在这个局部作用域里面定义的东西，在这个作用域的外面是访问不到的。试一下： 12345678var nameA = "全局作用域"var a = function() &#123; var nameB = '局部作用域'&#125;console.log(nameA)// 返回：全局作用域console.log(nameB)//返回：undefined 闭包了解了作用域接下来我讲一讲闭包 定义维基百科：在计算机科学中，闭包（Closure），是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。所以，有另一种说法认为闭包是由函数和与其相关的引用环境组合而成的实体。 上面的定义看的有点懵，那我说说我的看法：在我看来，不是说能够访问到其他作用域的变量就是闭包，这是很笼统的。准确来说，闭包是基于正常的垃圾回收处理机制下的。也就是说，一般情况一个函数（函数作用域）执行完毕，里面声明的变量会全部释放，被垃圾回收器回收。但闭包利用一个技巧，让作用域里面的变量，在函数执行完之后依旧保存没有被垃圾回收处理掉。 还是有点懵？那贴上一段代码来看看： 12345678function fn(x) &#123; var a = 3; return function (y) &#123; alert(x + y + (++a)); &#125;&#125;var bar = fn(2); // bar 现在是一个闭包bar(10); 我们来看看这段代码，我们声明了一个函数fn，在到var bar = fn(2)开始执行函fn(2)，由于只传入一个参数2，所以执行到return function(y)这一行代码会停下等参数y传入，但是这个时候我们想想a变量和参数回收了吗？其实并没有，因为return function(y)这一行代码还未执行，还在等待参数y传入。f n的变量并没有被释放，在return在等待继续使用这些变量了，这个时候bar就是一个闭包。这时候在看看维基百科的解释是不是有些明白了？ 闭包的缺点 1 因为闭包的变量保存在内存中，内存泄漏，对内存的消耗很大，所以不要滥用闭包 闭包常用的地方： 1 es5 for循环事件监听 2 函数里使用了定时器 3 封装许多高级的功能集减少闭包使用可以用立即执行函数传递变量 参考：https://www.cnblogs.com/JIANGCHEN520/p/7118656.html]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[for和for in的区别]]></title>
    <url>%2F2019%2F05%2F10%2Ffor%E4%B8%8Efor%20in%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[从学习C语言开始就学习了遍历，for更是用的特别熟悉。在javascript中除了有for循环还有for in，刚开始接触for in的时候总是把他当for来使用。感觉没什么区别然而在最近写项目时遇到了这个for in才知悉了他与for的不同，果然还是实践出真知。下面先简单介绍一下for 和 for in吧： for的语法结构：1234567 for( 初始值;判断条件;步幅)&#123; code &#125; for( var i =0;i&lt;5;i++ )&#123; //i初始值为0；i是否小写5；每次循环后i加1 console.log(i);// 0 1 2 3 4 &#125; for in的写法：12345678910111213 var man = &#123; age:21, name:"张三", sex:"男"&#125;console.log(man);//结果：Object age: 21 name: "张三" sex: "男" __proto__: Object 1234for(var attr in man)&#123;//attr是属性，attr可以换成任意变量名 console.log(attr);// 输出的是 属性名：age name sex console.log(wq[attr]);//属性相对应的值 20 咸鱼 男&#125; 看到这里我相信有些人已经看明白了。不过我还是多嘴说一下吧，上面的for循环就是我们常用的方法用来遍历,十分简单的操作。而下面的for in呢？他一般时用来遍历对象的，在我的理解看来，for 循环可以遍历一个数组属于一维，而for in遍历对象，对象有多个属性，各个属性又有各自 的值相当于二位数组了。在上面的案例里面，想要获取对象的属性相应的值for是遍历不了的，这个时候for in就出场了。但使用for in的时候还要注意几个小问题： 而for in就不同了，上面的案例中，对象wq里有三个属性和相对应的值，想要获取到这三个属性及相对应的值for是办不到的，只有for in才可以，所以说，for in一般都是用在遍历对象的，另外，for in也可以遍历数组，但是会存在以下几个问题。 1、 for in这种循环i是string类型的，不能直接进行几何运算2、遍历顺序有可能不是按照实际数组的内部顺序3、使用for in会遍历数组所有的可枚举属性，包括原型。例如上栗的原型方法method和name属性4、简而言之，for-in是为普通对象设计的，你可以遍历得到字符串类型的键，因此不适用于数组遍历。 所以说for in也有他的局限性，因此遍历一般的数组用for比较好，遍历对象就需要for in了 最后附上一个小案例]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>for in</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax发送get_post请求的基本格式模板以及验证用户是否存在案例]]></title>
    <url>%2F2019%2F05%2F10%2FAjax%E5%8F%91%E9%80%81get_post%E8%AF%B7%E6%B1%82%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A0%BC%E5%BC%8F%E6%A8%A1%E6%9D%BF%E4%BB%A5%E5%8F%8A%E9%AA%8C%E8%AF%81%E7%94%A8%E6%88%B7%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E6%A1%88%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[Ajax发送get/post请求主要分为以下4步： 1.创建对象1var xhr = new XMLHttpRequest(); 2.设置请求行//（get请求数据写在url后面）open(&apos;method&apos;,&apos;url&apos;,&apos;async&apos;); /*method:请求的类型：GET或POST * url:文件在服务器上的位置 * async:true(异步)或false(同步),默认true * */ xhr.open(&apos;get&apos;,&apos;getData.php&apos;，true); 3.设置请求头//（get请求可以省略，post不发数据也可以省略） xhr.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;); 4.请求主体发送12//get请求为空，或者写null，post请求数据写在这里，如果没有数据，直接为空或者写null xhr.send(null); 为了方便理解，下面我贴一个验证用户是否存在的小案例： 前端部分代码12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;用户注册&lt;/h2&gt; &lt;input type="text" placeholder="请输入用户名"&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt; //什么时候发送请求？onblur:失去焦点 document.querySelector('input').onblur = function()&#123; //1.创建对象 var xhr = new XMLHttpRequest(); //2.设置请求行 xhr.open('get','checkName.php?name='+this.value); //3.设置请求头（此处用get请求可以省略） // xhr.setRequestHeader(); //这里是设置回调函数 xhr.onload = function () &#123; document.querySelector('h2').innerHTML = xhr.responseText;//呈现给用户看 &#125; //4.请求主体发送（get请求为空，或者写null） xhr.send(null); &#125;&lt;/script&gt; 后端部分代码12345678910111213&lt;?php//获取数据$name = $_GET['name'];//用数组模拟数据库$nameArr = array('jack','rose','nike');//在数据库中查询数据，in_array（要查询的数据名，在哪个数据库查询）$result = in_array($name,$nameArr);if($result == true)&#123; echo '很遗憾，已被使用';&#125;else&#123; echo '恭喜你，可以使用';&#125;?&gt; 查询前查询rose(数据库中存在)查询Tom(数据库中不存在)]]></content>
      <categories>
        <category>Ajax</category>
      </categories>
      <tags>
        <tag>_get_post</tag>
      </tags>
  </entry>
</search>
