<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[python文件读取read()、readline()、readlines()]]></title>
    <url>%2F2019%2F11%2F20%2Fpython%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96read()%E3%80%81readline()%E3%80%81readlines()%2F</url>
    <content type="text"><![CDATA[## read() 优点是：读取整个文件，将文件内容放到一个字符串变量中。 缺点是：如果文件非常大，尤其是大于内存时，无法使用read()方法。 示例：pi_digits.txt文件： 1233.141592653589793238462643383279 1234filename = 'pi_digits.txt'with open(filename) as file: file1 = file.read() print(file.rstrip())//#rstrip() 删除 string 字符串末尾的指定字符（默认为空格）. 结果： readline() 优点：readline()方法每次读取一行；返回的是一个字符串对象，保持当前行的内存 缺点：读取速度较慢 示例： 12345678910filename = 'pi_digits.txt'with open(filename) as file:# 循环读取每一行，需要读取三次 while True: text_line = file.readline() if text_line: file3 = text_line print(file3.rstrip()) else: break 结果： readlines() 特点：一次性读取整个文件；自动将文件内容分析成一个行的列表。 示例： 1234567filename = 'pi_digits.txt'with open(filename) as file: file3 = file.readlines() print(file3) #从列表中循环读取出每一行 for line in file3: print(line.rstrip()) 结果：]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python文件读取read()、readline()、readlines()</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python字符串方法]]></title>
    <url>%2F2019%2F11%2F16%2Fpython%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[## python大小写处理方法 字符串首字母大写：title() 字符串全字母大写：upper() 字符串全字母小写：lower() 1234name = "ada LOVE"print(name.title())print(name.upper())print(name.lower()) 结果： 拼接字符串使用+拼接字符串 1234first_name = "ada"last_name = "love"full_name = first_name + last_nameprint(full_name) //输出:adalove 制表符和换行符 制表符：\t 换行符：\n 123print("Languages:\nPython\nC\nJavaScript")print("-------------------------------------------------")print("Languages:\n\tPython\n\tC\n\tJavaScript") 结果： rstrip(),lstrip(),strip()删除指定位置字符rstrip()rstrip() 方法用于截掉字符串右边的空格或指定字符。语法：str.rstrip([chars])chars – 指定删除的字符（默认为空格） 1234str = " this is string example....wow!!! ";print str.rstrip();str = "88888888this is string example....wow!!!8888888";print str.rstrip('8'); 默认删除空格，但是删除空格此处显示不明显，第二个例子删除·8·会比较明显 结果： lstriplstrip() 方法用于截掉字符串左边的空格或指定字符。 stripstrip() 方法用于截掉字符串两端 的空格或指定字符。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>ppython字符串方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个例子弄懂事件冒泡和事件捕获]]></title>
    <url>%2F2019%2F10%2F28%2F%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90%E5%BC%84%E6%87%82%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E5%92%8C%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7%2F</url>
    <content type="text"><![CDATA[先看一张图先看这张图，然后我们用例子来理解。 事件冒泡事件按照从最特定的事件目标到最不特定的事件目标(document对象)的顺序触发。事件冒泡会从当前触发的事件目标一级一级往上传递，依次触发，直到document为止。 事件冒泡例子层级关系：body&gt;div&gt;p 给body，div,p分别绑定点击事件，console.log()出body,div,p;123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html lang="zh"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;事件冒泡&lt;/title&gt; &lt;style&gt; body&#123; background-color: red; &#125; div &#123; width: 500px; height: 500px; background-color: aqua; &#125; p &#123; width: 100px; height: 100px; background-color: royalblue; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function()&#123; document.getElementById('body').addEventListener('click',body,false) document.getElementById('div').addEventListener('click',div,false) document.getElementById('p').addEventListener('click',p,false) function body() &#123; console.log('body') &#125; function div() &#123; console.log('body') &#125; function p() &#123; console.log('p') &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body id="body"&gt; &lt;div id="div"&gt; &lt;p id="p"&gt;&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 点击p时打印结果如下：由结果可以看出：事件冒泡会从当前触发的事件目标一级一级往上传递，依次触发，直到document为止。 事件捕获捕获型事件(event capturing)：事件从最不精确的对象(document 对象)开始触发，然后到最精确(也可以在窗口级别捕获事件，不过必须由开发人员特别指定)事件捕获会从document开始触发，一级一级往下传递，依次触发，直到真正事件目标为止。 这时将addEventListener的第三个参数改为true 再次点击： 123document.getElementById('body').addEventListener('click',body,true)document.getElementById('div').addEventListener('click',div,true)document.getElementById('p').addEventListener('click',p,true) 结果如图：由此可以得出：事件捕获会从document开始触发，一级一级往下传递，依次触发，直到真正事件目标为止。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>事件冒泡和事件捕获</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6新语法]]></title>
    <url>%2F2019%2F10%2F22%2FES6%E6%96%B0%E8%AF%AD%E6%B3%95%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[# ES6新语法 hello-es6 1.ES6怎么来的 2.ES6兼容性 3.变量 let 和 常量 const 4.函数-箭头函数 5.函数-参数 6.解构赋值 7.数组 8.字符串 9.面向对象-基础 10.面向对象应用 11.json 12.Promise 13.generator-认识生成器函数 14.generator-yield是啥 15.generator-实例 16.ES7 预览 1.ES6怎么来的 ECMAScript 和 JavaScript ECMA 是标准，JS 是实现 ECMAScript 简称 ECMA 或 ES 历史版本 1996, ES1.0 Netscape 将 JS 提交给 ECMA 组织，ES 正式出现 1999, ES3.0 被广泛支持 2011, ES5.1 成为 ISO 国际标准 2015, ES6.0 正式发布 2.ES6兼容性 ES6(ES2015) 支持的环境 IE10+, Chrome, FireFox, 移动端, NodeJS 解决不兼容办法，编译、转换 在线转换 或者提前编译 Babel 中文网 Babel 入门教程 阮一峰 Babel 是一个 JavaScript 编译器 一个广泛使用的转码器，可以将ES6代码转为ES5代码，从而在现有环境执行 现在就用 ES6 编写程序，而不用担心现有环境是否支持 3.变量 let 和 常量 const var 的问题 可以重复声明，没有报错和警告 无法限制修改 没有块级作用域， { } let 和 const 不能重复声明 都是块级作用域, { } 块内声明的，块外无效 let 是变量，可以修改 const 是常量，不能修改 块级作用域举例 原来用 var 的方式，结果弹出的都是 3 或者将变量 封装到函数里，限制作用域，但比较麻烦 用 let 最简单，直接 var 改 let，解决作用域问题 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; window.onload= function () &#123; /* var aBtn = document.getElementsByTagName('input') for (var i=0; i &lt; aBtn.length; i++) &#123; aBtn[i].onclick = function () &#123; alert(i) &#125; &#125;*/ var aBtn = document.getElementsByTagName('input') for (let i = 0; i &lt; aBtn.length; i++) &#123; aBtn[i].onclick = function () &#123; alert(i) &#125; &#125; /* var aBtn = document.getElementsByTagName('input') for (var i = 0; i &lt; aBtn.length; i++) &#123; // 封装到函数里，限制作用域 (function (i) &#123; aBtn[i].onclick = function () &#123; alert(i) &#125; &#125;)(i) &#125;*/ &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="button" value="按钮1"&gt; &lt;input type="button" value="按钮2"&gt; &lt;input type="button" value="按钮3"&gt;&lt;/body&gt;&lt;/html&gt; 4.函数-箭头函数 箭头函数，就是函数的简写 如果只有一个参数，() 可以省 如果只有一个return，{}可以省 12345678// 普通函数function name() &#123;&#125;// 箭头函数，去掉 function， 加上 =&gt;() =&gt; &#123;&#125; 12345678910111213141516171819let show1 = function () &#123; console.log('abc')&#125;let show2 = () =&gt; &#123; console.log('abc')&#125;show1() // 调用函数show2()let show4 = function (a) &#123; return a*2&#125;let show5 = a =&gt; a * 2 //简洁，类似python lambda 函数console.log(show4(10))console.log(show5(10)) 5.函数-参数 参数扩展／展开 ...args 收集剩余的参数，必须当到最后一个参数位置 展开数组，简写，效果和直接把数组的内容写在这儿一样 默认参数 12345678910111213141516function show(a, b, ...args) &#123; console.log(a) console.log(b) console.log(args)&#125;console.log(show(1, 2, 3, 4, 5))let arr1 = [1, 2, 3]let arr2 = [4, 5, 6]let arr3 = [...arr1, ...arr2]console.log(arr3)function show2(a, b=5, c=8) &#123; console.log(a, b, c)&#125;show2(88, 12) 6.解构赋值12345678let [a, b, c] = [1, 2, 3]console.log(a, b, c)let &#123;x, y, z&#125; = &#123;x: 1, y: 2, z: 3&#125;console.log(x, y, z)let [json, arr, num, str] = [&#123; a: 1, b: 2 &#125;, [1, 2, 3], 8, 'str']console.log(json, arr, num, str) 解构赋值 左右两个边结构必须一样 右边必须是个东西 声明和赋值赋值不能分开，必须在一句话里 7.数组 新增4个方法 map 映射 一个对一个 12345678910111213141516let arr = [12, 5, 8]let result = arr.map(function (item) &#123; return item*2&#125;)let result2 = arr.map(item=&gt;item*2) // 简写console.log(result)console.log(result2)let score = [18, 86, 88, 24]let result3 = score.map(item =&gt; item &gt;= 60 ? '及格' : '不及格')console.log(result3)// 结果[ 24, 10, 16 ][ 24, 10, 16 ][ '不及格', '及格', '及格', '不及格' ] reduce 汇总 一堆出来一个 用于比如，算个总数，算个平均 1234567891011121314151617var arr = [1, 3, 5, 7]var result = arr.reduce(function (tmp, item, index) &#123; //tmp 上次结果，item当前数，index次数1开始 console.log(tmp, item, index) return tmp + item&#125;)console.log(result)var arr = [1, 3, 5, 7]var result = arr.reduce(function (tmp, item, index) &#123; if (index != arr.length - 1) &#123; // 不是最后一次 return tmp + item &#125; else &#123; return (tmp + item)/arr.length &#125;&#125;)console.log(result) // 平均值 filter 过滤器 保留为true的 123456789101112var arr = [12, 4, 8, 9]var result = arr.filter(item =&gt; (item % 3 === 0) ? true : false)console.log(result)var result = arr.filter(item =&gt; item % 3 === 0)console.log(result)var arr = [ &#123; title: '苹果', price: 10 &#125;, &#123; title: '西瓜', price: 20 &#125;,]var result = arr.filter(json =&gt; json.price &gt;= 20)console.log(result) forEach 循环迭代 123var arr = [12, 4, 8, 9]var result = arr.forEach(item =&gt; console.log(item))var result = arr.forEach((item, index)=&gt;console.log(item, index)) 8.字符串 多了两个新方法 startsWith endsWith 1234var url = 'http://qq.com'console.log(url.startsWith('http'))console.log(url.endsWith('com'))// 都是 true 字符串模版 使用反引号，${变量} 可以折行 1234567891011121314let a = 12let str1 = `asdf$&#123;a&#125;`console.log(str1)let title = '标题'let content = '内容'let str = `&lt;div&gt;&lt;h1&gt;$&#123;title&#125;&lt;/h1&gt;&lt;p&gt;$&#123;content&#125;&lt;/p&gt;`console.log(str)&lt;div&gt;&lt;h1&gt;标题&lt;/h1&gt;&lt;p&gt;内容&lt;/p&gt; 9.面向对象-基础 原来写法 类和构造函数一样 属性和方法分开写的 123456789101112131415161718192021222324252627282930// 老版本function User(name, pass) &#123; this.name = name this.pass = pass&#125;User.prototype.showName = function () &#123; console.log(this.name)&#125;User.prototype.showPass = function () &#123; console.log(this.pass)&#125;var u1 = new User('able', '1233')u1.showName()u1.showPass()// 老版本继承function VipUser(name, pass, level) &#123; User.call(this, name, pass) this.level = level&#125;VipUser.prototype = new User()VipUser.prototype.constructor = VipUserVipUser.prototype.showLevel = function () &#123; console.log(this.level)&#125;var v1 = new VipUser('blue', '1234', 3)v1.showName()v1.showLevel() 新版面向对象 有了 class 关键字、构造器 class 里面直接加方法 继承，super 超类==父类 12345678910111213141516171819202122232425262728293031class User &#123; constructor(name, pass) &#123; this.name = name this.pass = pass &#125; showName() &#123; console.log(this.name) &#125; showPass() &#123; console.log(this.pass) &#125;&#125;var u1 = new User('able2', '111')u1.showName()u1.showPass()// 新版本继承class VipUser extends User &#123; constructor(name, pass, level) &#123; super(name, pass) this.level = level &#125; showLevel()&#123; console.log(this.level) &#125;&#125;v1 = new VipUser('blue', '123', 3)v1.showLevel() 10.面向对象应用 React 用于构建用户界面的 JavaScript 库 组件化，一个组件就是一个 class JSX == bable == browser.js 11.json JSON 格式 JavaScript Object Notation 的缩写，是一种用于数据交换的文本格式 JSON 是 JS对象 的严格子集 JSON 的标准写法 只能用双引号 所有的key都必须用双引号包起来 JSON 对象 JSON 对象是 JavaScript 的原生对象，用来处理 JSON 格式数据，有两个静态方法 JSON.parse(string) ：接受一个 JSON 字符串并将其转换成一个 JavaScript 对象。 JSON.stringify(obj) ：接受一个 JavaScript 对象并将其转换为一个 JSON 字符串。 123456789101112var json = &#123;a: 12, b: 5&#125;var str = 'hi,' + JSON.stringify(json)var url = 'http://www.xx.com/' + encodeURIComponent(JSON.stringify(json))console.log(str)console.log(url)var str = '&#123;"a": 12, "b": 4, "c": "abc"&#125;'var json = JSON.parse(str)console.log(json)hi,&#123;"a":12,"b":5&#125;http://www.xx.com/%7B%22a%22%3A12%2C%22b%22%3A5%7D&#123; a: 12, b: 4, c: 'abc' &#125; 对象（object） 是 JavaScript 语言的核心概念，也是最重要的数据类型 对象就是一组“键值对”（key-value）的集合，是一种无序的复合数据集合 对象的所有键名都是字符串, 所以加不加引号都可以 如果键名是数值，会被自动转为字符串 对象的每一个键名又称为“属性”（property），它的“键值”可以是任何数据类型 如果一个属性的值为函数，通常把这个属性称为“方法”，它可以像函数那样调用 in 运算符用于检查对象是否包含某个属性（注意，检查的是键名，不是键值 for…in循环用来遍历一个对象的全部属性 对象 简写 key-value 一样时可以简写 里面函数可以简写, 去掉 123456789var a = 12, b = 5console.log(&#123;a:a, b:b&#125;)console.log(&#123;a, b&#125;)console.log(&#123;a, b, c:"c"&#125;)console.log(&#123; a, b, show()&#123; console.log('a') &#125;&#125;)&#123; a: 12, b: 5 &#125;&#123; a: 12, b: 5 &#125;&#123; a: 12, b: 5, c: 'c' &#125;&#123; a: 12, b: 5, show: [Function: show] &#125; 12.Promise 异步和同步 异步，操作之间没有关系，同时执行多个操作， 代码复杂 同步，同时只能做一件事，代码简单 Promise 对象 用同步的方式来书写异步代码 Promise 让异步操作写起来，像在写同步操作的流程，不必一层层地嵌套回调函数 改善了可读性，对于多层嵌套的回调函数很方便 充当异步操作与回调函数之间的中介，使得异步操作具备同步操作的接口 Promise 也是一个构造函数 接受一个回调函数f1作为参数，f1里面是异步操作的代码 返回的p1就是一个 Promise 实例 所有异步任务都返回一个 Promise 实例 Promise 实例有一个then方法，用来指定下一步的回调函数 12345function f1(resolve, reject) &#123; // 异步代码...&#125;var p1 = new Promise(f1);p1.then(f2); // f1的异步操作执行完成，就会执行f2。 Promise 使得异步流程可以写成同步流程 12345678910111213141516// 传统写法step1(function (value1) &#123; step2(value1, function(value2) &#123; step3(value2, function(value3) &#123; step4(value3, function(value4) &#123; // ... &#125;); &#125;); &#125;);&#125;);// Promise 的写法(new Promise(step1)) .then(step2) .then(step3) .then(step4); Promise.all(promiseArray)方法 将多个Promise对象实例包装，生成并返回一个新的Promise实例 promise数组中所有的promise实例都变为resolve的时候，该方法才会返回 并将所有结果传递results数组中 promise数组中任何一个promise为reject的话，则整个Promise.all调用会立即终止，并返回一个reject的新的promise对象 123456var p1 = Promise.resolve(1), p2 = Promise.resolve(2), p3 = Promise.resolve(3);Promise.all([p1, p2, p3]).then(function (results) &#123; console.log(results); // [1, 2, 3]&#125;); Promise.race([p1, p2, p3]) Promse.race就是赛跑的意思 哪个结果获得的快，就返回那个结果 不管结果本身是成功状态还是失败状态 13.generator-认识生成器函数 generator 生成器函数 普通函数，一路到底 generator函数，中间可以停，到哪停呢，用 yield 配合，交出执行权 yield 有 放弃、退让、退位的意思 需要调用next()方法启动执行，需要遇到 yield 停, 踹一脚走一步 generator函数前面加一个 * 两边可以有空格，或靠近函数或function 背后实际生成多个小函数，实现走走停停 123456789101112131415function show() &#123; console.log('a') console.log('b')&#125;show() // 普通函数function *show2() &#123; console.log('1') yield console.log('2')&#125;let genObj = show2()genObj.next() // 1genObj.next() // 2genObj.next() // 最后了，没有结果 14.generator-yield是啥 yield 既可传参，又可以返回 第一个next()传参无效，只用来启动 如果函数前漏掉 * 就是普通函数 如果有yield会报错， ReferenceError: yield is not defined yield 只能在Generator函数内部使用 1234567891011121314151617181920212223242526function * show() &#123; console.log('1') var a = yield console.log('2') console.log(a)&#125;// yield 传参var gen = show()gen.next() // 1gen.next() // 2 和 undefined 因为没有传参，yield没有返回值var gen = show()gen.next(10) // 1 第一次执行到yield，但没有执行赋值gen.next(20) // 2 和 20function* show2() &#123; console.log('1') yield 10 console.log('2')&#125;// yield 返回var gen = show2()var res1 = gen.next()console.log(res1) // &#123; value: 10, done: false &#125;var res2 = gen.next()console.log(res2)// &#123; value: undefined, done: true &#125; 最后的value需要return返回 15.generator-实例 Promise 适合一次读一组 generator 适合逻辑性的 12345678910// 带逻辑-generatorrunner(function * () &#123; let userData = yield $.ajax(&#123;url: 'getUserData'&#125;) if (userData.type == 'VIP') &#123; let items = yield $.ajax(&#123;url: 'getVIPItems'&#125;) &#125; else &#123; let items = yield $.ajax(&#123;url: 'getItems'&#125;) &#125;&#125;) 12345// yield 实例，用同步方式写异步server.use(function * () &#123; let data = yield db.query(`select * from user_table`) this.body = data&#125;) 16.ES7 预览 数组 arr.includes() 数组是否包含某个东西 数组的 arr.keys(), arr,entries() for … in 遍历数组 下标 key for … of 遍历数组 值 value, 不能用于json 123456789101112131415161718192021let arr = ['a', 'b', 'c']console.log(arr.includes(1))for (let i in arr) &#123; console.log(i) // 循环的时下标 key&#125;for (let i of arr) &#123; console.log(i) // 循环的是值 value&#125;for (let i of arr.keys()) &#123; console.log('&gt;'+i)&#125;for (let [key, value] of arr.entries()) &#123; console.log('&gt;' + key + value)&#125;let json = &#123; a: 12, b: 5, c: 7 &#125;for (let i in json) &#123; console.log(i)&#125; 字符串 padStart()/padEnd() 指定宽度，不够就补空格或指定字符 1234console.log('=' + 'abcd'.padStart(6, '0') + '=')console.log('=' + 'abcd'.padEnd(6, '0') + '=')=00abcd==abcd00= 容忍度 [1, 2, 3,] 老版数组最后不能有逗号，新的可以有 函数参数最后多的逗号也可以 async await 和 generator yield 类似 generator 不可以写成箭头函数， async 可以 12345async function show() &#123; console.log(1) await console.log(2)&#125;]]></content>
      <categories>
        <category>es6</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS数组所有方法（ES5和ES6）]]></title>
    <url>%2F2019%2F10%2F13%2FJS%E6%95%B0%E7%BB%84%E6%89%80%E6%9C%89%E6%96%B9%E6%B3%95%EF%BC%88ES5%E5%92%8CES6%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1 arr.push() 从后面添加元素，返回值为添加完后的数组的长度 123let arr = [1,2,3,4,5]console.log(arr.push(5)) // 6console.log(arr) // [1,2,3,4,5,5] 2 arr.pop() 从后面删除元素，只能是一个，返回值是删除的元素 123let arr = [1,2,3,4,5]console.log(arr.pop()) // 5console.log(arr) //[1,2,3,4] 3 arr.shift() 从前面删除元素，只能删除一个 返回值是删除的元素 123let arr = [1,2,3,4,5]console.log(arr.shift()) // 1console.log(arr) // [2,3,4,5] 4 arr.unshift() 从前面添加元素, 返回值是添加完后的数组的长度 123let arr = [1,2,3,4,5]console.log(arr.unshift(2)) // 6console.log(arr) //[2,1,2,3,4,5] 5 arr.splice(i,n) 删除从i(索引值)开始之后的那个元素。返回值是删除的元素 参数： i 索引值 n 个数 123let arr = [1,2,3,4,5]console.log(arr.splice(2,2)) //[3,4]console.log(arr) // [1,2,5] 6 arr.concat() 连接两个数组 返回值为连接后的新数组 123let arr = [1,2,3,4,5]console.log(arr.concat([1,2])) // [1,2,3,4,5,1,2]console.log(arr) // [1,2,3,4,5] 7 str.split() 将字符串转化为数组 12let str = '123456'console.log(str.split('')) // ["1", "2", "3", "4", "5", "6"] 8 arr.sort() 将数组进行排序,返回值是排好的数组，默认是按照最左边的数字进行排序，不是按照数字大小排序的，见例子。 123456let arr = [2,10,6,1,4,22,3]console.log(arr.sort()) // [1, 10, 2, 22, 3, 4, 6]let arr1 = arr.sort((a, b) =&gt;a - b) console.log(arr1) // [1, 2, 3, 4, 6, 10, 22]let arr2 = arr.sort((a, b) =&gt;b-a) console.log(arr2) // [22, 10, 6, 4, 3, 2, 1] 9 arr.reverse() 将数组反转,返回值是反转后的数组 123let arr = [1,2,3,4,5]console.log(arr.reverse()) // [5,4,3,2,1]console.log(arr) // [5,4,3,2,1] 10 arr.slice(start,end) 切去索引值start到索引值end的数组，不包含end索引的值，返回值是切出来的数组 123let arr = [1,2,3,4,5]console.log(arr.slice(1,3)) // [2,3]console.log(arr) // [1,2,3,4,5] 11 arr.forEach(callback) 遍历数组,无return callback的参数： value –当前索引的值 index –索引 array –原数组 12345678910111213141516171819202122let arr = [1,2,3,4,5]arr.forEach( (value,index,array)=&gt;&#123; console.log(`value:$&#123;value&#125; index:$&#123;index&#125; array:$&#123;array&#125;`) &#125;) // value:1 index:0 array:1,2,3,4,5 // value:2 index:1 array:1,2,3,4,5 // value:3 index:2 array:1,2,3,4,5 // value:4 index:3 array:1,2,3,4,5 // value:5 index:4 array:1,2,3,4,5let arr = [1,2,3,4,5]arr.forEach( (value,index,array)=&gt;&#123; value = value * 2 console.log(`value:$&#123;value&#125; index:$&#123;index&#125; array:$&#123;array&#125;`) &#125;) console.log(arr) // value:2 index:0 array:1,2,3,4,5 // value:4 index:1 array:1,2,3,4,5 // value:6 index:2 array:1,2,3,4,5 // value:8 index:3 array:1,2,3,4,5 // value:10 index:4 array:1,2,3,4,5 // [1, 2, 3, 4, 5] 12 arr.map(callback) 映射数组(遍历数组),有return 返回一个新数组 callback的参数： value –当前索引的值 index –索引 array –原数组 123456let arr = [1,2,3,4,5]arr.map( (value,index,array)=&gt;&#123; value = value * 2 console.log(`value:$&#123;value&#125; index:$&#123;index&#125; array:$&#123;array&#125;`)&#125;) console.log(arr) ps: arr.forEach()和arr.map()的区别 1. arr.forEach()是和for循环一样，是代替for。arr.map()是修改数组其中的数据，并返回新的数据。 2. arr.forEach() 没有return arr.map() 有return 13 arr.filter(callback) 过滤数组，返回一个满足要求的数组 123let arr = [1,2,3,4,5]let arr1 = arr.filter( (i, v) =&gt; i &lt; 3)console.log(arr1) // [1, 2] 14 arr.every(callback) 依据判断条件，数组的元素是否全满足，若满足则返回ture 12345let arr = [1,2,3,4,5]let arr1 = arr.every( (i, v) =&gt; i &lt; 3)console.log(arr1) // falselet arr2 = arr.every( (i, v) =&gt; i &lt; 10)console.log(arr2) // true 15 arr.some() 依据判断条件，数组的元素是否有一个满足，若有一个满足则返回ture 12345let arr = [1,2,3,4,5]let arr1 = arr.some( (i, v) =&gt; i &lt; 3)console.log(arr1) // truelet arr2 = arr.some( (i, v) =&gt; i &gt; 10)console.log(arr2) // false 16 arr.reduce(callback, initialValue) 迭代数组的所有项，累加器，数组中的每个值（从左到右）合并，最终计算为一个值 参数： callback: previousValue 必选 –上一次调用回调返回的值，或者是提供的初始值（initialValue） currentValue 必选 –数组中当前被处理的数组项 index 可选 –当前数组项在数组中的索引值 array 可选 –原数组 initialValue: 可选 –初始值实行方法：回调函数第一次执行时，preValue 和 curValue 可以是一个值，如果 initialValue 在调用 reduce() 时被提供，那么第一个 preValue 等于 initialValue ，并且curValue 等于数组中的第一个值；如果initialValue 未被提供，那么preValue 等于数组中的第一个值. 123456789let arr = [0,1,2,3,4]let arr1 = arr.reduce((preValue, curValue) =&gt; preValue + curValue)console.log(arr1) // 10let arr2 = arr.reduce((preValue,curValue)=&gt;preValue + curValue,5)console.log(arr2) // 15 17 arr.reduceRight(callback, initialValue) 与arr.reduce()功能一样，不同的是，reduceRight()从数组的末尾向前将数组中的数组项做累加。 实行方法：reduceRight()首次调用回调函数callbackfn时，prevValue 和 curValue 可以是两个值之一。如果调用 reduceRight() 时提供了 initialValue 参数，则 prevValue 等于 initialValue，curValue 等于数组中的最后一个值。如果没有提供 initialValue 参数，则 prevValue 等于数组最后一个值， curValue 等于数组中倒数第二个值。 12345let arr = [0,1,2,3,4]let arr1 = arr.reduceRight((preValue, curValue) =&gt; preValue + curValue)console.log(arr1) // 10 12let arr2 = arr.reduceRight((preValue,curValue)=&gt;preValue + curValue,5)console.log(arr2) // 15 ps：(如果对这两个方法不明白，可以查看大漠老师的实例 http://www.w3cplus.com/javascript/array-part-8.html) 18 arr.indexOf() 查找某个元素的索引值，若有重复的，则返回第一个查到的索引值若不存在，则返回 -1 12345let arr = [1,2,3,4,5,2]let arr1 = arr.indexOf(2)console.log(arr1) // 1let arr2 = arr.indexOf(9)console.log(arr2) // -1 19 arr.lastIndexOf() 和arr.indexOf()的功能一样，不同的是从后往前查找 12345let arr = [1,2,3,4,5,2]let arr1 = arr.lastIndexOf(2)console.log(arr1) // 5let arr2 = arr.lastIndexOf(9)console.log(arr2) // -1 20 Array.from() 将伪数组变成数组，就是只要有length的就可以转成数组。 —es6 1234let str = '12345'console.log(Array.from(str)) // ["1", "2", "3", "4", "5"]let obj = &#123;0:'a',1:'b',length:2&#125;console.log(Array.from(obj)) // ["a", "b"] 21 Array.of() 将一组值转换成数组，类似于声明数组 —es6 12345let str = '11'console.log(Array.of(str)) // ['11']等价于console.log(new Array('11')) // ['11] ps:但是new Array()有缺点，就是参数问题引起的重载console.log(new Array(2)) //[empty × 2] 是个空数组console.log(Array.of(2)) // [2] 22 arr.copyWithin() 在当前数组内部，将制定位置的数组复制到其他位置，会覆盖原数组项，返回当前数组 参数: target –必选 索引从该位置开始替换数组项 start –可选 索引从该位置开始读取数组项，默认为0.如果为负值，则从右往左读。 end –可选 索引到该位置停止读取的数组项，默认是Array.length,如果是负值，表示倒数 1234567let arr = [1,2,3,4,5,6,7]let arr1 = arr.copyWithin(1)console.log(arr1) // [1, 1, 2, 3, 4, 5, 6]let arr2 = arr.copyWithin(1,2)console.log(arr2) // [1, 3, 4, 5, 6, 7, 7]let arr3 = arr.copyWithin(1,2,4)console.log(arr3) // [1, 3, 4, 4, 5, 6, 7] 23 arr.find(callback) 找到第一个符合条件的数组成员 123let arr = [1,2,3,4,5,2,4]let arr1 = arr.find((value, index, array) =&gt;value &gt; 2)console.log(arr1) // 3 24 arr.findIndex(callback) 找到第一个符合条件的数组成员的索引值 123let arr = [1,2,3,4,5]let arr1 = arr.findIndex((value, index, array) =&gt; value &gt; 3)console.log(arr1) // 3 25 arr.fill(target, start, end) 使用给定的值，填充一个数组,ps:填充完后会改变原数组 参数： target – 待填充的元素 start – 开始填充的位置-索引 end – 终止填充的位置-索引（不包括该位置) 12345678let arr = [1,2,3,4,5]let arr1 = arr.fill(5)console.log(arr1) // [5, 5, 5, 5, 5]console.log(arr) // [5, 5, 5, 5, 5]let arr2 = arr.fill(5,2)console.log(arr2)let arr3 = arr.fill(5,1,3)console.log(arr3) 26 arr.includes() 判断数中是否包含给定的值 1234567let arr = [1,2,3,4,5]let arr1 = arr.includes(2) console.log(arr1) // turelet arr2 = arr.includes(9) console.log(arr2) // falselet arr3 = [1,2,3,NaN].includes(NaN)console.log(arr3) // true ps:与indexOf()的区别：1 indexOf()返回的是数值，而includes()返回的是布尔值2 indexOf() 不能判断NaN，返回为-1 ，includes()则可以判断27 arr.keys() 遍历数组的键名let arr = [1,2,3,4]let arr2 = arr.keys()for (let key of arr2) { console.log(key); // 0,1,2,3} 28 arr.values() 遍历数组键值 12345let arr = [1,2,3,4]let arr1 = arr.values()for (let val of arr1) &#123; console.log(val); // 1,2,3,4&#125; 29 arr.entries() 遍历数组的键名和键值 12345let arr = [1,2,3,4]let arr1 = arr.entries()for (let e of arr1) &#123; console.log(e); // [0,1] [1,2] [2,3] [3,4]&#125; entries() 方法返回迭代数组。 迭代数组中每个值 前一个是索引值作为 key， 数组后一个值作为 value。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>JS数组所有方法（ES5和ES6）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jianshu-react项目总结]]></title>
    <url>%2F2019%2F10%2F04%2Fjianshu-react%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[## 目录 技术栈 项目结构及技术点介绍 项目结构 styled components 使用iconfont嵌入图标 使用react-transition-group动画库 使用react-redux及其中间件 等等。。。 项目代码和性能优化 this绑定的性能优化 合理使用无状态组件 Immutable.js与redux结合使用 避免无意义的网络请求 异步操作代码拆分优化 使用PureComponent 技术栈： react + redux + redux-thunk（让redux支持异步的中间件） + webpack + react-router + ES6/7/8 + axios + react-transition-group（react动画库）+ react-loadable（使组件按需载） + styled-components（css组件化） + immutable.js 运行打包（nodejs 6.0+）：123456789git clone https://github.com/CoderZF/jianshu-pc.gitcd jianshu-pcnpm i 或者运行 yarn(推荐) npm startnpm run build （发布） 项目结构及技术点介绍：该项目由 Create React App 搭建. 项目结构：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263jianshu-pc│ README.md│ package.json└───src│ │ App.js│ │ idnex.js│ │ style.js│ └───common│ │ └───header│ │ │ index.js│ │ │ style.js│ │ └───store │ │ │ actionCreators.js│ │ │ constants.js │ │ │ index.js │ │ │ reducer.js │ └───pages│ │ └───detail│ │ │ │ index.js│ │ │ │ style.js│ │ │ │ loadable.js│ │ │ └───store │ │ │ │ actionCreators.js│ │ │ │ constants.js │ │ │ │ index.js │ │ │ │ reducer.js │ │ └───home│ │ │ │ index.js│ │ │ │ style.js│ │ │ └───store │ │ │ │ actionCreators.js│ │ │ │ constants.js │ │ │ │ index.js │ │ │ │ reducer.js │ │ │ └───components │ │ │ │ List.js│ │ │ │ Recommend.js │ │ │ │ Topic.js │ │ │ │ Writer.js │ │ └───login│ │ │ │ index.js│ │ │ │ style.js│ │ │ └───store │ │ │ │ actionCreators.js│ │ │ │ constants.js │ │ │ │ index.js │ │ │ │ reducer.js │ │ └───write│ │ │ │ index.js│ │ │ │ style.js│ └───statics│ │ │ logo.png│ │ │ ...│ │ └───iconfont│ │ │ iconfont.eot│ │ │ iconfont.js│ │ │ ...│ └───store│ │ │ index.js│ │ │ reducer.js│ └───public │ ... styled components：使用styled components，可将组件分为逻辑组件和展示组件，逻辑组件只关注逻辑相关的部分，展示组件只关注样式。通过解耦成两种组件，可以使代码变得更加清晰可维护。当逻辑有变化，如后台拉取的数据的格式有所变化时，只需关注并修改逻辑组件上的代码，展示组件的代码不用动。而当UI需要变化时，只需改变展示组件上的代码，并保证展示组件暴露的props接口不变即可。逻辑组件和展示组件各司其职，修改代码时错误发生率也会有所减少。12345678910111213141516171819202122232425import &#123; injectGlobal &#125; from 'styled-components';injectGlobal` html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video &#123; margin: 0; padding: 0; border: 0; font-size: 100%; font: inherit; vertical-align: baseline; &#125; ...` 上面js可以看出全局公用样式使用injectGlobal，所有css写在字符串模板中，vscode下载vscode-styled-components插件可支持语法高亮。 123456789101112 import styled from "styled-components"; export const RecommendWrapper = styled.div` margin: 30px 0; width: 280px;`; export const RecommendItem = styled.div` width: 280px; height: 50px; background: url($&#123;props =&gt; props.imgUrl&#125;); background-size: contain;`; 123456789101112131415import &#123; RecommendWrapper, RecommendItem &#125; from '../style';class Recommend extends PureComponent &#123; render() &#123; return ( &lt;RecommendWrapper&gt; &#123; this.props.list.map((item) =&gt; &#123; return &lt;RecommendItem imgUrl=&#123;item.get('imgUrl')&#125; key=&#123;item.get('id')&#125;/&gt; &#125;) &#125; &lt;/RecommendWrapper&gt; ) &#125;&#125; 上面2个js就是styled components最常用的使用方法，将视图和逻辑彻底分离。 使用iconfont嵌入图标[外链图片转存失败(img-E4M00HYU-1568882130487)(https://upload-images.jianshu.io/upload_images/1517219-ce2bf5c272f293f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)][外链图片转存失败(img-u7nNWtY2-1568882130489)(https://upload-images.jianshu.io/upload_images/1517219-4ea045f8f4ef401e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)] 动画库的使用 react-transition-group是react官方提供的动画库，也是之前两个的合体版本，此动画库总共提供三个组件Transition，CSSTransition和TransitonGroup。本项目为实现输入框在聚焦和失去焦点时其长度的变化，使用了CSSTransition这个组件。 1234567&lt;CSSTransition in=&#123;focused&#125; timeout=&#123;200&#125; classNames="slide"&gt; &lt;NavSearch className=&#123;focused ? "focused" : ""&#125; onFocus=&#123;() =&gt; handleInputFocus(list)&#125; onBlur=&#123;handleInputBlur&#125; /&gt;&lt;/CSSTransition&gt; 12345678910111213141516171819202122232425262728293031323334 export const NavSearch = styled.input.attrs(&#123; placeholder: "搜索" &#125;)` width: 160px; height: 38px; padding: 0 30px 0 20px; margin-top: 9px; margin-left: 20px; box-sizing: border-box; border: none; outline: none; border-radius: 19px; background: #eee; font-size: 14px; color: #666; &amp;::placeholder &#123; color: #999; &#125; &amp;.focused &#123; width: 240px; &#125; &amp;.slide-enter &#123; transition: all 0.2s ease-out; &#125; &amp;.slide-enter-active &#123; width: 240px; &#125; &amp;.slide-exit &#123; transition: all 0.2s ease-out; &#125; &amp;.slide-exit-active &#123; width: 160px; &#125;`; CSSTransition包装的组件会给其组件自动包装不同状态的类名，如上slide-enter，slide-enter-active，slide-exit，slide-exit-active 就是其根据classNames-xxx自动挂载的。 使用react-redux及其中间件 首先为根组件用react-redux提供的Provider包裹，其目的就是让整个项目的组件可以使用store。1234567891011121314151617class App extends Component &#123; render() &#123; return ( &lt;Provider store=&#123;store&#125;&gt; &lt;BrowserRouter&gt; &lt;div&gt; &lt;Header /&gt; &lt;Route path='/' exact component=&#123;Home&#125;&gt;&lt;/Route&gt; &lt;Route path='/login' exact component=&#123;Login&#125;&gt;&lt;/Route&gt; &lt;Route path='/write' exact component=&#123;Write&#125;&gt;&lt;/Route&gt; &lt;Route path='/detail/:id' exact component=&#123;Detail&#125;&gt;&lt;/Route&gt; &lt;/div&gt; &lt;/BrowserRouter&gt; &lt;/Provider&gt; ); &#125;&#125; 然后让组件通过connect连接store，connect第一次调用的两个参数分别是store和dispatch对其组件props的映射回调函数12345678910import &#123; connect &#125; from "react-redux";...class Header extends Component &#123; ...&#125;...export default connect( mapStateToProps, mapDispathToProps)(Header); 代码和性能优化：this绑定优化 当使用bind()绑定时，最好把所有需要绑定的方法都放在构造函数constructor中，这样就仅需要绑定一次就可以，避免每次渲染时都要重新绑定，函数在别处复用时也无需再次绑定。 12345678910111213141516171819import React, &#123;Component&#125; from 'react'class Test extends React.Component &#123; constructor (props) &#123; super(props) this.handleClick = this.handleClick.bind(this) &#125; handleClick (e) &#123; &#125; render () &#123; return ( &lt;div&gt; &lt;button onClick=&#123; this.handleClick &#125;&gt;Say Hello&lt;/button&gt; &lt;/div&gt; ) &#125;&#125; 箭头函数则会捕获其所在上下文的this值，作为自己的this值，使用箭头函数就不用担心函数内的this不是指向组件内部了。可以按下面这种方式使用箭头函数： 123456789101112131415161718class Test extends React.Component &#123; constructor (props) &#123; super(props) this.state = &#123;message: 'Allo!'&#125; &#125; handleClick (e) &#123; console.log(this.state.message) &#125; render () &#123; return ( &lt;div&gt; &lt;button onClick=&#123; ()=&gt;&#123; this.handleClick() &#125; &#125;&gt;Say Hello&lt;/button&gt; &lt;/div&gt; ) &#125;&#125; 使用这个语法有个问题就是每次 Test 渲染的时候都会创建一个不同的回调函数。在大多数情况下，这没有问题。然而如果这个回调函数作为一个属性值传入低阶组件，这些组件可能会进行额外的重新渲染。我们通常建议在构造函数中绑定或像下面代码使用属性初始化器语法来避免这类性能问题。123456789101112131415161718class Test extends React.Component &#123; constructor (props) &#123; super(props) this.state = &#123;message: 'Allo!'&#125; &#125; handleClick = (e) =&gt; &#123; console.log(this.state.message) &#125; render () &#123; return ( &lt;div&gt; &lt;button onClick=&#123; this.handleClick &#125;&gt;Say Hello&lt;/button&gt; &lt;/div&gt; ) &#125;&#125; 使用无状态组件提高性能如此组件没有状态的影响或者仅仅纯静态展示时，完全可以用无状态组件来替代有状态组件，因其除render无任何其他生命周期方法且仅仅返回的是个函数，无实例化过程，大大提升了性能。12345678910111213import React, &#123; PureComponent &#125; from 'react';import &#123; WriterWrapper &#125; from '../style';class Writer extends PureComponent &#123; render() &#123; return ( &lt;WriterWrapper&gt;HomeWork&lt;/WriterWrapper&gt; ) &#125;&#125;export default Writer; 上面组件就可以完全改装成如下无状态组件。123456import React, &#123; PureComponent &#125; from "react";import &#123; WriterWrapper &#125; from "../style";const Writer = () =&gt; &lt;WriterWrapper&gt;HomeWork&lt;/WriterWrapper&gt;;export default Writer; immutable.js与redux结合使用当我们对一个Immutable对象进行操作的时候，ImmutableJS基于哈希映射树(hash map tries)和vector map tries，只clone该节点以及它的祖先节点，其他保持不变，这样可以共享相同的部分，大大提高性能。在对Immutable对象的操作均会返回新的对象，所以使用redux的reducer中就不需要总是想着不能修改原state，因为对Immutable对象的操作返回就是新的对象，且比普通js深拷贝产生的性能消耗要低得多。 我在项目中也是大量使用immutable.js1234567891011121314151617181920212223242526272829303132import * as constants from './constants';import &#123; fromJS &#125; from 'immutable';const defaultState = fromJS(&#123; focused: false, mouseIn: false, list: [], page: 1, totalPage: 1&#125;);export default (state = defaultState, action) =&gt; &#123; switch(action.type) &#123; case constants.SEARCH_FOCUS: return state.set('focused', true); case constants.SEARCH_BLUR: return state.set('focused', false); case constants.CHANGE_LIST: return state.merge(&#123; list: action.data, totalPage: action.totalPage &#125;); case constants.MOUSE_ENTER: return state.set('mouseIn', true); case constants.MOUSE_LEAVE: return state.set('mouseIn', false); case constants.CHANGE_PAGE: return state.set('page', action.page); default: return state; &#125;&#125; 12345678910111213141516171819import * as constants from './constants';import &#123; fromJS &#125; from 'immutable';import axios from 'axios';const changeList = (data) =&gt; (&#123; type: constants.CHANGE_LIST, data: fromJS(data), totalPage: Math.ceil(data.length / 10)&#125;);export const getList = () =&gt; &#123; return (dispatch) =&gt; &#123; axios.get('/api/headerList.json').then((res) =&gt; &#123; const data = res.data; dispatch(changeList(data.data)); &#125;).catch(() =&gt; &#123; console.log('error'); &#125;) &#125;&#125;; 避免无意义的网络请求比如在请求热门搜索提示项的时候，只有当size是0的时候我才去发送请求。12345678const mapDispathToProps = dispatch =&gt; &#123;return &#123; handleInputFocus(list) &#123; list.size === 0 &amp;&amp; dispatch(actionCreators.getList()); dispatch(actionCreators.searchFocus()); &#125;,... &#125;; 异步操作代码拆分优化在UI组件中因尽量减少业务逻辑操作，像与服务器交互的大量代码都应该解耦出来，所以结合redux-thunk的使用将大量的网络请求代码写在action中就解决了这一问题。下面是home页的actionCreators.js，当前模块的所有action和网络请求都在此文件中123456789101112131415161718192021222324252627282930313233343536373839import axios from 'axios';import * as constants from './constants';import &#123; fromJS &#125; from 'immutable';const changHomeData = (result) =&gt; (&#123; type: constants.CHANGE_HOME_DATA, topicList: result.topicList, articleList: result.articleList, recommendList: result.recommendList&#125;);const addHomeList = (list, nextPage) =&gt; (&#123; type: constants.ADD_ARTICLE_LIST, list: fromJS(list), nextPage&#125;)export const getHomeInfo = () =&gt; &#123; return (dispatch) =&gt; &#123; axios.get('/api/home.json').then((res) =&gt; &#123; const result = res.data.data; dispatch(changHomeData(result)); &#125;); &#125;&#125;export const getMoreList = (page) =&gt; &#123; return (dispatch) =&gt; &#123; axios.get('/api/homeList.json?page=' + page).then((res) =&gt; &#123; const result = res.data.data; dispatch(addHomeList(result, page + 1)); &#125;); &#125;&#125;export const toggleTopShow = (show) =&gt; (&#123; type: constants.TOGGLE_SCROLL_TOP, show&#125;) 这样在组件中就可以轻松的去调用网络请求，然后将返回结果发送给reducer进行处理1234567891011121314151617181920212223242526272829303132333435363738394041424344import React, &#123; PureComponent &#125; from 'react';import &#123; ListItem, ListInfo, LoadMore &#125; from '../style';import &#123; connect &#125; from 'react-redux';import &#123; actionCreators &#125; from '../store';import &#123; Link &#125; from 'react-router-dom';class List extends PureComponent &#123; render() &#123; const &#123; list, getMoreList, page &#125; = this.props; return ( &lt;div&gt; &#123; list.map((item, index) =&gt; &#123; return ( &lt;Link key=&#123;index&#125; to=&#123;'/detail/' + item.get('id')&#125;&gt; &lt;ListItem &gt; &lt;img alt='' className='pic' src=&#123;item.get('imgUrl')&#125; /&gt; &lt;ListInfo&gt; &lt;h3 className='title'&gt;&#123;item.get('title')&#125;&lt;/h3&gt; &lt;p className='desc'&gt;&#123;item.get('desc')&#125;&lt;/p&gt; &lt;/ListInfo&gt; &lt;/ListItem&gt; &lt;/Link&gt; ); &#125;) &#125; &lt;LoadMore onClick=&#123;() =&gt; getMoreList(page)&#125;&gt;更多文字&lt;/LoadMore&gt; &lt;/div&gt; ) &#125;&#125;const mapState = (state) =&gt; (&#123; list: state.getIn(['home', 'articleList']), page: state.getIn(['home', 'articlePage'])&#125;);const mapDispatch = (dispatch) =&gt; (&#123; getMoreList(page) &#123; dispatch(actionCreators.getMoreList(page)) &#125;&#125;)export default connect(mapState, mapDispatch)(List); 使用PureComponent继承Component的普通组件，使用react-redux的connect连接了store，那么只要store内的数据发生改变就会让所有连接的组件触发render，这样就会产生不必要的渲染开销，当然使用shouldComponentUpdate也可以阻止不必要的渲染，但这样的话每个组件都要写同样的shouldComponentUpdate方法；继承PureComponent的组件正好解决了这一痛点，默认实现的shouldComponentUpdate。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>项目总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于React中使用bind(this)的理解]]></title>
    <url>%2F2019%2F09%2F26%2F%E5%85%B3%E4%BA%8EReact%E4%B8%AD%E4%BD%BF%E7%94%A8bind(this)%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[## 前言 在学习React的过程中发现调用函数的时候必须使用bind(this)，之后直接在class中声明函数即可正常使用，但是为什么要使用这个呢？在这里总结一下。 1.JavaScript自身特性说明如果传递一个函数名给一个变量，之后通过函数名()的方式进行调用，在方法内部如果使用this则this的指向会丢失。 示例代码： 首先我们创建test对象并直接调用方法 ： 1234567const test = &#123; name:'jack', getName:function()&#123; console.log(this.name) &#125;&#125;test.getName() 使用node test.js执行上述代码可以正常输出jack。 之后，我们对代码进行调整： 12345678const test = &#123; name:'jack', getJack:function()&#123; console.log(this.name) &#125;&#125;const func = test.getJack;func(); 我们没有直接调用对象的方法，而是将方法声明给一个中间变量，之后利用中间变量()调用方法，此时this则失去指向，输出undefined，如果使用node环境执行js文件则输出node相关信息，如嵌入到html中则this指向window对象。 2.React事件绑定React中的bind同上方原理一致,在JSX中传递的事件不是一个字符串，而是一个函数（如:onClick={this.handleClick}），此时onClick即是中间变量，所以处理函数中的this指向会丢失。解决这个问题就是给调用函数时bind(this)，从而使得无论事件处理函数如何传递，this指向都是当前实例化对象。 当然，如果不想使用bind(this)，我们可以在声明函数时使用箭头函数将函数内容返回给一个变量，并在调用时直接使用this.变量名即可。示例代码如下： 123456789101112131415161718192021222324252627282930313233343536import React from 'react';export default class Life extends React.Component&#123; constructor(props)&#123; super(props); this.state = &#123; count:4 &#125;; &#125; render()&#123; var style = &#123; padding:'10px', color:'red', fontSize:'30px' &#125; return ( &lt;div style=&#123;style&#125;&gt;&#123;/*注意js语法使用一个括号&#123;&#125;去表示,style使用两个括号,原因里面其实是一个对象*/&#125; &lt;p&gt;React生命周期介绍&lt;/p&gt; &lt;button onClick=&#123;this.handleAdd&#125;&gt;无bind点击一下&lt;/button&gt; &lt;button onClick=&#123;this.handleClick.bind(this)&#125;&gt;有bind点击一下&lt;/button&gt; &lt;p&gt;&#123;this.state.count&#125;&lt;/p&gt; &lt;/div&gt; ) &#125; //此时this指向是当前实例对象 handleAdd = ()=&gt; &#123; console.log(this) this.setState(&#123; count:5 &#125;) &#125; handleClick()&#123; this.setState(&#123; count:6 &#125;) &#125;&#125; 总结普通函数中，内层函数不能从外层函数中继承this的值，在内层函数中，this会是window或者undefined（取决于是否使用严格模式），可以设置一个临时变量用来将外部的this值导入到内部函数中，再一个方法就是在内部函数执行.bind(this)。而箭头函数的this是继承父级的this。因此在React中要注意，在一个方法中调用this.setState()等函数，或者在render()方法中被调用，都有内层函数参与，因此需要将该方法的this绑定到class。所以如果是用function的普通方法定义，需要在constructor中bind(this)，如：this.onChange = this.onChange.bind(this);这样this指向组件实例，就可以在render()中使用，也可以在方法中调用this.setState()方法了。或者直接用箭头函数进行定义。这样，this就继承自父级方法render(), 而render()的this为组件实例。这样一来，在render()中就可以愉快的使用了： 12345render() &#123;return(&lt;input onChange=&#123;this.onChange&#125;&gt;);&#125; 不建议在render()中bind，如：，因为它会在每次render()方法执行时绑定类方法，肯定对于性能有影响。而直接在constructor中bind, 则bind只会在组件实例化初时运行一次。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>bind(this)</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试题：如何画一条0.5px的线]]></title>
    <url>%2F2019%2F09%2F24%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E5%A6%82%E4%BD%95%E7%94%BB%E4%B8%80%E6%9D%A10.5px%E7%9A%84%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[## 前言 理论上1px已经是最小单位了，那如何画一条0.5px的线呢？有以下两种方法 解决方法 采用meta viewport的方式 1&lt;meta name="viewport" content="width=device-width, initial-scale=0.5, minimum-scale=0.5, maximum-scale=0.5"/&gt; 这样子就能缩放到原来的0.5倍，如果是1px那么就会变成0.5px 要记得viewport只针对于移动端，只在移动端上才能看到效果 采用transform: scale()的方式 1transform: scale(0.5,0.5);]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>如何画一条0.5px的线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里前端笔试：请编写一个JavaScript 函数toRGB，它的作用是转换CSS中常用的颜色编码]]></title>
    <url>%2F2019%2F09%2F23%2F%E9%98%BF%E9%87%8C%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AF%95%EF%BC%9A%E8%AF%B7%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AAJavaScript%20%E5%87%BD%E6%95%B0toRGB%EF%BC%8C%E5%AE%83%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E8%BD%AC%E6%8D%A2CSS%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E9%A2%9C%E8%89%B2%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[## 题目 请编写一个JavaScript 函数toRGB，它的作用是转换CSS中常用的颜色编码。 要求： 123alert(toRGB("#0000FF")); // 输出 rgb(0, 0, 255)alert(toRGB("invalid")); // 输出 invalidalert(toRGB("#G00")); // 输出 #G00 解答12345678var color = "#0000FF"function toRGB(color)&#123; var regex = /^#([0-9a-fA-F]&#123;2&#125;)([0-9a-fA-F]&#123;2&#125;)([0-9a-fA-F]&#123;2&#125;)$/; var match = color.match(regex); return match ? 'rgb(' + parseInt(match[1] ,16) + ',' + parseInt(match[2] ,16) + ',' + parseInt(match[3] ,16) + ')' : color &#125;toRGB(color)]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试题：作用域]]></title>
    <url>%2F2019%2F09%2F21%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[题目代码如下:求运行出的结果 123456789101112131415161718&lt;script type="text/javascript"&gt; var num1 = 55; var num2 = 66; function f1(num,num1) &#123; num = 100; num1 = 100; num2 = 100; console.log(num); console.log(num1); console.log(num2); &#125; f1(num1,num2); console.log(num1); console.log(num2); console.log(num);&lt;/script&gt; 分析代码： 123456789101112131415161718192021222324//代码首先声明了num1,num2,函数f1，接着调用f1 &lt;script type="text/javascript"&gt; var num1 = 55; var num2 = 66; //=&gt;var num2 = 100 function f1(num,num1) &#123; //传入num,num1相当于在函数中定义了num,num1； // var num = 55;=&gt;100 // var num1 = 66;=&gt;100 num = 100;//将函数中num改为100 num1 = 100;//将函数中num1改为100 num2 = 100;//函数中找不到num2，则找到全局定义的num2改为100 console.log(num);//函数内num 100 console.log(num1);//函数内num1 100 console.log(num2);//函数内num2 100 &#125; f1(num1,num2); // 函数内的是局部作用域调用不到，所以下面打印出来的是全局作用域里的 console.log(num1);//55 console.log(num2);//全局的被修改为100，所以这里打印出来的也是100 console.log(num);//全局作用域里没有这个，找不到报错 &lt;/script&gt; 结果：]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈和堆的区别 栈和堆的区别]]></title>
    <url>%2F2019%2F09%2F20%2F%E6%A0%88%E5%92%8C%E5%A0%86%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[### 一、程序的内存分配方式不同 栈区（stack）：编译器自动分配释放，存放函数的参数值，局部变量的值等，其操作方式类似于数据结构的栈。 堆区（heap）：一般是由程序员分配释放，若程序员不释放的话，程序结束时可能由OS回收，值得注意的是他与数据结构的堆是两回事，分配方式倒是类似于数据结构的链表。二、申请方式不同 stack 由系统自动分配，heap 需要程序员自己申请。 C 中用函数 malloc分配空间，用 free 释放，C++用 new 分配，用 delete 释放。三、申请后系统的响应不同 栈：只要栈的剩余空间大于所申请的空间，系统将为程序提供内存，否则将报异常提示栈溢出。 堆：首先应该知道操作系统有一个记录内存地址的链表，当系统收到程序的申请时，遍历该链表，寻找第一个空间大于所申请的空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样代码中的 delete 或 free 语句就能够正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会将多余的那部分重新放入空闲链表中。四、 申请的大小限制不同 栈：在 windows 下，栈是向低地址扩展的数据结构，是一块连续的内存区域，栈顶的地址和栈的最大容量是系统预先规定好的，能从栈获得的空间较小。 堆：堆是向高地址扩展的数据结构，是不连续的内存区域，这是由于系统是由链表在存储空闲内存地址，自然堆就是不连续的内存区域，且链表的遍历也是从低地址向高地址遍历的，堆得大小受限于计算机系统的有效虚拟内存空间，由此空间，堆获得的空间比较灵活，也比较大。五、申请的效率不同 栈：栈由系统自动分配，速度快，但是程序员无法控制。 堆：堆是有程序员自己分配，速度较慢，容易产生碎片，不过用起来方便。六、堆和栈的存储内容不同 栈：在函数调用时，第一个进栈的是主函数中函数调用后的下一条指令的地址，然后函数的各个参数，在大多数的 C 编译器中，参数是从右往左入栈的，当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令。 堆：一般是在堆的头部用一个字节存放堆的大小，具体内容由程序员安排。]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[前端面试题：封装函数进行字符串驼峰命名的转换]]></title>
    <url>%2F2019%2F09%2F17%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E5%B0%81%E8%A3%85%E5%87%BD%E6%95%B0%E8%BF%9B%E8%A1%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%A9%BC%E5%B3%B0%E5%91%BD%E5%90%8D%E7%9A%84%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[## 题目：封装函数进行字符串驼峰命名的转换 解：代码如下： 12345678910111213141516&lt;script type="text/javascript"&gt; function toString(foo) &#123; var foo = foo; var arr = foo.split('-'); for (var i = 1;i&lt;arr.length;i++) &#123; arr[i] = arr[i].charAt(0).toUpperCase() + arr[i].substr(1,arr[length-1]) &#125; return(arr.join('')) &#125; console.log(toString( "get-element-by-id")) //结果：getElementById&lt;/script&gt; 补充：split() 方法用于把一个字符串分割成字符串数组。charAt() 方法可返回指定位置的字符。toUpperCase() 方法用于把字符串转换为大写。substr() 方法可在字符串中抽取从 start 下标开始的指定数目的字符。]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React项目--如何mock数据？]]></title>
    <url>%2F2019%2F09%2F15%2FReact%E9%A1%B9%E7%9B%AE--%E5%A6%82%E4%BD%95mock%E6%95%B0%E6%8D%AE%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[## 前言 在开发项目时，前端需要和后端对接数据，但有时后端并没有写好数据，前端还需要继续往下开发，这时候就需要mock数据了。 如何mock数据？如下代码，在input获得焦点时调用getList()方法。1234567const mapDispathToProps = (dispatch) =&gt; &#123; return &#123; handleInputFocus() &#123; dispatch(actionCreators.getList()) &#125; &#125;&#125; getList()方法是通过Ajax获取数据，此时后端并没有写好，所以自己mock一个数据。12345678910export const getList = () =&gt; &#123; return (dispatch) =&gt; &#123; axios.get('/api/headerList.json').then((res) =&gt; &#123; const data = res.data; console.log(data) &#125;).catch(() =&gt; &#123; console.log('error') &#125;) &#125;&#125; axios.get(&#39;/api/headerList.json&#39;)这句代码，计算机会首先去src目录下寻找/api/headerList.json,没有找到然后去public目录下找，此时我们在public目录下建立/api/headerList.json文件，文件如下： 1234&#123; "success":true, "data":["微信","支付宝","蚂蚁金服","被骗","借呗","诈骗","盗窃","pandas","TensorFlow","PyTorch","Caffe","scikit-learn","Python","Keras","pyecharts","ggplot","Matplotlib","Gensim","Bokeh","Theano","Scrapy","SciPy","Plotly","NumPy","XGBoost","是","他","有","光大永明","我","要","人","Android","女","大","不","着","男","它","二","于","中","java","把","上","这","下","的","了","来"]&#125; 此时返回的数据就是以上数据，通过console.log(res.data)打印数据如下图： 这样mock数据就成功了。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>mock数据</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试题：值类型和引用类型的传递]]></title>
    <url>%2F2019%2F09%2F13%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BC%A0%E9%80%92%2F</url>
    <content type="text"><![CDATA[题目如下： 1234567891011121314151617&lt;script type="text/javascript"&gt; function Person(name,age,salary) &#123; this.name = name; this.age = age; this.salary = salary; &#125; function f1(person) &#123; person.name = "ls"; person = new Person("aa",18,10); &#125; var p = new Person("zs",18,1000); console.log(p.name); f1(p); console.log(p.name)&lt;/script&gt; 分析代码：首先定义了一个构造函数Person，然后定义了一个普通函数f1，var p = new Person(&quot;zs&quot;,18,1000);这句话new了一个对象，所以第一个打印出来的是：zs;f1(p);这句话把p这个对象传入f1，person.name = &quot;ls&quot;;把p的name属性改为”ls”,person = new Person(&quot;aa&quot;,18,10);这句话重新new了一个对象，并且把person指向到了这个新的对象上，但这对p没有影响，所以最后打印出来的是”ls” 画图说明： 结果：]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redux的工作流程以及subscribe的作用]]></title>
    <url>%2F2019%2F09%2F03%2Fredux%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E4%BB%A5%E5%8F%8Asubscribe%E7%9A%84%E4%BD%9C%E7%94%A8%2F</url>
    <content type="text"><![CDATA[## redux的工作流程 使用函数createStore创建store数据点 123456789import &#123; createStore &#125; from 'redux';import reducer from './reducer'const store = createStore( reducer, window.__REDUX_DEVTOOLS_EXTENSION__ &amp;&amp; window.__REDUX_DEVTOOLS_EXTENSION__() );export default store; 创建Reducer。它要改变的组件，它获取state和action，生成新的state 1234567891011121314151617181920212223242526import &#123; CHANGE_INPUT_VALUE,ADD_TODO_ITEM,DELETE_TODO_ITEM &#125; from './actionTpyes'const defaultState = &#123; inputValue:'', list: []&#125;// reducer 可以接收state，但是绝不能修改stateexport default (state = defaultState,action) =&gt; &#123; if(action.type === CHANGE_INPUT_VALUE) &#123; const newState = JSON.parse(JSON.stringify(state)); newState.inputValue = action.value; return newState &#125; if(action.type === ADD_TODO_ITEM) &#123; const newState = JSON.parse(JSON.stringify(state)); newState.list.push(newState.inputValue); newState.inputValue = '' return newState &#125; if(action.type === DELETE_TODO_ITEM) &#123; const newState = JSON.parse(JSON.stringify(state)); newState.list.splice(action.index,1) return newState &#125; return state;&#125; 用subscribe监听每次修改情况 1234constructor(props) &#123; super(props); store.subscribe(this.handleStoreChange)&#125; dispatch执行，reducer(currentState,action)处理当前dispatch后的传入的action.type并返回给currentState处理后的state，通过currentListeners.forEach(v=&gt;v())执行监听函数，并最后返回当前 action状态 1234567handleItemDelete(index) &#123; const action = &#123; type: DELETE_TODO_ITEM, index &#125; store.dispatch(action)&#125; subscribe的作用subscribe 这个函数是用来去订阅 store 的变化，比如你每次对 store 进行 dispatch(action) 都会触发 subscribe 注册的函数调用，这个在实际情况不是必须要的，看自己的应用场景，比如你想监控 store 的全局变化时 可以用 subscript 订阅一下，然后作一些反应 每次通过dispatch 修改数据的时候，其实只是数据发生了变化，如果不手动调用 render方法，页面上的内容是不会发生变化的。 但是每次dispatch之后都手动调用很麻烦啊，所以就使用了发布订阅模式，监听数据变化来自动渲染。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>redux的工作流程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一张图理清React中的生命周期]]></title>
    <url>%2F2019%2F08%2F24%2F%E4%B8%80%E5%BC%A0%E5%9B%BE%E7%90%86%E6%B8%85React%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[生命周期函数是指在某一时刻组件会自动调用执行的函数。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>生命周期</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用vue-cli脚手架开发APP的步骤]]></title>
    <url>%2F2019%2F08%2F09%2F%E7%94%A8vue-cli%E8%84%9A%E6%89%8B%E6%9E%B6%E5%BC%80%E5%8F%91APP%E7%9A%84%E6%AD%A5%E9%AA%A4%2F</url>
    <content type="text"><![CDATA[## 前言 本文主要记录vue-cli脚手架开发app的步骤，如果还未安装vue-cli的请查看vue-cli官方文档有详细过程。 项目地址：vue-cli-demo 效果点击链接实现界面跳转，下方底部可以改成导航栏，中间内容自己修改。 步骤1.创建模板运行以下命令来创建一个新项目(项目名自己随意)： 1vue create test3 你会被提示选取一个 preset。你可以选默认的包含了基本的 Babel + ESLint 设置的 preset，也可以选“手动选择特性”来选取需要的特性。这里直接回车即可。等待下载，下载完会看到看到如下图所示，根据提示，cd hello-world进入目录，然后npm run serve启动启动好，默认8080端口，用浏览器打开网址，就可以看到vue-cli的模板启动成功 2.删除无用文件用编辑器打开项目文件，看到目录结构如下：src/assets下面图片就是打开页面的logo图片没用可以连带着assets目录一起删除。 src/components下面有一个HelloWorld.vue文件就是刚才浏览器打开的页面可以删除。 src下面的App.vue文件修改如下：只留下简单框架，内容都删了public/index.html修改如下：也只留下简单模板然后浏览器页面一片空白，可以开始写代码 3.写代码components下面随意写几个页面，目录结构如下：然后实现路由跳转使用vue-router,首先npm install vue-router --save安装在src下建src/router/router.js文件管理路由，注册路由然后在src下面的main.js里面引用，并且挂载最后一步，修改App.vue文件只是加了一行代码，router-view 可以当做是一个容器，它渲染的组件是你使用 vue-router 指定的。]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>用vue-cli脚手架开发APP的步骤</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Img标签绑定_src不显示图片]]></title>
    <url>%2F2019%2F08%2F08%2F%E5%85%B3%E4%BA%8EImg%E6%A0%87%E7%AD%BE%E7%BB%91%E5%AE%9A_src%E4%B8%8D%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[## 问题 如下图所示动态绑定src，不显示图片，将路径换成网络图片地址又可以显示 解决方法引用本地图片需要加上require，使用require定义之后，就可以动态使用了，不用require你就只能写死的。不用 :src=”‘../img/image.jpg’” 会被解析为字符串]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>关于Img标签绑定</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[轮播插件vue-awesome-swiper的使用方法]]></title>
    <url>%2F2019%2F08%2F04%2F%E8%BD%AE%E6%92%AD%E6%8F%92%E4%BB%B6vue-awesome-swiper%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[## 前言 在使用vue框架写项目时，轮播图是经常需要用到的，在这里推荐一款vue的轮播图插件vue-awesome-swiper。支持多种样式，点击样式预览。贴上地址：vue-awesome-swiper 安装引用 npm install vue-awesome-swiper --save 在main.js文件中引入，和vue-router使用差不多1234567import Vue from 'vue'import VueAwesomeSwiper from 'vue-awesome-swiper'// require stylesimport 'swiper/dist/css/swiper.css'Vue.use(VueAwesomeSwiper, /* &#123; default global options &#125; */) 使用在VUE中经常需要循环遍历图片然后生成轮播图，加上一个动态指示点像这样：代码如下： js部分是一些设置例如循环播放，间隔时间，指示器设置等这里需要注意的是数据里动态绑定src使用本地图片需要使用require，若使用网络图片则不需要 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;template&gt; &lt;div class="wrapper"&gt; &lt;swiper :options="swiperOption"&gt;//这既是图片轮播 &lt;swiper-slide v-for="item of swiperlist" :key="item.id"&gt; &lt;img class="swiper-img" :src="item.imgurl" /&gt; &lt;/swiper-slide&gt; &lt;div class="swiper-pagination weiz" slot="pagination"&gt;&lt;/div&gt; // 上面div是指示器不需要可以删除，要其他样式例如前进后退按钮切换可以自己修改，官方文档都有 &lt;/swiper&gt; &lt;/div&gt;&lt;/template&gt;&lt;script type="text/ecmascript-6"&gt;export default &#123; data: function() &#123; return &#123; swiperlist: [ &#123; imgurl: require("../../assets/img/banner/1.webp") &#125;, &#123; imgurl: require("../../assets/img/banner/2.webp") &#125;, &#123; imgurl: require("../../assets/img/banner/3.webp") &#125;, &#123; imgurl: require("../../assets/img/banner/4.webp") &#125; ], swiperOption: &#123; pagination: &#123; el: ".swiper-pagination" &#125;, autoplay: &#123; delay: 3000, disableOninteraction: true &#125;, loop: true &#125; &#125;; &#125;&#125;;&lt;/script&gt;]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue-awesome-swiper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自适应方案：在vue项目中使用postcss-px2rem]]></title>
    <url>%2F2019%2F08%2F04%2F%E8%87%AA%E9%80%82%E5%BA%94%E6%96%B9%E6%A1%88%EF%BC%9A%E5%9C%A8vue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8postcss-px2rem%2F</url>
    <content type="text"><![CDATA[在src目录下创建 viewport.js 文件下载：https://github.com/imochen/hotcss/tree/master/src 这个JS是用来在页面打开的时候给HTML根加上适配的字体大小 然后在main.js下添加： import &#39;./viewport.js&#39; 这里强调下为什么不使用lib-flexible插件个人在使用lib-flexible插件时，感觉没hotcss友好，lib-flexible在页面打开的时候，内容渲染完了才在HTML根上添加适配，这样页面会重新渲染一次，导致内容从大变小，或从小变大这样的BUG。而hotcss就没这个问题。 接下来要安装换算PX换算REM插件cnpm install postcss-px2rem --save然后在 vue.config.js加入： 123456789101112module.exports = &#123; lintOnSave: false,//关闭eslint css: &#123; loaderOptions: &#123; postcss: &#123; plugins: [ require('postcss-px2rem')(&#123;remUnit: 75&#125;), // 换算的基数 ] &#125; &#125; &#125;&#125; 最后重启]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>postcss-px2rem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[router-link-active 与 router-link-exact-active 区别]]></title>
    <url>%2F2019%2F07%2F28%2Frouter-link-active%20%E4%B8%8E%20router-link-exact-active%20%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[## router-link-exact-active router-link-exact-active 是精确匹配规则，即只有当前点击router被匹配 router-link-activerouter-link-active 默认是全包含匹配规则，即path名全包含在当前router path名开头的router也会被匹配到。 1. \ 2. \ 3. \ 4. \ 2/3号被选中 1号也会被匹配到router-link-active，4号被选中1号2号两个也会被匹配到router-link-active。 可以通过在router添加exact属性改变为精精确匹配。 我遇到两个router同时匹配class：router-link-active 的情况，而我预期是被点击的router匹配。查了官方文档得知]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>router-link</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack打包进行丑化压缩遇到（TypeError_ Cannot read property 'compilation' of undefined）问题]]></title>
    <url>%2F2019%2F07%2F27%2Fwebpack%E6%89%93%E5%8C%85%E8%BF%9B%E8%A1%8C%E4%B8%91%E5%8C%96%E5%8E%8B%E7%BC%A9%E9%81%87%E5%88%B0%EF%BC%88TypeError_%20Cannot%20read%20property%20'compilation'%20of%20undefined%EF%BC%89%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[## 问题 在使用vue官方推荐打包插件UglifyjsWebpackPlugin对webpack打包时遇到TypeError: Cannot read property ‘compilation’ of undefined 解决办法很明显，这是node一些包的版本对应不上的问题 将项目中的该包升级或者降级到1.0.0版本 1npm i uglifyjs-webpack-plugin@1.0.0 --save]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue动态绑定class]]></title>
    <url>%2F2019%2F07%2F22%2Fvue%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9Aclass%2F</url>
    <content type="text"><![CDATA[#### 1.v-bind:class 一个对象，以动态地切换 class： 动态绑定active类，当isactive == index为true时使用active类1&lt;p :class="&#123;'active':isactive == index&#125;"&gt;&#123;&#123;item.name&#125;&#125;&lt;/p&gt; 2.data数据中定义isactive定义isactive并且初始化12345data()&#123; return &#123; isactive:0, &#125; &#125; 3.样式动态绑定对象在p标签父元素上绑定了点击事件click()，点击时isactive赋值，使isactive == index，则active类生效12345methods: &#123; click(index)&#123; this.isactive = index; &#125;&#125;]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue动态绑定class</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js实现简易计算器]]></title>
    <url>%2F2019%2F07%2F18%2Fjs%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E8%AE%A1%E7%AE%97%E5%99%A8%2F</url>
    <content type="text"><![CDATA[## 前言 今天一个朋友写计算器遇到写bug，帮他解决也花了一些时间，就顺便记录一下吧！ 实现在线预览 实现主要是那几行js代码，像html,css部分并没有太大关系。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;简易计算器&lt;/title&gt; &lt;style&gt; * &#123; padding: 0; margin: 0; &#125; body, html &#123; background-color: pink; &#125; .column &#123; position: relative; border: 5px solid #fff; width: 400px; height: 500px; margin: 100px auto; &#125; .column .co-top .add &#123; font-size: 24px; font-weight: bold; margin: 4px; display: block; width: 388px; height: 100px; background-color: pink; &#125; button &#123; border: 2px solid #fff; height: 50px; width: 90px; background-color: pink; margin-bottom: 8px; font-weight: bolder; font-size: 20px; &#125; .co-bottom &#123; margin-top: 30px; position: absolute; left: 50%; border: 2px solid #fff; margin-left: -199px; width: 388px; &#125; .column .co-top .clear &#123; margin-left: 100px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="column"&gt; &lt;div class="co-top"&gt; &lt;input type="text" class="add" value="0" id="add"&gt; &lt;button class="clear" onclick="clears()"&gt;CLEAR&lt;/button&gt; &lt;button class="delete" onclick="deletes()"&gt;DELETE&lt;/button&gt; &lt;/div&gt; &lt;div class="co-bottom"&gt; &lt;button class="num"&gt;1&lt;/button&gt; &lt;button class="num"&gt;2&lt;/button&gt; &lt;button class=num&gt;3&lt;/button&gt; &lt;button class="options num"&gt;*&lt;/button&gt; &lt;button class="num"&gt;4&lt;/button&gt; &lt;button class="num"&gt;5&lt;/button&gt; &lt;button class="num"&gt;6&lt;/button&gt; &lt;button class="options num"&gt;-&lt;/button&gt; &lt;button class='num'&gt;7&lt;/button&gt; &lt;button class='num'&gt;8&lt;/button&gt; &lt;button class='num'&gt;9&lt;/button&gt; &lt;button class="options num"&gt;+&lt;/button&gt; &lt;button class='num'&gt;.&lt;/button&gt; &lt;button class="num"&gt;0&lt;/button&gt; &lt;button class="options num"&gt;/&lt;/button&gt; &lt;button class="dengyu" id="dengyu" onclick="dengyu()"&gt;=&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; var arr = []; var temp = ''; var x; var result = document.getElementById("add"); function getButton() &#123; var btns = document.getElementsByClassName("num"); for (let i = 0; i &lt; btns.length; i++) &#123; btns[i].onclick = function () &#123; x = btns[i].innerHTML; arr.push(x); result.value = temp + arr.join(''); &#125; &#125; &#125; getButton(); function dengyu() &#123; result.value = eval(result.value); temp = result.value; arr = []; &#125; function clears() &#123; result.value = 0; arr = []; temp = ''; &#125; function deletes() &#123; arr.splice(arr.length-1,1) result.value = temp + arr.join(''); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js实现简易计算器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[scss基本使用]]></title>
    <url>%2F2019%2F07%2F13%2Fscss%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[## 前言 Sass是成熟、稳定、强大的CSS预处理器，而SCSS是Sass3版本当中引入的新语法特性，完全兼容CSS3的同时继承了Sass强大的动态功能。 特性概览CSS书写代码规模较大的Web应用时，容易造成选择器、层叠的复杂度过高，因此推荐通过SASS预处理器进行CSS的开发，SASS提供的变量、嵌套、混合、继承等特性，让CSS的书写更加有趣与程式化。 变量变量用来存储需要在CSS中复用的信息，例如颜色和字体。SASS通过$符号去声明一个变量。 1234567$font-stack: Helvetica, sans-serif;$primary-color: #333;body &#123; font: 100% $font-stack; color: $primary-color;&#125; 上面例子中变量\$font-stack和\$primary-color的值将会替换所有引用他们的位置。 123body &#123; font: 100% Helvetica, sans-serif; color: #333; &#125; 嵌套SASS允许开发人员以嵌套的方式使用CSS，但是过度的使用嵌套会让产生的CSS难以维护，因此是一种不好的实践，下面的例子表达了一个典型的网站导航样式： 123456789101112131415nav &#123; ul &#123; margin: 0; padding: 0; list-style: none; &#125; li &#123; display: inline-block; &#125; a &#123; display: block; padding: 6px 12px; text-decoration: none; &#125;&#125; 大家注意上面代码中的ul、li、a选择器都被嵌套在nav选择器当中使用，这是一种书写更高可读性CSS的良好方式，编译后产生的CSS代码如下： 12345678910nav ul &#123; margin: 0; padding: 0; list-style: none; &#125;nav li &#123; display: inline-block; &#125;nav a &#123; display: block; padding: 6px 12px; text-decoration: none; &#125; 引入SASS能够将代码分割为多个片段，并以underscore风格的下划线作为其命名前缀（_partial.scss），SASS会通过这些下划线来辨别哪些文件是SASS片段，并且不让片段内容直接生成为CSS文件，从而只是在使用@import指令的位置被导入。CSS原生的@import会通过额外的HTTP请求获取引入的样式片段，而SASS的@import则会直接将这些引入的片段合并至当前CSS文件，并且不会产生新的HTTP请求。下面例子中的代码，将会在base.scss文件当中引入_reset.scss片断。 123456789101112// _reset.scsshtml, body, ul, ol &#123; margin: 0; padding: 0;&#125;// base.scss@import 'reset';body &#123; font: 100% Helvetica, sans-serif; background-color: #efefef;&#125; SASS中引入片断时，可以缺省使用文件扩展名，因此上面代码中直接通过@import ‘reset’引入，编译后生成的代码如下： 1234567html, body, ul, ol &#123; margin: 0; padding: 0; &#125;body &#123; font: 100% Helvetica, sans-serif; background-color: #efefef; &#125; 混合混合（Mixin）用来分组那些需要在页面中复用的CSS声明，开发人员可以通过向Mixin传递变量参数来让代码更加灵活，该特性在添加浏览器兼容性前缀的时候非常有用，SASS目前使用@mixin name指令来进行混合操作。 12345678910@mixin border-radius($radius) &#123; border-radius: $radius; -ms-border-radius: $radius; -moz-border-radius: $radius; -webkit-border-radius: $radius;&#125;.box &#123; @include border-radius(10px);&#125; 上面的代码建立了一个名为border-radius的Mixin，并传递了一个变量$radius作为参数，然后在后续代码中通过@include border-radius(10px)使用该Mixin，最终编译的结果如下： 12345.box &#123; border-radius: 10px; -ms-border-radius: 10px; -moz-border-radius: 10px; -webkit-border-radius: 10px; &#125; 继承继承是SASS中非常重要的一个特性，可以通过@extend指令在选择器之间复用CSS属性，并且不会产生冗余的代码，下面例子将会通过SASS提供的继承机制建立一系列样式： 12345678910111213141516171819202122232425262728293031// 这段代码不会被输出到最终生成的CSS文件，因为它没有被任何代码所继承。%other-styles &#123; display: flex; flex-wrap: wrap;&#125;// 下面代码会正常输出到生成的CSS文件，因为它被其接下来的代码所继承。%message-common &#123; border: 1px solid #ccc; padding: 10px; color: #333;&#125;.message &#123; @extend %message-common;&#125;.success &#123; @extend %message-common; border-color: green;&#125;.error &#123; @extend %message-common; border-color: red;&#125;.warning &#123; @extend %message-common; border-color: yellow;&#125; 操作符SASS提供了标准的算术运算符，例如+、-、*、/、%。在接下来的例子里，我们尝试在aside和article选择器当中对宽度进行简单的计算。 1234567891011.container &#123; width: 100%; &#125;article[role="main"] &#123; float: left; width: 600px / 960px * 100%;&#125;aside[role="complementary"] &#123; float: right; width: 300px / 960px * 100%;&#125; 上面代码以960px为基准建立了简单的流式网格布局，SASS提供的算术运算符让开发人员可以更容易的将像素值转换为百分比，最终生成的CSS样式如下所示： 12345678910.container &#123; width: 100%; &#125;article[role="main"] &#123; float: left; width: 62.5%; &#125;aside[role="complementary"] &#123; float: right; width: 31.25%; &#125; CSS扩展 引用父级选择器”&amp;”Scss使用”&amp;”关键字在CSS规则中引用父级选择器，例如在嵌套使用伪类选择器的场景下： 12345678910111213141516/*===== SCSS =====*/a &#123; font-weight: bold; text-decoration: none; &amp;:hover &#123; text-decoration: underline; &#125; body.firefox &amp; &#123; font-weight: normal; &#125;&#125;/*===== CSS =====*/a &#123; font-weight: bold; text-decoration: none; &#125; a:hover &#123; text-decoration: underline; &#125; body.firefox a &#123; font-weight: normal; &#125; 无论CSS规则嵌套的深度怎样，关键字”&amp;”都会使用父级选择器级联替换全部其出现的位置： 12345678910111213141516/*===== SCSS =====*/#main &#123; color: black; a &#123; font-weight: bold; &amp;:hover &#123; color: red; &#125; &#125;&#125;/*===== CSS =====*/#main &#123; color: black; &#125; #main a &#123; font-weight: bold; &#125; #main a:hover &#123; color: red; &#125; “&amp;”必须出现在复合选择器开头的位置，后面再连接自定义的后缀，例如： 1234567891011/*===== SCSS =====*/#main &#123; color: black; &amp;-sidebar &#123; border: 1px solid; &#125;&#125;/*===== CSS =====*/#main &#123; color: black; &#125; #main-sidebar &#123; border: 1px solid; &#125; 如果在父级选择器不存在的场景使用&amp;，Scss预处理器会报出错误信息。 嵌套属性CSS许多属性都位于相同的命名空间（例如font-family、font-size、font-weight都位于font命名空间下），Scss当中只需要编写命名空间一次，后续嵌套的子属性都将会位于该命名空间之下，请看下面的代码： 1234567891011121314/*===== SCSS =====*/.demo &#123; // 命令空间后带有冒号: font: &#123; family: fantasy; size: 30em; weight: bold; &#125;&#125;/*===== CSS =====*/.demo &#123; font-family: fantasy; font-size: 30em; 命令空间上可以直接书写CSS简写属性，但是日常开发中建议直接书写CSS简写属性，尽量保持CSS语法的一致性。 12345678910.demo &#123; font: 20px/24px fantasy &#123; weight: bold; &#125;&#125;.demo &#123; font: 20px/24px fantasy; font-weight: bold;&#125;]]></content>
      <categories>
        <category>css/html</category>
      </categories>
      <tags>
        <tag>scss基本使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[十大排序算法]]></title>
    <url>%2F2019%2F07%2F04%2F%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[## 前言 源码地址：Sorts 正文排序算法说明（1）排序的定义：对一序列对象根据某个关键字进行排序； 输入：n个数：a1,a2,a3,…,an输出：n个数的排列:a1’,a2’,a3’,…,an’，使得a1’&lt;=a2’&lt;=a3’&lt;=…&lt;=an’。 再讲的形象点就是排排坐，调座位，高的站在后面，矮的站在前面咯。 （3）对于评述算法优劣术语的说明 稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面；不稳定：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面； 内排序：所有排序操作都在内存中完成；外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行； 时间复杂度: 一个算法执行所耗费的时间。空间复杂度: 运行完一个程序所需内存的大小。 关于时间空间复杂度的更多了解请戳这里，或是看书程杰大大编写的《大话数据结构》还是很赞的，通俗易懂。 （4）排序算法图片总结(图片来源于网络): 排序对比： 图片名词解释：n: 数据规模k:“桶”的个数In-place: 占用常数内存，不占用额外内存Out-place: 占用额外内存 排序分类： 1.冒泡排序（Bubble Sort） 好的，开始总结第一个排序算法，冒泡排序。我想对于它每个学过C语言的都会了解的吧，这可能是很多人接触的第一个排序算法。 (1)算法描述 冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 (2)算法描述和实现具体算法描述如下： .比较相邻的元素。如果第一个比第二个大，就交换它们两个； .对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数； .针对所有的元素重复以上的步骤，除了最后一个； .重复步骤1~3，直到排序完成。 JavaScript代码实现： 123456789101112131415function bubbleSort(arr) &#123; var len = arr.length; for (var i = 0; i &lt; len; i++) &#123; for (var j = 0; j &lt; len - 1 - i; j++) &#123; if (arr[j] &gt; arr[j+1]) &#123; //相邻元素两两对比 var temp = arr[j+1]; //元素交换 arr[j+1] = arr[j]; arr[j] = temp; &#125; &#125; &#125; return arr;&#125;var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];console.log(bubbleSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] 改进冒泡排序： 设置一标志性变量pos,用于记录每趟排序中最后一次进行交换的位置。由于pos位置之后的记录均已交换到位,故在进行下一趟排序时只要扫描到pos位置即可。 改进后算法如下:123456789101112131415161718function bubbleSort2(arr) &#123; console.time('改进后冒泡排序耗时'); var i = arr.length-1; //初始时,最后位置保持不变 while ( i&gt; 0) &#123; var pos= 0; //每趟开始时,无记录交换 for (var j= 0; j&lt; i; j++) if (arr[j]&gt; arr[j+1]) &#123; pos= j; //记录交换的位置 var tmp = arr[j]; arr[j]=arr[j+1];arr[j+1]=tmp; &#125; i= pos; //为下一趟排序作准备 &#125; console.timeEnd('改进后冒泡排序耗时'); return arr;&#125;var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];console.log(bubbleSort2(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] 传统冒泡排序中每一趟排序操作只能找到一个最大值或最小值,我们考虑利用在每趟排序中进行正向和反向两遍冒泡的方法一次可以得到两个最终值(最大者和最小者) , 从而使排序趟数几乎减少了一半。 改进后的算法实现为:12345678910111213141516171819202122function bubbleSort3(arr3) &#123; var low = 0; var high= arr.length-1; //设置变量的初始值 var tmp,j; console.time('2.改进后冒泡排序耗时'); while (low &lt; high) &#123; for (j= low; j&lt; high; ++j) //正向冒泡,找到最大者 if (arr[j]&gt; arr[j+1]) &#123; tmp = arr[j]; arr[j]=arr[j+1];arr[j+1]=tmp; &#125; --high; //修改high值, 前移一位 for (j=high; j&gt;low; --j) //反向冒泡,找到最小者 if (arr[j]&lt;arr[j-1]) &#123; tmp = arr[j]; arr[j]=arr[j-1];arr[j-1]=tmp; &#125; ++low; //修改low值,后移一位 &#125; console.timeEnd('2.改进后冒泡排序耗时'); return arr3;&#125; var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];console.log(bubbleSort3(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] 三种方法耗时对比： 由图可以看出改进后的冒泡排序明显的时间复杂度更低，耗时更短了。读者自行尝试可以戳这，博主在github建了个库，读者可以Clone下来本地尝试。此博文配合源码体验更棒哦~~~ 冒泡排序动图演示: (3)算法分析 最佳情况：T(n) = O(n) 当输入的数据已经是正序时（都已经是正序了，为毛何必还排序呢….） 最差情况：T(n) = O(n2) 当输入的数据是反序时(卧槽，我直接反序不就完了….) 平均情况：T(n) = O(n2) 2.选择排序（Selection Sort） 表现最稳定的排序算法之一(这个稳定不是指算法层面上的稳定哈，相信聪明的你能明白我说的意思2333)，因为无论什么数据进去都是O(n²)的时间复杂度…..所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。 (1)算法简介 选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 (2)算法描述和实现n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下： .初始状态：无序区为R[1..n]，有序区为空； .第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区； .n-1趟结束，数组有序化了。 Javascript代码实现: 1234567891011121314151617181920function selectionSort(arr) &#123; var len = arr.length; var minIndex, temp; console.time('选择排序耗时'); for (var i = 0; i &lt; len - 1; i++) &#123; minIndex = i; for (var j = i + 1; j &lt; len; j++) &#123; if (arr[j] &lt; arr[minIndex]) &#123; //寻找最小的数 minIndex = j; //将最小数的索引保存 &#125; &#125; temp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = temp; &#125; console.timeEnd('选择排序耗时'); return arr;&#125;var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];console.log(selectionSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] 选择排序动图演示： (3)算法分析 最佳情况：T(n) = O(n2) 最差情况：T(n) = O(n2) 平均情况：T(n) = O(n2) 3.插入排序（Insertion Sort） 插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。当然，如果你说你打扑克牌摸牌的时候从来不按牌的大小整理牌，那估计这辈子你对插入排序的算法都不会产生任何兴趣了….. (1)算法简介 插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。 (2)算法描述和实现一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下： .从第一个元素开始，该元素可以认为已经被排序； .取出下一个元素，在已经排序的元素序列中从后向前扫描； .如果该元素（已排序）大于新元素，将该元素移到下一位置； .重复步骤3，直到找到已排序的元素小于或者等于新元素的位置； .将新元素插入到该位置后； .重复步骤2~5。 Javascript代码实现: 123456789101112131415161718function insertionSort(array) &#123; if (Object.prototype.toString.call(array).slice(8, -1) === 'Array') &#123; console.time('插入排序耗时：'); for (var i = 1; i &lt; array.length; i++) &#123; var key = array[i]; var j = i - 1; while (j &gt;= 0 &amp;&amp; array[j] &gt; key) &#123; array[j + 1] = array[j]; j--; &#125; array[j + 1] = key; &#125; console.timeEnd('插入排序耗时：'); return array; &#125; else &#123; return 'array is not an Array!'; &#125;&#125; 改进插入排序： 查找插入位置时使用二分查找的方式 12345678910111213141516171819202122232425262728function binaryInsertionSort(array) &#123; if (Object.prototype.toString.call(array).slice(8, -1) === 'Array') &#123; console.time('二分插入排序耗时：'); for (var i = 1; i &lt; array.length; i++) &#123; var key = array[i], left = 0, right = i - 1; while (left &lt;= right) &#123; var middle = parseInt((left + right) / 2); if (key &lt; array[middle]) &#123; right = middle - 1; &#125; else &#123; left = middle + 1; &#125; &#125; for (var j = i - 1; j &gt;= left; j--) &#123; array[j + 1] = array[j]; &#125; array[left] = key; &#125; console.timeEnd('二分插入排序耗时：'); return array; &#125; else &#123; return 'array is not an Array!'; &#125;&#125;var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];console.log(binaryInsertionSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] 改进前后对比： 插入排序动图演示: (3)算法分析 最佳情况：输入数组按升序排列。T(n) = O(n) 最坏情况：输入数组按降序排列。T(n) = O(n2) 平均情况：T(n) = O(n2) 4.希尔排序（Shell Sort） 1959年Shell发明；第一个突破O(n^2)的排序算法；是简单插入排序的改进版；它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序 (1)算法简介 希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。动态定义间隔序列的算法是《算法（第4版》的合著者Robert Sedgewick提出的。 (2)算法描述和实现先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述： . 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1； .按增量序列个数k，对序列进行k 趟排序； .每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。 Javascript代码实现： 12345678910111213141516171819202122function shellSort(arr) &#123; var len = arr.length, temp, gap = 1; console.time('希尔排序耗时:'); while(gap &lt; len/5) &#123; //动态定义间隔序列 gap =gap*5+1; &#125; for (gap; gap &gt; 0; gap = Math.floor(gap/5)) &#123; for (var i = gap; i &lt; len; i++) &#123; temp = arr[i]; for (var j = i-gap; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j-=gap) &#123; arr[j+gap] = arr[j]; &#125; arr[j+gap] = temp; &#125; &#125; console.timeEnd('希尔排序耗时:'); return arr;&#125;var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];console.log(shellSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] 希尔排序图示（图片来源网络）： （3）算法分析 最佳情况：T(n) = O(nlog2 n) 最坏情况：T(n) = O(nlog2 n) 平均情况：T(n) =O(nlog n) 5.归并排序（Merge Sort） 和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(n log n）的时间复杂度。代价是需要额外的内存空间。 (1)算法简介 归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 (2)算法描述和实现具体算法描述如下： .把长度为n的输入序列分成两个长度为n/2的子序列； .对这两个子序列分别采用归并排序； .将两个排序好的子序列合并成一个最终的排序序列。 Javscript代码实现: 123456789101112131415161718192021222324252627282930313233function mergeSort(arr) &#123; //采用自上而下的递归方法 var len = arr.length; if(len &lt; 2) &#123; return arr; &#125; var middle = Math.floor(len / 2), left = arr.slice(0, middle), right = arr.slice(middle); return merge(mergeSort(left), mergeSort(right));&#125;function merge(left, right)&#123; var result = []; console.time('归并排序耗时'); while (left.length &amp;&amp; right.length) &#123; if (left[0] &lt;= right[0]) &#123; result.push(left.shift()); &#125; else &#123; result.push(right.shift()); &#125; &#125; while (left.length) result.push(left.shift()); while (right.length) result.push(right.shift()); console.timeEnd('归并排序耗时'); return result;&#125;var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];console.log(mergeSort(arr)); 归并排序动图演示: (3)算法分析 最佳情况：T(n) = O(n) 最差情况：T(n) = O(nlogn) 平均情况：T(n) = O(nlogn) 6.快速排序（Quick Sort） 快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高! 它是处理大数据最快的排序算法之一了。 (1)算法简介 快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。 (2)算法描述和实现快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下： .从数列中挑出一个元素，称为 “基准”（pivot）； .重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作； .递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。 Javascript代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/*方法说明：快速排序@param array 待排序数组*///方法一function quickSort(array, left, right) &#123; console.time('1.快速排序耗时'); if (Object.prototype.toString.call(array).slice(8, -1) === 'Array' &amp;&amp; typeof left === 'number' &amp;&amp; typeof right === 'number') &#123; if (left &lt; right) &#123; var x = array[right], i = left - 1, temp; for (var j = left; j &lt;= right; j++) &#123; if (array[j] &lt;= x) &#123; i++; temp = array[i]; array[i] = array[j]; array[j] = temp; &#125; &#125; quickSort(array, left, i - 1); quickSort(array, i + 1, right); &#125; console.timeEnd('1.快速排序耗时'); return array; &#125; else &#123; return 'array is not an Array or left or right is not a number!'; &#125;&#125;//方法二var quickSort2 = function(arr) &#123; console.time('2.快速排序耗时'); if (arr.length &lt;= 1) &#123; return arr; &#125; var pivotIndex = Math.floor(arr.length / 2); var pivot = arr.splice(pivotIndex, 1)[0]; var left = []; var right = []; for (var i = 0; i &lt; arr.length; i++)&#123; if (arr[i] &lt; pivot) &#123; left.push(arr[i]); &#125; else &#123; right.push(arr[i]); &#125; &#125;console.timeEnd('2.快速排序耗时'); return quickSort2(left).concat([pivot], quickSort2(right));&#125;;var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];console.log(quickSort(arr,0,arr.length-1));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]console.log(quickSort2(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] 快速排序动图演示： (3)算法分析 最佳情况：T(n) = O(nlogn) 最差情况：T(n) = O(n2) 平均情况：T(n) = O(nlogn) 7.堆排序（Heap Sort） 堆排序可以说是一种利用堆的概念来排序的选择排序。 (1)算法简介 堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。 (2)算法描述和实现具体算法描述如下： .将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区； .将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]； .由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。 Javascript代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/*方法说明：堆排序@param array 待排序数组*/function heapSort(array) &#123; console.time('堆排序耗时'); if (Object.prototype.toString.call(array).slice(8, -1) === 'Array') &#123; //建堆 var heapSize = array.length, temp; for (var i = Math.floor(heapSize / 2) - 1; i &gt;= 0; i--) &#123; heapify(array, i, heapSize); &#125; //堆排序 for (var j = heapSize - 1; j &gt;= 1; j--) &#123; temp = array[0]; array[0] = array[j]; array[j] = temp; heapify(array, 0, --heapSize); &#125; console.timeEnd('堆排序耗时'); return array; &#125; else &#123; return 'array is not an Array!'; &#125;&#125;/*方法说明：维护堆的性质@param arr 数组@param x 数组下标@param len 堆大小*/function heapify(arr, x, len) &#123; if (Object.prototype.toString.call(arr).slice(8, -1) === 'Array' &amp;&amp; typeof x === 'number') &#123; var l = 2 * x + 1, r = 2 * x + 2, largest = x, temp; if (l &lt; len &amp;&amp; arr[l] &gt; arr[largest]) &#123; largest = l; &#125; if (r &lt; len &amp;&amp; arr[r] &gt; arr[largest]) &#123; largest = r; &#125; if (largest != x) &#123; temp = arr[x]; arr[x] = arr[largest]; arr[largest] = temp; heapify(arr, largest, len); &#125; &#125; else &#123; return 'arr is not an Array or x is not a number!'; &#125;&#125;var arr=[91,60,96,13,35,65,46,65,10,30,20,31,77,81,22];console.log(heapSort(arr));//[10, 13, 20, 22, 30, 31, 35, 46, 60, 65, 65, 77, 81, 91, 96] 堆排序动图演示： (3)算法分析 最佳情况：T(n) = O(nlogn) 最差情况：T(n) = O(nlogn) 平均情况：T(n) = O(nlogn) 8.计数排序（Counting Sort） 计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。 (1)算法简介 计数排序(Counting sort)是一种稳定的排序算法。计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。它只能对整数进行排序。 (2)算法描述和实现具体算法描述如下： . 找出待排序的数组中最大和最小的元素； . 统计数组中每个值为i的元素出现的次数，存入数组C的第i项； . 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）； . 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。 Javascript代码实现： 1234567891011121314151617181920212223function countingSort(array) &#123; var len = array.length, B = [], C = [], min = max = array[0]; console.time('计数排序耗时'); for (var i = 0; i &lt; len; i++) &#123; min = min &lt;= array[i] ? min : array[i]; max = max &gt;= array[i] ? max : array[i]; C[array[i]] = C[array[i]] ? C[array[i]] + 1 : 1; &#125; for (var j = min; j &lt; max; j++) &#123; C[j + 1] = (C[j + 1] || 0) + (C[j] || 0); &#125; for (var k = len - 1; k &gt;= 0; k--) &#123; B[C[array[k]] - 1] = array[k]; C[array[k]]--; &#125; console.timeEnd('计数排序耗时'); return B;&#125;var arr = [2, 2, 3, 8, 7, 1, 2, 2, 2, 7, 3, 9, 8, 2, 1, 4, 2, 4, 6, 9, 2];console.log(countingSort(arr)); //[1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 4, 4, 6, 7, 7, 8, 8, 9, 9] JavaScript动图演示：、 (3)算法分析 当输入的元素是n 个0到k之间的整数时，它的运行时间是 O(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。 最佳情况：T(n) = O(n+k) 最差情况：T(n) = O(n+k) 平均情况：T(n) = O(n+k) 9.桶排序（Bucket Sort） 桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。 (1)算法简介 桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排 (2)算法描述和实现具体算法描述如下： .设置一个定量的数组当作空桶； .遍历输入数据，并且把数据一个一个放到对应的桶里去； .对每个不是空的桶进行排序； .从不是空的桶里把排好序的数据拼接起来。 Javascript代码实现: 1234567891011121314151617181920212223242526272829303132333435363738/*方法说明：桶排序@param array 数组@param num 桶的数量*/function bucketSort(array, num) &#123; if (array.length &lt;= 1) &#123; return array; &#125; var len = array.length, buckets = [], result = [], min = max = array[0], regex = '/^[1-9]+[0-9]*$/', space, n = 0; num = num || ((num &gt; 1 &amp;&amp; regex.test(num)) ? num : 10); console.time('桶排序耗时'); for (var i = 1; i &lt; len; i++) &#123; min = min &lt;= array[i] ? min : array[i]; max = max &gt;= array[i] ? max : array[i]; &#125; space = (max - min + 1) / num; for (var j = 0; j &lt; len; j++) &#123; var index = Math.floor((array[j] - min) / space); if (buckets[index]) &#123; // 非空桶，插入排序 var k = buckets[index].length - 1; while (k &gt;= 0 &amp;&amp; buckets[index][k] &gt; array[j]) &#123; buckets[index][k + 1] = buckets[index][k]; k--; &#125; buckets[index][k + 1] = array[j]; &#125; else &#123; //空桶，初始化 buckets[index] = []; buckets[index].push(array[j]); &#125; &#125; while (n &lt; num) &#123; result = result.concat(buckets[n]); n++; &#125; console.timeEnd('桶排序耗时'); return result;&#125;var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];console.log(bucketSort(arr,4));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] 桶排序图示（图片来源网络）： 关于桶排序更多 (3)算法分析 桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。 最佳情况：T(n) = O(n+k) 最差情况：T(n) = O(n+k) 平均情况：T(n) = O(n2) 10.基数排序（Radix Sort） 基数排序也是非比较的排序算法，对每一位进行排序，从最低位开始排序，复杂度为O(kn),为数组长度，k为数组中的数的最大的位数； (1)算法简介 基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。 (2)算法描述和实现具体算法描述如下： .取得数组中的最大数，并取得位数； .arr为原始数组，从最低位开始取每个位组成radix数组； .对radix进行计数排序（利用计数排序适用于小范围数的特点）； Javascript代码实现： 1234567891011121314151617181920212223242526272829303132333435363738/** * 基数排序适用于： * (1)数据范围较小，建议在小于1000 * (2)每个数值都要大于等于0 * @author xiazdong * @param arr 待排序数组 * @param maxDigit 最大位数 *///LSD Radix Sortfunction radixSort(arr, maxDigit) &#123; var mod = 10; var dev = 1; var counter = []; console.time('基数排序耗时'); for (var i = 0; i &lt; maxDigit; i++, dev *= 10, mod *= 10) &#123; for(var j = 0; j &lt; arr.length; j++) &#123; var bucket = parseInt((arr[j] % mod) / dev); if(counter[bucket]== null) &#123; counter[bucket] = []; &#125; counter[bucket].push(arr[j]); &#125; var pos = 0; for(var j = 0; j &lt; counter.length; j++) &#123; var value = null; if(counter[j]!=null) &#123; while ((value = counter[j].shift()) != null) &#123; arr[pos++] = value; &#125; &#125; &#125; &#125; console.timeEnd('基数排序耗时'); return arr;&#125;var arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];console.log(radixSort(arr,2)); //[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] 基数排序LSD动图演示： (3)算法分析 最佳情况：T(n) = O(n * k) 最差情况：T(n) = O(n * k) 平均情况：T(n) = O(n * k) 基数排序有两种方法： MSD 从高位开始进行排序 LSD 从低位开始进行排序 基数排序 vs 计数排序 vs 桶排序 这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异： 基数排序：根据键值的每位数字来分配桶 计数排序：每个桶只存储单一键值 桶排序：每个桶存储一定范围的数值 后记 十大排序算法的总结到这里就算告一段落了。博主总结完之后只有一个感觉，排序算法博大精深，前辈们用了数年甚至一辈子的心血研究出来的算法更值得我们推敲。站在十大算法的门前心里还是诚惶诚恐的，身为一个小学生，博主的总结难免会有所疏漏，欢迎各位批评指正。er[j].shift()) != null) { arr[pos++] = value; } } } } console.timeEnd(‘基数排序耗时’); return arr;}var arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];console.log(radixSort(arr,2)); //[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] 123456789101112131415161718192021222324252627**基数排序LSD动图演示：**[外链图片转存中...(img-3TJzayzj-1562200672184)]#### (3)算法分析- 最佳情况：T(n) = O(n * k)- 最差情况：T(n) = O(n * k)- 平均情况：T(n) = O(n * k)基数排序有两种方法：- MSD 从高位开始进行排序- LSD 从低位开始进行排序**基数排序 vs 计数排序 vs 桶排序**这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：1. 基数排序：根据键值的每位数字来分配桶2. 计数排序：每个桶只存储单一键值3. 桶排序：每个桶存储一定范围的数值## 后记&gt; 十大排序算法的总结到这里就算告一段落了。博主总结完之后只有一个感觉，排序算法博大精深，前辈们用了数年甚至一辈子的心血研究出来的算法更值得我们推敲。站在十大算法的门前心里还是诚惶诚恐的，身为一个小学生，博主的总结难免会有所疏漏，欢迎各位批评指正。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue组件兄弟间通信]]></title>
    <url>%2F2019%2F06%2F27%2Fvue%E7%BB%84%E4%BB%B6%E5%85%84%E5%BC%9F%E9%97%B4%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[## 兄弟组件间通信（event） 借助于一个公共的Vue的实例对象，不同的组件可以通过该对象完成事件的绑定和触发 1234var bus = new Vue();bus.$emit()bus.$on() 熊大想要发消息给熊二 接收方（熊二）：事件绑定 123bus.$on('customEvent',function(msg)&#123;//msg就是通过事件 传递来的数据&#125;) 发送方（熊大）：触发事件 1bus.$emit('customEvent',123); Demo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;!doctype html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="js/vue.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="container"&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;xiongda&gt;&lt;/xiongda&gt; &lt;hr&gt; &lt;xionger&gt;&lt;/xionger&gt; &lt;/div&gt; &lt;script&gt;/*借助于一个公共的Vue的实例对象，不同的组件可以通过该对象完成事件的绑定和触发*///new一个对象，兄弟间的通信，将借助他事件绑定和触发来实现 var bus = new Vue(); //熊大发送消息给熊二 //xiongda组件 Vue.component("xiongda",&#123; data:function()&#123; return &#123; xiongDaInput:"" &#125; &#125;, methods:&#123; sendToXiongEr:function()&#123; //给熊二发送消息 //触发msgToXiongEr事件 bus.$emit("msgToXiongEr",this.xiongDaInput); this.xiongDaInput = ""; &#125; &#125;, template:` &lt;div&gt; &lt;h1&gt;我是熊大&lt;/h1&gt; &lt;input type="text" v-model="xiongDaInput"/&gt; &lt;button @click="sendToXiongEr"&gt;Click Me&lt;/button&gt; &lt;/div&gt; ` &#125;)//熊二组件 Vue.component("xionger",&#123; data:function()&#123; return&#123; recvMsgIs:[] &#125; &#125;, template:` &lt;div&gt; &lt;h1&gt;我是熊二&lt;/h1&gt; &lt;p v-for="tmp in recvMsgIs"&gt;&#123;&#123;tmp&#125;&#125;&lt;/p&gt; &lt;/div&gt; `, mounted:function()&#123;// 给该组件绑定一个自定义事件和对应的处理函数 //调用bus中的on方法 //事件的触发一般是接收数据然后处理 var that = this; bus.$on("msgToXiongEr",function(msg)&#123; //alert("自定义的事件触发，接收到的数据"+msg); that.recvMsgIs.push(msg); &#125;) &#125; &#125;) new Vue(&#123; el:"#container", data:&#123; msg:"Hello VueJs" &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 效果图]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>兄弟组件间通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何用 async_await 来处理异步]]></title>
    <url>%2F2019%2F06%2F26%2F%E5%A6%82%E4%BD%95%E7%94%A8%20async_await%20%E6%9D%A5%E5%A4%84%E7%90%86%E5%BC%82%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[## 前言 ES7的async/await语法在2016年就已经提出来了，用async/ await来发送异步请求，从服务端获取数据，代码很简洁，async/await 也已经被标准化。 async先说一下async的用法，它作为一个关键字放到函数前面，用于表示函数是一个异步函数，因为async就是异步的意思， 异步函数也就意味着该函数的执行不会阻塞后面代码的执行。 写一个async 函数： 123async function timeout() &#123; return 'hello world';&#125; 语法很简单，就是在函数前面加上async 关键字，来表示它是异步的，那怎么调用呢？async 函数也是函数，平时我们怎么使用函数就怎么使用它，直接加括号调用就可以了，为了表示它没有阻塞它后面代码的执行，我们在async 函数调用之后加一句console.log; 12345async function timeout() &#123; return 'hello world'&#125;timeout();console.log('虽然在后面，但是我先执行'); 打开浏览器控制台，我们看到了 async 函数 timeout 调用了，但是没有任何输出，它不是应该返回 ‘hello world’, 先不要着急， 看一看timeout()执行返回了什么？ 把上面的 timeout() 语句改为console.log(timeout()) 12345async function timeout() &#123; return 'hello world'&#125;console.log(timeout());console.log('虽然在后面，但是我先执行'); 继续看控制台原来async 函数返回的是一个promise 对象，如果要获取到promise 返回值，我们应该用then 方法， 继续修改代码 1234567async function timeout() &#123; return 'hello world'&#125;timeout().then(result =&gt; &#123; console.log(result);&#125;)console.log('虽然在后面，但是我先执行'); 看控制台 我们获取到了”hello world’, 同时timeout 的执行也没有阻塞后面代码的执行，和 我们刚才说的一致。 这时，你可能注意到控制台中的Promise 有一个resolved，这是async 函数内部的实现原理。如果async 函数中有返回一个值 ,当调用该函数时，内部会调用Promise.solve() 方法把它转化成一个promise 对象作为返回，但如果timeout 函数内部抛出错误呢？ 那么就会调用Promise.reject() 返回一个promise 对象， 这时修改一下timeout 函数 123456789async function timeout(flag) &#123; if (flag) &#123; return 'hello world' &#125; else &#123; throw 'my god, failure' &#125;&#125;console.log(timeout(true)) // 调用Promise.resolve() 返回promise 对象。console.log(timeout(false)); // 调用Promise.reject() 返回promise 对象。 控制台如下：如果函数内部抛出错误， promise 对象有一个catch 方法进行捕获。 123timeout(false).catch(err =&gt; &#123; console.log(err)&#125;) awaitawait是等待的意思，那么它等待什么呢，它后面跟着什么呢？其实它后面可以放任何表达式，不过我们更多的是放一个返回promise 对象的表达式。注意await 关键字只能放到async 函数里面 现在写一个函数，让它返回promise 对象，该函数的作用是2s 之后让数值乘以2 12345678// 2s 之后返回双倍的值function doubleAfter2seconds(num) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(2 * num) &#125;, 2000); &#125; )&#125; 现在再写一个async 函数，从而可以使用await 关键字， await 后面放置的就是返回promise对象的一个表达式，所以它后面可以写上 doubleAfter2seconds 函数的调用 1234async function testResult() &#123; let result = await doubleAfter2seconds(30); console.log(result);&#125; 现在调用testResult 函数 1testResult(); 打开控制台，2s 之后，输出了60. 现在我们看看代码的执行过程，调用testResult 函数，它里面遇到了await, await 表示等一下，代码就暂停到这里，不再向下执行了，它等什么呢？等后面的promise对象执行完毕，然后拿到promise resolve 的值并进行返回，返回值拿到之后，它继续向下执行。具体到 我们的代码, 遇到await 之后，代码就暂停执行了， 等待doubleAfter2seconds(30) 执行完毕，doubleAfter2seconds(30) 返回的promise 开始执行，2秒 之后，promise resolve 了， 并返回了值为60， 这时await 才拿到返回值60， 然后赋值给result， 暂停结束，代码才开始继续执行，执行 console.log语句。 就这一个函数，我们可能看不出async/await 的作用，如果我们要计算3个数的值，然后把得到的值进行输出呢？ 123456async function testResult() &#123; let first = await doubleAfter2seconds(30); let second = await doubleAfter2seconds(50); let third = await doubleAfter2seconds(30); console.log(first + second + third);&#125; 6秒后，控制台输出220, 我们可以看到，写异步代码就像写同步代码一样了，再也没有回调地域了。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>sync_await</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手写jQuery轮播图（无缝回到第一张）]]></title>
    <url>%2F2019%2F06%2F26%2F%E6%89%8B%E5%86%99jQuery%E8%BD%AE%E6%92%AD%E5%9B%BE%EF%BC%88%E6%97%A0%E7%BC%9D%E5%9B%9E%E5%88%B0%E7%AC%AC%E4%B8%80%E5%BC%A0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[## 前言 轮播图是学习前端必须会的，面试的时候经常会面试到。轮播图的难点在于最后一张到第一张怎么实现无缝滚动，这是一种思维方式的转变。 原理我们以3张的轮播图为例讲解。 如下图，制作三张轮播图时需要放4张图片，第四张和第一张一样。在如何从第四张1转到2呢？在我们从3移到1后，我们需要把第4张变成第一张。惯性思维会认为需要从第四张1移动到第一张1。其实对计算机而言，并没有这个过程，加上移动只是为了是我们看的舒服，我们直接设置外部ul的偏移量变成0，就变成第一张了，因为1，4两张图片一样所以看不出来变化。这一部分代码： 123456789101112131415function start() &#123; timer = setInterval(() =&gt; &#123; //将图片的right改为0则成了第一张图片，因为1，4两张图片一样所以看不出来变化 num++ if (num &gt;= 7) &#123; num = 1; ul.css(&#123; right: 0 &#125;); &#125; //然后在播放就是第一张到第二张了 ul.animate(&#123; "right": width * num &#125;) &#125; Demo为了方便，这里直接将css,js代码写在了html中，注意图片路径和jq路径需要改成自己的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;script src="../../js/jquery-1.11.3.js"&gt;&lt;/script&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; border: 0; &#125; .wrapper &#123; position: relative; width: 500px; margin: 30px auto; &#125; .top &#123; width: 500px; overflow: hidden; &#125; li &#123; list-style-type: none; float: left; white-space: nowrap; &#125; .imgs &#123; width: 4000px; position: relative; &#125; .center .btn &#123; position: absolute; top: 140px; color: white; background-color: black; opacity: 0.7; width: 40px; height: 60px; line-height: 60px; text-align: center; &#125; .center .btn.left &#123; left: 0; &#125; .center .btn.right &#123; right: 0; &#125; .buttom .move &#123; position: absolute; bottom: 10px; transform: translateX(-50%); left: 50%; &#125; .buttom .move li &#123; width: 10px; height: 10px; border-radius: 50%; background-color: skyblue; text-align: center; margin-left: 3px; &#125; .bg &#123; background-color: red !important; &#125; &lt;/style&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="wrapper"&gt; &lt;div class="top"&gt; &lt;ul class="imgs"&gt; &lt;li&gt;&lt;img src="../image/1.jpg" alt="" width="500px" height="333"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="../image/2.jpg" alt="" width="500px" height="333"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="../image/3.jpg" alt="" width="500px" height="333"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="../image/4.jpg" alt="" width="500px" height="333"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="../image/5.jpg" alt="" width="500px" height="333"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="../image/6.jpg" alt="" width="500px" height="333"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="../image/1.jpg" alt="" width="500px" height="333"&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class="center"&gt; &lt;div class="btn left"&gt; &lt;&lt;/div&gt; &lt;div class="btn right"&gt;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="buttom"&gt; &lt;ul class="move"&gt; &lt;li class="bg"&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; $(document).ready(function () &#123; ul = $('.wrapper .top .imgs') var width = 500 var num = 1 start() // 鼠标放在下方原点上触发事件 $('.buttom .move li').hover(function () &#123; //清除ul所有动画队列 ul.stop(true, true) //清楚定时器 clearInterval(timer) //添加背景色 $(this).addClass('bg').siblings().removeClass('bg') //图片移到相对应 num = $(this).index() ul.animate(&#123; "right": width * num &#125;) &#125;, function () &#123; //开始轮播 start() $(this).removeClass('bg') &#125;) //下一张 $('.center .right').on('click', function () &#123; ul.stop(true, true) clearInterval(timer) num++; if (num &gt;= 7) &#123; num = 1; ul.css(&#123; right: 0 &#125;); &#125; ul.animate(&#123; "right": width * num &#125;) color() start() &#125;) //下一张 $('.center .left').on('click', function () &#123; ul.stop(true, true) clearInterval(timer) num--; if (num &lt;= -1) &#123; num = 5; ul.css(&#123; right: 3000 &#125;); &#125; ul.animate(&#123; "right": width * num &#125;) color() start() &#125;) // 下方原点背景色 function color() &#123; if (num === 6) &#123; $('.buttom .move li').eq(0).addClass('bg').siblings().removeClass('bg') &#125; else &#123; $('.buttom .move li').eq(num).addClass('bg').siblings().removeClass('bg') &#125; &#125; // 自动轮播 function start() &#123; timer = setInterval(() =&gt; &#123; num++ if (num &gt;= 7) &#123; num = 1; ul.css(&#123; right: 0 &#125;); &#125; ul.animate(&#123; "right": width * num &#125;) if (num === 6) &#123; $('.buttom .move li').eq(0).addClass('bg').siblings().removeClass('bg') &#125; else &#123; $('.buttom .move li').eq(num).addClass('bg').siblings().removeClass('bg') &#125; &#125;, 1000); &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果图]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>轮播图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS事件委托]]></title>
    <url>%2F2019%2F06%2F26%2Fjs%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%2F</url>
    <content type="text"><![CDATA[## 事件委托 事件委托：也称事件代理 就是利用冒泡的原理 把事件加到父级上，触发执行效果 说明你应该写过这样的程序，有一个列表，当鼠标移入每个li，背景颜色变红，于是我们写出了这样的代 码： 12345678window.onload = function()&#123; var oUl = document.getElementById('ull');//获取ul var aLi = document.getElementsByTagName('li'); //获取所有li for(var i =0;i &lt; aLi.length;i++)&#123; aLi[i].onmouseover = function()&#123; this.style.background = "red"; &#125;&#125; 当然这样一看代码也没什么问题，通过循环给每个li加事件，但想一想如果我们有很多个li,是不是要加很多次事件，这样其实是非常耗性能的。那么我们会想，能不能只加一个事件就能实现呢。这当然是能的。 通过冒泡原理进行事件委托，我们可以把事件只加给父级oUL,这样不管移入哪个li,都会触发父级的移入事件，但这个时候也有个问题，因为我的需求是，让对应的li变颜色，不是让整个列表变，它怎么知道我鼠标移入的是哪个LI，这个时候万能的事件对象中的一个属性就要出场了，就是事件源 (不管事件绑定在那个元素中 都指的是实际触发事件的那个的目标)，就是能获取到你当前鼠标所在的LI， 不过这个有兼容性问题， IE和标准下不同，标准指的就是比较新版本的那些浏览器了 IE：window.event.srcElement标准：event.target 下面看下整体代码： 12345678910111213window.onload = function()&#123; var oUl = document.getElementById('ull'); var aLi = document.getElementsByTagName('li'); oUl.onmouseover = function(ev)&#123; var event = ev||window.event; // 获取event对象 var target = ev.target || ev.srcElement; // 获取触发事件的目标对象 if(target.nodeName.toLowerCase() == 'li')&#123; //判断目标对象是不是li target.style.background = 'red'; &#125; &#125; 代码中加了一个标签名的判断，主要原因是如果不加判断，当你鼠标移入到父级oUL上面的时候，整个列表就会变红，这不是我们想要的结果，所以要判断一下。target.nodeName 弹出的名字是大写的，所以需要转换大小写再比较。 整个需求这样就完成了，而且当列表很多的时候大大的提高了性能。 其实事件委托还有第二个优点：就是新添加的元素还会有之前的事件 假定我们又有一个需求，点击某个按钮，可以在列表中再创建一个li,这个时候一般方法，因为新创建的li没有加事件，所以是不具备移入变红的功能的，但是用事件委托的方法，新的li,同样有这个事件。原理也很容易相同，因为事件是加在父亲上面的，父亲在，事件在，这就留给大家自己尝试吧。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>事件委托</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS中多种常见居中方法]]></title>
    <url>%2F2019%2F06%2F23%2FCSS%E4%B8%AD%E5%A4%9A%E7%A7%8D%E5%B8%B8%E8%A7%81%E5%B1%85%E4%B8%AD%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[## 前言 css居中是常见的需求，不同场景需要不同的居中方法，本文讨论多种常见居中方法，如有遗漏欢迎补充。 水平居中 内联元素 给内联元素的父级加text-align:cente; 123.container&#123; text-align:center;&#125; 块级元素 设置左右marign的值为auto 123.container&#123; margin:0 auto;&#125; 垂直居中1. 内联元素设置行高和父级高度一样12345678.container&#123; height:200px; text-align:center;&#125;.center&#123; line-height:200px;&#125; 2. 不知道 .parent 的 height将上下padding的值相等 123456789.container&#123; border:1px solid #000; text-align:center;&#125;.center&#123; display:inline-blcok; padding:20px 0;&#125; 3. table自带功能1234567&lt;table class="parent"&gt; &lt;tr&gt; &lt;td class="child"&gt; 这里内容会自动居中 &lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 4. div 装成 table设置display的值为table-cell，将元素变为表格cell显示 1234567.container&#123; width:600px; height:800px; display:table-cell; vertical-align:middle; text-align:center;&#125; 5. 绝对定位父元素 postion 为 relative 子元素 position 为absolute ，用 transform 属性居中 12345678910111213141516.container&#123; position:relative; width:800px; height:800px; border:1px solid #000;&#125;.center&#123; position:absolute; border:1px solid #000; width:100px; height:100px; top:50%; left:50%; transform:translate(-50%,-50%)&#125; 6. flex布局目前的主流方式，非常好用，建议用这种 1234567891011121314.container&#123; width:800px; height:800px; border:1px solid #000; display:flex; align-items: center; justify-content: center;&#125;.center&#123; width:100px; height:100px; border:1px solid #000;&#125; 7. grid布局Grid布局是一种二维布局方法，能够在行和列中布置内容。因此在任何网格中都有两个轴，横轴（即行轴，内联）和纵轴（即列轴，块）。 沿着这些轴，可以使用盒模型对齐规范中定义的属性对项目进行行对齐和列对齐。 较新的方法，所以有兼容问题，未来会越来越常使用 1234567891011121314.container&#123; width:800px; height:800px; border:1px solid #000; display: grid; align-items: center; justify-content: center;&#125;.center&#123; width:100px; height:100px; border:1px solid #000;&#125;]]></content>
      <categories>
        <category>H5/C3</category>
      </categories>
      <tags>
        <tag>css居中</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈前端架构的工程化、模块化、组件化、规范化]]></title>
    <url>%2F2019%2F06%2F22%2F%E6%B5%85%E8%B0%88%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84%E7%9A%84%E5%B7%A5%E7%A8%8B%E5%8C%96%E3%80%81%E6%A8%A1%E5%9D%97%E5%8C%96%E3%80%81%E7%BB%84%E4%BB%B6%E5%8C%96%E3%80%81%E8%A7%84%E8%8C%83%E5%8C%96%2F</url>
    <content type="text"><![CDATA[## 前言 一个项目组成分为 前端，服务端。传统的前端项目用三剑客 javascript html css 就传统的项目结构已经不能满足日益壮大的大型应用的需求了。现在前端的生态圈很繁荣，各种框架，组件的出现。让前端发展迅速，快速开发已经成为了前端的一个标准。如果你想构建一个易维护，代码简洁，性能优化程度高的项目就离不开前端的架构。这也就解疑了架构是不是必须的？ 架构的目的是什么？答案是提升质量和效率。 工程化工程化就像是百叶箱一样，减少人的操作，把工作所需要的工具做到的标准化，工作的流程做到的标准化。同时把很多重复的工作交给了代码来做，保证高质，标准统一。 先从工具入手，工程化包括哪些方面： 模块化与组件化: npm, es6,seajs, react/angularjs/Vue 代码版本管理: git 代码风格管理: jscs, editorconfig 代码编译: babel, less,sass,scss, imgmin, csssprit, inline-svg 代码质量管理 (QA): eslint, mocha 代码构建: webpack 项目脚手架: yeoman 持续集成/持续交付/持续部署: jenkins 本地化与国际化 执行工程化： 在配置初始项目文件结构和基本文件依靠命令行（工具）自动生成。 确定代码规范，缩进，换行，以及各种预编译工具less，coffee，保证输出代码的标准一致 对JS文件是否规范化，进行单元测试，不用手动复制到jshint上去检测，现在配置grunt监听文件变动自动检验显示检验结果还可以通过配置构建工具自动刷新浏览器实现文件实时变动监听。 以前压缩合并文件用手工复制到压缩工具然后复制到一个文件里面，现在配置一下 grunt，gulp可以做自动任务，实时编译，并且监测文件改变而做出响应。 以前发布到服务器上，要手动使用 FTP 软件上传，现在也可以用工具自动打包上传。模块化在JavaScript发展初期就是为了实现简单的页面交互逻辑，寥寥数语即可；如今CPU、浏览器性能得到了极大的提升，很多页面逻辑迁移到了客户端（表单验证等），随着web2.0时代的到来，Ajax技术得到广泛应用，jQuery等前端库层出不穷，前端代码日益膨胀 这时候JavaScript作为嵌入式的脚本语言的定位动摇了，JavaScript却没有为组织代码提供任何明显帮助，甚至没有类的概念，更不用说模块（module）了，JavaScript极其简单的代码组织规范不足以驾驭如此庞大规模的代码就 模块既然JavaScript不能handle如此大规模的代码，我们可以借鉴一下其它语言是怎么处理大规模程序设计的，在Java中有一个重要带概念——package，逻辑上相关的代码组织到同一个包内，包内是一个相对独立的王国，不用担心命名冲突什么的，那么外部如果使用呢？直接import对应的package即可 1import java.util.ArrayList; 遗憾的是JavaScript在设计时定位原因，没有提供类似的功能，开发者需要模拟出类似的功能，来隔离、组织复杂的JavaScript代码，我们称为模块化。 是”业务框架”或者“业务模块”，也可以理解为“框架”，意思是把功能进行划分，将同一类型的代码整合在一起，所以模块的功能相对复杂，但都同属于一个业务。 一个模块就是实现特定功能的文件，有了模块，我们就可以更方便地使用别人的代码，想要什么功能，就加载什么模块。模块开发需要遵循一定的规范，各行其是就都乱套了 使用按照项目功能需求划分成不同类型的业务框架（例如：注册、登录、外卖、直播…..） 目的隔离/封装 （高内聚）。 依赖模块之间有依赖的关系，可通过路由器进行模块之间的耦合问题。 架构定位横向分块（位于架构业务框架层）。 组件化就是”基础库”或者“基础组件”，意思是把代码重复的部分提炼出一个个组件供给功能使用。 使用：Dialog，各种自定义的UI控件、能在项目或者不同项目重复应用的代码等等。 目的复用，解耦。 依赖组件之间低依赖，比较独立。 架构定位纵向分层（位于架构底层，被其他层所依赖）。 规范化作用使项目目录结构非常清晰。当进行开发的时候，哪些代码应该放到哪里都进行了明确的规定，并且每个文件的功能都尽量清晰并且单一。 顶层目录结构如下图： src文件夹存放的是所有的的源代码和其他静态资源（比如图片，iconfont)。 dist文件夹存放的是所有编译后的代码。 build文件夹存放的是所有工程化所需要的代码。 document文件夹当然存放的文档。 下面重点看下src目录结构，如下图： app文件夹里的每一个子文件夹代表了一个页面，每个页面所用到的所有静态资源都存放在这个子文件下面（除了引用的公共资源以外），构建的时候，每个子文件夹会生成自己的静态资源供页面引用。 common文件夹里面的所有代码在构建的时候会单独生成js文件和css文件供页面引用。所以一个页面会引用两个js和两个css.里面存放的是每个页面都会用到的一些共用资源。比如触屏端使用了react,那么跟react相关的那些包就会放在common里面。 components文件夹里面存放的是共用组件，每一个子文件夹代表了一个组件。有可能是通用的功能组件，比如分页组件，Loading组件，ModalDialog组件。也有可能是一个通用的业务组件，比如站点通用头部，通用footer，通用分享组件。注意，在其他地方引用这些组件时，是不需要写相对路径的，直接写组件名字就可以了，比如import pager from ‘pager’。这样对使用者更方便。 lib文件夹存放的是通用的js类库。比如检测浏览器用的browserDetect.js,处理日期用的dateUtil.js。同样的，在其他地方需要引入这些JS时，也不需要写相对路径，直接写JS的名字就可以了。比如import{isIE} from ‘browserDetect’。 5、style文件夹里面存放的一些公用的sass资源。比如function,mixing, variable。其他的sass文件需要引入这些资源的时候，使用方式跟使用通用js一样，直接@import “base.scss”即可。]]></content>
      <categories>
        <category>框架设计</category>
      </categories>
      <tags>
        <tag>组件化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用canvas制作在线涂鸦画板]]></title>
    <url>%2F2019%2F06%2F20%2F%E4%BD%BF%E7%94%A8canvas%E5%88%B6%E4%BD%9C%E5%9C%A8%E7%BA%BF%E6%B6%82%E9%B8%A6%E7%94%BB%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[## 介绍 点击预览：在线涂鸦画板项目源码：github地址 主要功能调节笔颜色点击黑色，将画笔颜色改为黑色，并且加上active类，其他颜色删除active，实现点击处高亮。1234567black.onclick = function () &#123; context.strokeStyle = 'black' for (var i = 0; i &lt; black.parentNode.children.length; i++) &#123; black.parentNode.children[i].classList.remove('active') &#125; black.classList.add('active')&#125; 调节笔粗细点击第一个按钮，将画笔width改为3，并且加上active类，其他删除active，实现点击处高亮。1234567one.onclick = function () &#123; lineWidth = 3; for (var i = 0; i &lt; one.parentNode.children.length; i++) &#123; one.parentNode.children[i].classList.remove('active') &#125; one.classList.add('active')&#125; 清空画板使用clearRect属性清空画板123clear.onclick = function () &#123; context.clearRect(0, 0, yyy.width, yyy.height)&#125; 返回上一步先定义一个数组canvasHistory，在鼠标松开的时候将本次保存到canvasHistory中，点击返回时将画板清空然后将上一步画板信息在canvas中画出。 主要属性 getImageData 返回 ImageData 对象，该对象拷贝了画布指定矩形的像素数据。 putImageData将图像数据（从指定的 ImageData 对象）放回画布上。 1234canvas.ontouchend = function () &#123; step++; canvasHistory.push(context.getImageData(0, 0, yyy.width, yyy.height))&#125; 1234567891011cancel.onclick = function () &#123; if (step &gt;= 0) &#123; step--; context.clearRect(0, 0, yyy.width, yyy.height) context.putImageData(canvasHistory[step], 0, 0) console.log(step, context) &#125; else &#123; console.log('不能再继续撤销了'); &#125;&#125; 保存下载将画板图案用toDataURL属性产生URL，在body创建a元素设置其href和download属性，并点击a元素开始下载主要属性 toDataURL返回一个包含图片展示的 data URI download该属性设置一个值来规定下载文件的名称 target标签的 target 属性规定在何处打开链接文档。_blank：浏览器总在一个新打开、未命名的窗口中载入目标文档。 123456789save.onclick = function () &#123; var url = yyy.toDataURL('image/png') var a = document.createElement('a') document.body.appendChild(a) a.href = url a.download = '我的画板' a.target = '_blank' a.click()&#125;]]></content>
      <categories>
        <category>H5/C3</category>
      </categories>
      <tags>
        <tag>canvas画板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[本地存储和离线缓存的作用和区别]]></title>
    <url>%2F2019%2F06%2F18%2F%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E5%92%8C%E7%A6%BB%E7%BA%BF%E7%BC%93%E5%AD%98%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[## 前言 前端的存储方式有：localStorage、sessionStorage、cookie、UserData、webSQL、indexeddb、HTML5离线存储等。各个存储方式有各自的优缺点，本文我们来探讨一下不同存储的功能及区别。 本地存储1.cookie在h5之前，存储主要用的是cookie。cookie会随着每次http请求头信息一起发送，无形中增加了网络流量，另外，cookie能存储的数据容量有限，根据浏览器类型不同而不同，IE6大约只能存储2K。 1）cookie的存取方法 1.存:赋值（键值对） 1document.cookie = "键=值"; //一次只能存一个键值对 2.取：不赋值 12345var v=document.cookie; //取出字符串常用操作：var arr1 = v.split("; ");//分割JSON.stringify(obj); //对象转换为字符串存入JSON.parse(str); //JSON字符串转换为对象取出 3.删：（设置存储有效时长为过去时间） 123var date = new Date();date.setDate(date.getDate()+"设置时长");document.cookie = "key=value;expires="+date.toUTCString(); 2）cookie的优缺点 优点：可控制过期时间，使其不会长期有效可扩展、可用性比较好可加密减少cookie被破解的可能性 缺点：数量和长度有限制，最多20条，最长不能超过40k在请求头上带着数据安全性差 3）cookie的应用场景主要应用：购物车、客户端登录 2.localStoragelocalStorage（本地存储）,可以长期存储数据，没有时间限制，一天，一年，两年甚至更长，数据都可以使用。localStorage中一般浏览器支持的是5M大小，这个在不同的浏览器中localStorage会有所不同 1）使用方法123456localStorage.setItem("key","value");//存储localStorage.getItems(key);//按key进行取值localStorage.removeItems(key);//按key单个删除localStorage.clear();//删除全部数据localStorage.length;//获得数据的数量localStorage.valueOf();//获取全部值 2）优缺点 优点：localStorage拓展了cookie的4k限制localStorage可以将第一次请求的5M大小数据直接存储到本地，相比于cookie可以节约带宽localStorage的使用也是遵循同源策略的，所以不同的网站直接是不能共用相同的localStorage 缺点：需要手动删除，否则长期存在浏览器大小不一，版本的支持也不一样localStorage只支持string类型的存储，JSON对象需要转换localStorage本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡 特点：同源策略限制、只在本地存储、永久保存、同浏览器共享 3）应用场合数据比较大的临时保存方案。如在线编辑文章时的自动保存。多页面访问共同数据。sessionStorage只适用于同一个标签页，localStorage相比而言可以在多个标签页中共享数据。 3.sessionStoragesessionStorage（会话存储），只有在浏览器被关闭之前使用，创建另一个页面时同意可以使用，关闭浏览器之后数据就会消失 1）使用方法123456sessionStorage.setItem("key","value");//存储 sessionStorage.getItems(key);//按key进行取值 sessionStorage.removeItems(key);//按key单个删除 sessionStorage.clear();//删除全部数据 sessionStorage.length;//获得数据的数量 sessionStorage.valueOf();//获取全部值 2）特点 同源策略限制。若想在不同页面之间对同一个sessionStorage进行操作，这些页面必须在同一协议、同一主机名和同一端口下。 单标签页限制。sessionStorage操作限制在单个标签页中，在此标签页进行同源页面访问都可以共享sessionStorage数据。 只在本地存储。seesionStorage的数据不会跟随HTTP请求一起发送到服务器，只会在本地生效，并在关闭标签页后清除数据 存储方式。seesionStorage的存储方式采用key、value的方式。value的值必须为字符串类型(传入非字符串，也会在存储时转换为字符串。)。 存储上限限制。不同的浏览器存储的上限也不一样，但大多数浏览器把上限限制在5MB以下。 3）应用场合sessionStorage 非常适合单页应用程序，可以方便在各业务模块进行传值。 4.localStorange与sessionStorage的相同点和不同点是不敢看完上面两个感觉有点懵，好像一样的？他们还是有所区别的，让我们看看他们的相同点和不同点： 相同点：存值都是以键值对形式存在，值也是存入字符串类型（如果是对象，就序列化以后再存入）；localStorage和sessionStorage使用时使用相同的API；都是用来存储客户端临时信息的对象；解决cookie大小4k的问题；解决请求头常带存储信息的问题；解决关系型存储的问题 不同点：H5的两种存储技术的最大区别就是生命周期。localStorage是本地存储，存储期限不限；sessionStorage是会话存储，页面关闭数据就会丢失。 5. web storage和cookie的区别Web Storage包括localStorange与sessionStorage。它的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小是受限的，并且每次请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可以跨域调用。 除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie，getCookie。 但是Cookie也是不可以或缺的：Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生。 离线缓存Html5 引入了应用程序缓存，这意味着 web 应用可在没有因特网连接时进行访问 为什么要使用离线缓存？应用程序缓存为应用带来的优势： 离线浏览：用户可在应用离线时使用它们 速度：已缓存资源加载速度块 减少服务器负载：浏览器只从服务器下载更新过的资源 2.Application Cache （Manifest）1）使用方法：1. 在html标签添加manifest属性在页面的html标签中添加manifest属性，属性值为manifest文件的路径。如： 1234&lt;!DOCTYPE HTML&gt; &lt;html manifest="../js/demo.manifest"&gt; ...&lt;/html&gt; 2. 编写manifest文件2&gt; 编写manifest文件manifest文件是简单的文本文件，它会告知浏览器需要缓存的内容以及不需要缓存的内容。 manifest文件可分为三部分：(1) CACHE MANIFEST - 在此标题下列出的文件将在首次下载后进行缓存(2)NETWORK - 在此标题下列出的文件需要与服务器的连接，且不会被缓存(3)FALLBACK - 在此标题下列出的文件规定当页面无法访问时的回退页面（比如 404 页面） 简单示例: 12345678CACHE MANIFEST #version 1.1 /*版本号*/ CACHE: html/index.html /*需要缓存的文件*/ NETWORK: js/jquery.js /*不需要缓存的文件*/ FALLBACK: html/index.html /*当页面无法访问时的回退页面*/ 2）注意事项： 浏览器对缓存数据的容量限制可能不太一样 如果manifest文件，或者内部列举的某一个文件不能正常下载，整个更新过程将视为失败，浏览器会继续加载之前的缓存 引用的manifest文件必须和html文件同源，同域 浏览器的自动缓存会导致更改了的html文件必须更新版本才能更新页面 更新版本后，必须刷新一次才会启动新版本 当manifest文件发生改变时，资源请求本身也会触发更新 3)离线缓存与传统浏览器缓存区别：浏览器缓存（Browser Caching）是为了节约网络的资源加速浏览，浏览器在用户磁盘上对最近请求过的文档进行存储，当访问者再次请求这个页面时，浏览器就可以从本地磁盘显示文档，这样就可以加速页面的阅览 区别： 离线缓存是针对整个应用，浏览器缓存是单个文件 离线缓存断网了还是可以打开页面，浏览器缓存不行 离线缓存可以主动通知浏览器更新资源 本地存储和离线存储有什么相同和不同相同：本地存储与离线缓存都是为了方便网页的加载，提高用户体验等。 不同：本地存储一般存储的都是数据，而离线缓存一般存储的是网页等。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>本地存储和离线缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax详细剖析]]></title>
    <url>%2F2019%2F06%2F18%2FAjax%E8%AF%A6%E7%BB%86%E5%89%96%E6%9E%90%2F</url>
    <content type="text"><![CDATA[## 前言 手写Ajax是前端面试常考的，所以对于手写Ajax是很必要的，不过我们不只要会默写更要理解。 基本模板下面是Ajax请求的基本模板12345678var xhr=new XMLHttpRequest();xhr.open("GET",url);xhr.onreadystatechange=function()&#123; if(xhr.readyState==4 &amp;&amp; xhr.status==200)&#123; console.log(xhr.responseText); &#125; &#125;xhr.send(); 理解接下来我们一句一句的来解释一下什么意思。 var xhr=new XMLHttpRequest(); 获取一个XMLHttpRequest 对象，XMLHttpRequest 用于和服务器交换数据。 xhr.open(&quot;GET&quot;,url) open(method,url,async)规定请求的类型、URL 以及是否异步处理请求。method：请求的类型；GET 或 POSTurl：文件在服务器上的位置async：true（异步默认）或 false（同步） 12345xhr.onreadystatechange=function()&#123; if(xhr.readyState==4 &amp;&amp; xhr.status==200)&#123; console.log(xhr.responseText); &#125; &#125; onreadyStateChange事件是在readyState属性发生改变时触发的，readyState的值表示了当前请求的状态，在事件处理程序中可以根据这个值来进行不同的处理。 readyState有五种可取值0：尚未初始化，1：正在加载，2：加载完毕，3：正在处理；4：处理完毕。一旦readyState属性的值变成了4，就可以从服务器返回的响应数据进行访问了。status 返回了XMLHttpRequest 响应中的数字状态码。status 200 代表一个成功的请求。如果服务器响应中没有明确指定status码，XMLHttpRequest.status 将会默认为200。上面代码意思就是：当请求处理完毕并成功的时候打印信息 xhr.send(); send() 方法用于发送 HTTP 请求。如果是异步请求（默认为异步请求），则此方法会在请求发送后立即返回；如果是同步请求，则此方法直到响应到达后才会返回。 GET请求12345678910var xhr=new XMLHttpRequest();var url="http://127.0.0.1:8080/xxx.do?username=testuser&amp;userno=123";xhr.open("GET",url);xhr.onreadystatechange=function()&#123; if(xhr.readyState==4 &amp;&amp; xhr.status==200)&#123; console.log(xhr.responseText); &#125; &#125;xhr.send(); POST请求1234567891011var xhr=new XMLHttpRequest();var url="http://127.0.0.1:8080/xxx.do";xhr.open("POST",url);xhr.setRequestHeader("Content-type","application/www-form-urlencoded")xhr.onreadystatechange=function()&#123; if(xhr.readyState==4 &amp;&amp; xhr.status==200)&#123; console.log(xhr.responseText); &#125; &#125;xhr.send("username=testuser&amp;usernum=123"); 解释一下GET和POST请求的一些区别： setRequestHeader语法：myReq.setRequestHeader(header, value); 通 常在HTTP协议里，客户端像服务器取得某个网页的时候，必须发送一个HTTP协议的头文件，告诉服务器客户端要下载什么信息以及相关的参数。而 XMLHTTP 就是通过HTTP协议取得网站上的文件数据的，所以也要发送HTTP头给服务器。 但是 XMLHTTP 默认的情况下有些参数可能没有说明在HTTP头里，这是当我们需要修改或添加这些参数时就用到了setRequestHeader 方法 一般GET请求不需要设置，因为get的请求直接拼接在url后面，例如：var url=&quot;http://127.0.0.1:8080/xxx.do?username=testuser&amp;userno=123&quot;; 但是post请求一般就需要设置请求头。常见的：CONTENT-TYPE:application/x-www-form-urlencoded含义是表示客户端提交给服务器文本内容的编码方式 是URL编码，即除了标准字符外，每字节以双字节16进制前加个“%”表示 sendGET请求一般直接send()为空，因为GET请求不需要发送数据，请求已经拼接在URL后面了，而POST一般就需要，例如：xhr.send(&quot;username=testuser&amp;usernum=123&quot;);这里send里面写的就是postdata。]]></content>
      <categories>
        <category>Ajax</category>
      </categories>
      <tags>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[双向绑定]]></title>
    <url>%2F2019%2F06%2F18%2F%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[## 前言 单向绑定非常简单，就是把Model绑定到View，当我们用JavaScript代码更新Model时，View就会自动更新。 有单向绑定，就有双向绑定。如果用户更新了View，Model的数据也自动被更新了，这种情况就是双向绑定。 双向绑定什么情况下用户可以更新View呢？填写表单就是一个最直接的例子。当用户填写表单时，View的状态就被更新了，如果此时MVVM框架可以自动更新Model的状态，那就相当于我们把Model和View做了双向绑定：在浏览器中，当用户修改了表单的内容时，我们绑定的Model会自动更新： vue中实现在Vue中，使用双向绑定非常容易，我们先创建一个VM实例： 12345678910$(function () &#123; var vm = new Vue(&#123; el: '#vm', data: &#123; email: '', name: '' &#125; &#125;); window.vm = vm;&#125;); 然后，编写一个HTML FORM表单，并用v-model指令把某个和Model的某个属性作双向绑定： 1234&lt;form id="vm" action="#"&gt; &lt;p&gt;&lt;input v-model="email"&gt;&lt;/p&gt; &lt;p&gt;&lt;input v-model="name"&gt;&lt;/p&gt;&lt;/form&gt; 我们可以在表单中输入内容，然后在浏览器console中用window.vm.$data查看Model的内容，也可以用window.vm.name查看Model的name属性，它的值和FORM表单对应的是一致的。 如果在浏览器console中用JavaScript更新Model，例如，执行window.vm.name=’Bob’，表单对应的内容就会立刻更新。 处理事件当用户提交表单时，传统的做法是响应onsubmit事件，用jQuery获取表单内容，检查输入是否有效，最后提交表单，或者用AJAX提交表单。 现在，获取表单内容已经不需要了，因为双向绑定直接让我们获得了表单内容，并且获得了合适的数据类型。 响应onsubmit事件也可以放到VM中。我们在元素上使用指令： 1&lt;form id="vm" v-on:submit.prevent="register"&gt; 其中，v-on:submit=”register”指令就会自动监听表单的submit事件，并调用register方法处理该事件。使用.prevent表示阻止事件冒泡，这样，浏览器不再处理的submit事件。 因为我们指定了事件处理函数是register，所以需要在创建VM时添加一个register函数： 12345678910111213var vm = new Vue(&#123; el: '#vm', data: &#123; ... &#125;, methods: &#123; register: function () &#123; // 显示JSON格式的Model: alert(JSON.stringify(this.$data)); // TODO: AJAX POST... &#125; &#125;&#125;); 在register()函数内部，我们可以用AJAX把JSON格式的Model发送给服务器，就完成了用户注册的功能。]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>双向绑定</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新版本vue中没有dev-server.js文件，如何进行后台数据模拟？]]></title>
    <url>%2F2019%2F06%2F18%2F%E6%B5%85%E6%9E%90BFC%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BD%9C%E7%94%A8%2F</url>
    <content type="text"><![CDATA[## 什么是BFC 块格式化上下文（Block Formatting Context，BFC） 是Web页面的可视化CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。 怎么创建BFC下列方式会创建块格式化上下文：上面太多了不太好记，主要可以记住以下四种： body 根元素 浮动元素：float 除 none 以外的值 绝对定位元素：position (absolute、fixed) display 为 inline-block、table-cells、flex overflow 除了 visible 以外的值 (hidden、auto、scroll) BFC 特性 使 BFC 内部浮动元素不会到处乱跑； 和浮动元素产生边界。 BFC常见作用1、阻止外边距折叠margin塌陷问题：在标准文档流中，块级标签之间竖直方向的margin会以大的为准，这就是margin的塌陷现象。可以用overflow：hidden产生bfc来解决。 1234567891011&lt;style&gt;div&#123; width: 100px; height: 100px; background: lightblue; margin: 100px;&#125;&lt;/style&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; 从效果上看，因为两个div元素都处于同一个BFC容器下（这里指body元素），所以第一个div的下边距和第二个div的上边距发生了重叠，所以两个盒子之间距离只有100px，而不是200px。 但这不是 CSS 的 bug，我们可以理解为一种规范，如果想要避免外边距的重叠，可以将其放在不同的 BFC 容器中。 123456789101112131415161718192021&lt;style&gt; .content1,.content2&#123; overflow: hidden; &#125; .div1,.div2 &#123; width: 100px; height: 100px; background: lightblue; margin: 100px; &#125; &lt;/style&gt;&lt;body&gt; &lt;div class="content1"&gt; &lt;div class="div1"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="content2"&gt; &lt;div class="div2"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 2、包含浮动元素高度塌陷问题，在通常情况下父元素的高度会被子元素撑开，而在这里因为其子元素为浮动元素所以父元素发生了高度坍塌，上下边界重合，这时就可以用BFC来清除浮动了。 123&lt;div style="border: 1px solid #000;"&gt; &lt;div style="width: 100px;height: 100px;background: grey;float: left;"&gt;&lt;/div&gt;&lt;/div&gt; 由于容器内元素浮动，脱离了文档流，所以容器只剩下2px的边距高度。如果触发容器的BFC，那么容器将会包裹浮动元素。 123&lt;div style="border: 1px solid #000;overflow: hidden"&gt; &lt;div style="width: 100px;height: 100px;background: grey;float: left;"&gt;&lt;/div&gt;&lt;/div&gt; 3、阻止元素被浮动元素覆盖兄弟div浮动问题：由于左侧块级元素发生了浮动，所以和右侧未发生浮动的块级元素不在同一层内，所以会发生div遮挡问题。可以给右侧元素添加 overflow: hidden，触发BFC来解决遮挡问题。 123&lt;div style="height: 100px;width: 100px;float: left;background: lightblue"&gt;我是一个左浮动的元素&lt;/div&gt;&lt;div style="width: 200px; height: 200px;background: grey"&gt;我是一个没有设置浮动, 也没有触发 BFC 元素, width: 200px; height:200px; background: grey;&lt;/div&gt; 这时候其实第二个元素有部分被浮动元素所覆盖，但是文本信息不会被浮动元素所覆盖，如果想避免元素被覆盖，可触发第二个元素的BFC特性，在第二个元素中加入overflow：hidden，就会变成： 123&lt;div style="height: 100px;width: 100px;float: left;background: lightblue"&gt;我是一个左浮动的元素&lt;/div&gt;&lt;div style="width: 200px; height: 200px;background: grey;overflow:hidden"&gt;我是一个没有设置浮动, 也没有触发 BFC 元素, width: 200px; height:200px; background: grey;&lt;/div&gt;]]></content>
      <categories>
        <category>css/html</category>
      </categories>
      <tags>
        <tag>dev-server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单向绑定]]></title>
    <url>%2F2019%2F06%2F18%2F%E5%8D%95%E5%90%91%E7%BB%91%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[## 简单理解 单向绑定非常简单，就是把Model绑定到View，当我们用JavaScript代码更新Model时，View就会自动更新。 MVVM就是在前端页面上，应用了扩展的MVC模式，我们关心Model的变化，MVVM框架自动把Model的变化映射到DOM结构上，这样，用户看到的页面内容就会随着Model的变化而更新。 例如，我们定义好一个JavaScript对象作为Model，并且把这个Model的两个属性绑定到DOM节点上： 经过MVVM框架的自动转换，浏览器就可以直接显示Model的数据了： 下面我们在vue中看看首先，我们就可以在HTML页面中编写JavaScript代码。我们的Model是一个JavaScript对象，它包含两个属性： 1234&#123; name: 'Robot', age: 15&#125; 而负责显示的是DOM节点可以用和来引用Model的属性： 1234&lt;div id="vm"&gt; &lt;p&gt;Hello, &#123;&#123; name &#125;&#125;!&lt;/p&gt; &lt;p&gt;You are &#123;&#123; age &#125;&#125; years old!&lt;/p&gt;&lt;/div&gt; 最后一步是用Vue把两者关联起来。要特别注意的是，在内部编写的JavaScript代码，需要用jQuery把MVVM的初始化代码推迟到页面加载完毕后执行，否则，直接在内执行MVVM代码时，DOM节点尚未被浏览器加载，初始化将失败。正确的写法如下： 12345678910111213141516171819202122232425262728293031323334&lt;html&gt;&lt;head&gt;&lt;!-- 引用jQuery --&gt;&lt;script src="/static/js/jquery.min.js"&gt;&lt;/script&gt;&lt;!-- 引用Vue --&gt;&lt;script src="/static/js/vue.js"&gt;&lt;/script&gt;&lt;script&gt;// 初始化代码:$(function () &#123; var vm = new Vue(&#123; el: '#vm', data: &#123; name: 'Robot', age: 15 &#125; &#125;); window.vm = vm;&#125;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="vm"&gt; &lt;p&gt;Hello, &#123;&#123; name &#125;&#125;!&lt;/p&gt; &lt;p&gt;You are &#123;&#123; age &#125;&#125; years old!&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;html&gt; 其中，el指定了要把Model绑定到哪个DOM根节点上，语法和jQuery类似。这里的’#vm’对应ID为vm的一个\节点 在该节点以及该节点内部，就是Vue可以操作的View。Vue可以自动把Model的状态映射到View上，但是不能操作View范围之外的其他DOM节点。 然后，data属性指定了Model，我们初始化了Model的两个属性name和age，在View内部的\节点上，可以直接用引用Model的某个属性。 一切正常的话，我们在浏览器中访问http://localhost:3000/static/index.html，可以看到页面输出为： 12Hello, Robot!You are 15 years old! 如果打开浏览器console，因为我们用代码window.vm = vm，把VM变量绑定到了window对象上，所以，可以直接修改VM的Model： 1window.vm.name = 'Bob' 执行上述代码，可以观察到页面立刻发生了变化，原来的Hello, Robot!自动变成了Hello, Bob!。Vue作为MVVM框架会自动监听Model的任何变化，在Model数据变化时，更新View的显示。这种Model到View的绑定我们称为单向绑定。]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>单向绑定</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[clientX,screenX,pageX,offsetX的区别]]></title>
    <url>%2F2019%2F06%2F17%2FclientX%2CscreenX%2CpageX%2CoffsetX%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[## 前言 关于clientX,screenX,pageX,offsetX的区别之前也比较迷糊，然后自己写了几个demo算是弄明白了，在这记录一下。 定义一、clientX、clientY点击位置距离当前body可视区域的x，y坐标。可以理解为距离浏览器窗口的距离，但注意这里不包括浏览器的导航栏距离只是浏览器内容区域。 二、pageX、pageY对于整个页面来说，包括了被卷去的body部分的长度相对于文档边缘,包含滚动条距离 三、screenX、screenY点击位置距离当前电脑屏幕的x，y坐标 四、offsetX、offsetY相对于带有定位的父盒子的x，y坐标 贴图下面这张图很清楚的标明了 demo下面来看一个小demo加深理解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; .big&#123; width: 300px; height: 1000px; background-color: greenyellow; margin: 0 auto; position: absolute; &#125; #div&#123; width: 200px; height: 200px; background-color: skyblue; margin: 150px auto; position: relative; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="big"&gt; &lt;div id="div"&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var div = document.getElementById("div") div.onclick = function (e) &#123; console.log('clientY',e.clientY) console.log('screenY',e.screenY) console.log('pageY',e.pageY) console.log('offsetY',e.offsetY) console.log('下一个') &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果图未滚动时：滚动时：]]></content>
      <categories>
        <category>H5/C3</category>
      </categories>
      <tags>
        <tag>clientX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图片验证码的实现方法]]></title>
    <url>%2F2019%2F06%2F17%2F%E5%9B%BE%E7%89%87%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[## 前言 图片验证码是我们日常经常用到的，本文将介绍如何实现以及其原理，并没有过多注重css样式（有些简陋）。如果对滑块验证码感兴趣的可以看这篇文章：滑块验证码实现及原理 实现主要是利用canvas画布加上随机字母，以及适当的旋转，移动，颜色。这一块主要利用的是css3的内容。 对于代码看不懂的可以看注释，注释标注的很详细。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;图片验证码&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id="canvas" width="120" height="40"&gt;&lt;/canvas&gt; &lt;input type="text" id="text"&gt; &lt;input type="button" value="提交" id="bt"&gt; &lt;script&gt; var canvas = document.getElementById("canvas");//演员 var context = canvas.getContext("2d");//舞台，getContext() 方法可返回一个对象，该对象提供了用于在画布上绘图的方法和属性。 var button = document.getElementById("bt");//获取按钮 var input = document.getElementById("text");//获取输入框 draw(); canvas.onclick = function () &#123; context.clearRect(0, 0, 120, 40);//在给定的矩形内清除指定的像素 draw(); &#125; // 随机颜色函数 function getColor() &#123; var r = Math.floor(Math.random() * 256); var g = Math.floor(Math.random() * 256); var b = Math.floor(Math.random() * 256); return "rgb(" + r + "," + g + "," + b + ")"; &#125; function draw() &#123; context.strokeRect(0, 0, 120, 40);//绘制矩形（无填充） var aCode = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"]; // 绘制字母 var arr = [] //定义一个数组用来接收产生的随机数 var num //定义容器接收验证码 for (var i = 0; i &lt; 4; i++) &#123; var x = 20 + i * 20;//每个字母之间间隔20 var y = 20 + 10 * Math.random();//y轴方向位置为20-30随机 var index = Math.floor(Math.random() * aCode.length);//随机索引值 var txt = aCode[index]; context.font = "bold 20px 微软雅黑";//设置或返回文本内容的当前字体属性 context.fillStyle=getColor();//设置或返回用于填充绘画的颜色、渐变或模式，随机 context.translate(x,y);//重新映射画布上的 (0,0) 位置，字母不可以旋转移动，所以移动容器 var deg=90*Math.random()*Math.PI/180;//0-90度随机旋转 context.rotate(deg);// 旋转当前绘图 context.fillText(txt, 0, 0);//在画布上绘制“被填充的”文本 context.rotate(-deg);//将画布旋转回初始状态 context.translate(-x,-y);//将画布移动回初始状态 arr[i] = txt //接收产生的随机数 &#125; num = arr[0] + arr[1] + arr[2] + arr[3] //将产生的验证码放入num // 绘制干扰线条 for (var i = 0; i &lt; 8; i++) &#123; context.beginPath();//起始一条路径，或重置当前路径 context.moveTo(Math.random() * 120, Math.random() * 40);//把路径移动到画布中的随机点，不创建线条 context.lineTo(Math.random() * 120, Math.random() * 40);//添加一个新点，然后在画布中创建从该点到最后指定点的线条 context.strokeStyle=getColor();//随机线条颜色 context.stroke();// 绘制已定义的路径 &#125; // 绘制干扰点，和上述步骤一样，此处用长度为1的线代替点 for (var i = 0; i &lt; 20; i++) &#123; context.beginPath(); var x = Math.random() * 120; var y = Math.random() * 40; context.moveTo(x, y); context.lineTo(x + 1, y + 1); context.strokeStyle=getColor(); context.stroke(); &#125; //点击按钮验证 button.onclick = function () &#123; var text = input.value //获取输入框的值 if (text === num) &#123; alert('验证通过') &#125; else &#123; alert('验证失败') &#125; &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果图]]></content>
      <categories>
        <category>H5/C3</category>
      </categories>
      <tags>
        <tag>图片验证码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[滑块验证码实现及原理]]></title>
    <url>%2F2019%2F06%2F17%2F%E6%BB%91%E5%9D%97%E9%AA%8C%E8%AF%81%E7%A0%81%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[## 前言 滑块验证码也是生活中常见的，本文会介绍如何实现以及原理。如果对图片验证码感兴趣的话可以查看这篇文章：图片验证码的实现方法 实现滑块验证码主要用到几个属性:clientX,screenX,pageX,offsetX,如果对此有疑惑可以查看这篇文章：clientX,screenX,pageX,offsetX的区别 代码的解释在注释中已经写的很清楚了，还不了解的欢迎留言。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;滑块验证码&lt;/title&gt; &lt;style&gt; * &#123; margin: 0px; padding: 0px; font-family: "微软雅黑"; &#125; .drag &#123; width: 300px; height: 40px; line-height: 40px; background-color: #e8e8e8; position: relative; margin: 0 auto; &#125; .bg &#123; width: 40px; height: 100%; position: absolute; background-color: #75CDF9; &#125; .text &#123; position: absolute; width: 100%; height: 100%; text-align: center; user-select: none; &#125; .btn &#123; width: 40px; height: 38px; position: absolute; border: 1px solid #ccc; cursor: move; font-family: "宋体"; text-align: center; background-color: #fff; user-select: none; color: #666; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="drag"&gt; &lt;div class="bg"&gt;&lt;/div&gt; &lt;div class="text" onselectstart="return false"&gt;请拖动滑块解锁&lt;/div&gt; &lt;div class="btn"&gt;&amp;gt;&amp;gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; //一、定义一个获取DOM元素的方法 var $ = function (selector) &#123; return document.querySelector(selector); &#125;, box = $(".drag"),//容器 bg = $(".bg"),//背景 text = $(".text"),//文字 btn = $(".btn"),//滑块 success = false,//是否通过验证的标志 distance = box.offsetWidth - btn.offsetWidth;//滑动成功的宽度（距离） //二、给滑块注册鼠标按下事件 btn.onmousedown = function (e) &#123; //1.鼠标按下之前必须清除掉后面设置的过渡属性 btn.style.transition = ""; bg.style.transition = ""; //说明：clientX 事件属性会返回当事件被触发时，鼠标指针向对于浏览器页面(或客户区)的水平坐标。 //2.当滑块位于初始位置时，得到鼠标按下时的水平位置 var e = e || window.event; var downX = e.clientX; //三、给文档注册鼠标移动事件 document.onmousemove = function (e) &#123; var e = e || window.event;//是为了更好的兼容IE浏览器和非ie浏览器。在ie浏览器中,window.event是全局变量,在非ie中，就需要自己传入一个参数来获取event啦，所以就有了var e = e||window.event //1.获取鼠标移动后的水平位置 var moveX = e.clientX; //2.得到鼠标水平位置的偏移量（鼠标移动时的位置 - 鼠标按下时的位置） var offsetX = moveX - downX; //3.在这里判断一下：鼠标水平移动的距离 与 滑动成功的距离 之间的关系 if (offsetX &gt; distance) &#123; offsetX = distance;//如果滑过了终点，就将它停留在终点位置 &#125; else if (offsetX &lt; 0) &#123; offsetX = 0;//如果滑到了起点的左侧，就将它重置为起点位置 &#125; //4.根据鼠标移动的距离来动态设置滑块的偏移量和背景颜色的宽度 btn.style.left = offsetX + "px"; bg.style.width = offsetX + "px"; //如果鼠标的水平移动距离 = 滑动成功的宽度 if (offsetX == distance) &#123; //1.设置滑动成功后的样式 text.innerHTML = "验证通过"; text.style.color = "#fff"; btn.innerHTML = "&amp;radic;"; btn.style.color = "green"; bg.style.backgroundColor = "lightgreen"; //2.设置滑动成功后的状态 success = true; //成功后，清除掉鼠标按下事件和移动事件（因为移动时并不会涉及到鼠标松开事件） btn.onmousedown = null; document.onmousemove = null; //3.成功解锁后的回调函数 setTimeout(function () &#123; alert('解锁成功！'); &#125;, 100); &#125; &#125; //四、给文档注册鼠标松开事件 document.onmouseup = function (e) &#123; //如果鼠标松开时，滑到了终点，则验证通过 if (success) &#123; return; &#125; else &#123; //反之，则将滑块复位（设置了1s的属性过渡效果） btn.style.left = 0; bg.style.width = 0; btn.style.transition = "left 1s ease"; bg.style.transition = "width 1s ease"; &#125; //只要鼠标松开了，说明此时不需要拖动滑块了，那么就清除鼠标移动和松开事件。 document.onmousemove = null; document.onmouseup = null; &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果图]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>滑块验证码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-router的详细介绍使用]]></title>
    <url>%2F2019%2F06%2F16%2Fvue-router%E7%9A%84%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[## 什么是路由？ 路由，其实就是指向的意思。例如:当我点击页面上的home按钮时，页面中就要显示home的内容，如果点击页面上的about 按钮，页面中就要显示about 的内容。Home按钮 =&gt; home 内容， about按钮 =&gt; about 内容，也可以说是一种映射. 所以在页面上有两个部分，一个是点击部分，一个是点击之后，显示内容的部分。点击之后，怎么做到正确的对应，比如，我点击home 按钮，页面中怎么就正好能显示home的内容。这就要在js 文件中配置路由。 路由的基本概念路由中有三个基本的概念： route, routes, router。 route，它是一条路由，由这个英文单词也可以看出来，它是单数， Home按钮 =&gt; home内容， 这是一条route, about按钮 =&gt; about 内容， 这是另一条路由。 routes 是一组路由，把上面的每一条路由组合起来，形成一个数组。[{home 按钮 =&gt;home内容 }， { about按钮 =&gt; about 内容}] router 是一个机制，相当于一个管理者，它来管理路由。因为routes 只是定义了一组路由，它放在哪里是静止的，当真正来了请求，怎么办？ 就是当用户点击home 按钮的时候，怎么办？这时router 就起作用了，它到routes 中去查找，去找到对应的 home 内容，所以页面中就显示了 home 内容。 客户端中的路由，实际上就是dom 元素的显示和隐藏。当页面中显示home 内容的时候，about 中的内容全部隐藏，反之也是一样。客户端路由有两种实现方式：基于hash 和基于html5 history api. 路由的实现在vue中实现路由还是相对简单的。因为我们页面中所有内容都是组件化的，我们只要把路径和组件对应起来就可以了，然后在页面中把组件渲染出来。 页面实现 html模板中 在vue-router中, 我们定义两个标签\ 和\来对应点击和显示部分。\ 就是定义页面中点击的部分，\ 定义显示部分，就是点击后，区配的内容显示在什么地方。所以 \ 还有一个非常重要的属性 to，定义点击之后，要到哪里去， 如：\Home\ js 中配置路由 首先要定义route, 一条路由的实现。它是一个对象，由两个部分组成： path和component. path 指路径，component 指的是组件。如：{path:’/home’, component: home} 我们这里有两条路由，组成一个routes:1234const routes = [ &#123; path: '/home', component: Home &#125;, &#123; path: '/about', component: About &#125;] 创建router 对路由进行管理，它是由构造函数 new vueRouter() 创建，接受routes 参数。 123const router = new VueRouter(&#123; routes // routes: routes 的简写&#125;) 配置完成后，把router 实例注入到 vue 根实例中,就可以使用路由了 123const app = new Vue(&#123; router&#125;).$mount('#app') 执行过程：当用户点击 router-link 标签时，会去寻找它的 to 属性， 它的 to 属性和 js 中配置的路径{ path: ‘/home’, component: Home} path 一一对应，从而找到了匹配的组件， 最后把组件渲染到 标签所在的地方。所有的这些实现才是基于hash 实现的。 vue-cli 下实现 在src 目录下新建两个组件，home.vue 和 about.vue 123456789101112131415&lt;template&gt; &lt;div&gt; &lt;h1&gt;home&lt;/h1&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data () &#123; return &#123; msg: "我是home 组件" &#125; &#125; &#125;&lt;/script&gt; 123456789101112131415&lt;template&gt; &lt;div&gt; &lt;h1&gt;about&lt;/h1&gt; &lt;p&gt;&#123;&#123;aboutMsg&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data () &#123; return &#123; aboutMsg: '我是about组件' &#125; &#125; &#125;&lt;/script&gt; 在 App.vue中 定义\ 和 \ 123456789101112131415161718&lt;template&gt; &lt;div id="app"&gt; &lt;img src="./assets/logo.png"&gt; &lt;header&gt; &lt;!-- router-link 定义点击后导航到哪个路径下 --&gt; &lt;router-link to="/home"&gt;Home&lt;/router-link&gt; &lt;router-link to="/about"&gt;About&lt;/router-link&gt; &lt;/header&gt; &lt;!-- 对应的组件内容渲染到router-view中 --&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; &#125;&lt;/script&gt; 在 src目录下的index.js定义router, 就是定义 路径到 组件的 映射。 12345678910111213141516171819202122232425import Vue from "vue";import VueRouter from "vue-router";// 引入组件import home from "./home.vue";import about from "./about.vue";// 要告诉 vue 使用 vueRouterVue.use(VueRouter);const routes = [ &#123; path:"/home", component: home &#125;, &#123; path: "/about", component: about &#125;]var router = new VueRouter(&#123; routes&#125;)export default router; 把路由注入到根实例中，启动路由。这里其实还有一种方法，就像vuex store 注入到根实例中一样，我们也可以把vueRouter 直接注入到根实例中。在main.js中引入路由，注入到根实例中。 12345678910import Vue from 'vue'import App from './App.vue'// 引入路由import router from "./router.js" // import router 的router 一定要小写， 不要写成Router, 否则报 can't match的报错new Vue(&#123; el: '#app', router, // 注入到根实例中 render: h =&gt; h(App)&#125;) 最后，我们看一下路由是怎么实现的 打开浏览器控制台，首先看到 router-link 标签渲染成了 a 标签，to 属性变成了a 标签的 href 属性，这时就明白了点击跳转的意思。router-view 标签渲染成了我们定义的组件，其实它就是一个占位符，它在什么地方，匹配路径的组件就在什么地方，所以 router-link 和router-view 标签一一对应，成对出现。 动态路由上面我们定义的路由，都是严格匹配的，只有router-link 中的to属性和 js 中一条路由route中 path 一模一样，才能显示相应的组件component. 但有时现实却不是这样的，当我们去访问网站并登录成功后，它会显示 欢迎你，+ 你的名字。不同的用户登录， 只是显示“你的名字” 部分不同，其它部分是一样的。这就表示，它是一个组件，假设是user组件。不同的用户（就是用户的id不同），它都会导航到同一个user 组件中。这样我们在配置路由的时候，就不能写死, 就是路由中的path属性，不能写死，那要怎么设置? 导航到 user 组件，路径中肯定有user, id 不同，那就给路径一个动态部分来匹配不同的id. 在vue-router中，动态部分 以 : 开头，那么路径就变成了 /user/:id, 这条路由就可以这么写： { path:”/user/:id”, component: user }. 实现动态路由我们定义一个user组件，页面中再添加两个router-link 用于导航， 最后router.js中添加路由配置，来体验一下 app.vue 中添加两个router-link： 12345678910111213&lt;template&gt; &lt;div id="app"&gt; &lt;img src="./assets/logo.png"&gt; &lt;header&gt; &lt;router-link to="/home"&gt;Home&lt;/router-link&gt; &lt;router-link to="/about"&gt;About&lt;/router-link&gt; &lt;!-- 增加两个到user组件的导航，可以看到这里使用了不同的to属性 --&gt; &lt;router-link to="/user/123"&gt;User123&lt;/router-link&gt; &lt;router-link to="/user/456"&gt;User456&lt;/router-link&gt; &lt;/header&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt; index.js 配置user动态路由： 12345678910111213141516171819const routes = [ &#123; path:"/home", component: home &#125;, &#123; path: "/about", component: about &#125;, /*新增user路径，配置了动态的id*/ &#123; path: "/user/:id", component: user &#125;, &#123; path: '/', redirect: '/home' &#125;] user组件 1234567891011&lt;template&gt; &lt;div&gt; &lt;h1&gt;User&lt;/h1&gt; &lt;div&gt;我是user组件&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; &#125;&lt;/script&gt; 这时在页面中点击user123 和user456, 可以看到它们都导航到user组件，配置正确。 在动态路由中，怎么获取到动态部分？ 因为在组件中是可以显示不同部分的，就是上面提到的“你的名字”。其实，当整个vue-router 注入到根实例后，在组件的内部，可以通过this.$route 来获取到 router 实例。它有一个params 属性，就是来获得这个动态部分的。它是一个对象，属性名，就是路径中定义的动态部分 id, 属性值就是router-link中to 属性中的动态部分，如123。使用vuex时，组件中想要获取到state 中的状态，是用computed 属性，在这里也是一样，在组件中，定义一个computed 属性dynamicSegment， user 组件修改如下： 123456789101112131415&lt;template&gt; &lt;div&gt; &lt;h1&gt;User&lt;/h1&gt; &lt;div&gt;我是user组件, 动态部分是&#123;&#123;dynamicSegment&#125;&#125;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; computed: &#123; dynamicSegment () &#123; return this.$route.params.id &#125; &#125; &#125;&lt;/script&gt; 嵌套路由嵌套路由，主要是由我们的页面结构所决定的。当我们进入到home页面的时候，它下面还有分类，如手机系列，平板系列，电脑系列。当我们点击各个分类的时候，它还是需要路由到各个部分，如点击手机，它肯定到对应到手机的部分。 在路由的设计上，首先进入到 home ,然后才能进入到phone, tablet, computer. Phone, tablet, compute 就相当于进入到了home的子元素。所以vue 提供了childrens 属性，它也是一组路由,相当于我们所写的routes。 首先，在home页面上定义三个router-link 标签用于导航，然后再定义一个router-view标签，用于渲染对应的组件。router-link 和router-view 标签要一一对应。home.vue 组件修改如下： 123456789101112&lt;template&gt; &lt;div&gt; &lt;h1&gt;home&lt;/h1&gt;&lt;!-- router-link 的to属性要注意，路由是先进入到home,然后才进入相应的子路由如 phone,所以书写时要把 home 带上 --&gt; &lt;p&gt; &lt;router-link to="/home/phone"&gt;手机&lt;/router-link&gt; &lt;router-link to="/home/tablet"&gt;平板&lt;/router-link&gt; &lt;router-link to="/home/computer"&gt;电脑&lt;/router-link&gt; &lt;/p&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt; index.js 配置路由，修改如下： 12345678910111213141516171819202122232425262728293031323334const routes = [ &#123; path:"/home", // 下面这个属性也不少，因为，我们是先进入home页面，才能进入子路由 component: home, // 子路由 children: [ &#123; path: "phone", component: phone &#125;, &#123; path: "tablet", component: tablet &#125;, &#123; path: "computer", component: computer &#125; ] &#125;, &#123; path: "/about", component: about &#125;, &#123; path: "/user/:id", component: user &#125;, &#123; path: '/', redirect: '/home' &#125;] 这时当我们点击home 时，它下面出现手机等字样，但没有任何对应的组件进行显示，这通常不是我们想要的。要想点击home时，要想渲染相对应的子组件，那还需要配置一条路由。当进入到home 时，它在children中对应的路由path 是空 ‘’，完整的childrens 如下： 12345678910111213141516171819children: [ &#123; path: "phone", component: phone &#125;, &#123; path: "tablet", component: tablet &#125;, &#123; path: "computer", component: computer &#125;, // 当进入到home时，下面的组件显示 &#123; path: "", component: phone &#125;]]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>route</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程思想：面向对象和面向过程]]></title>
    <url>%2F2019%2F06%2F16%2F%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[## 前言 什么是面向对象？面向过程又是什么？对于这编程界的两大思想，一直贯穿在我们学习和工作当中。也许我们心里对这两个概念有个模糊的理解，却又说不出个所以然。 一、面向过程 首先我们来认识下，什么是面向过程？如果咬文嚼字的话可以这样来理解，面向过程就是面向解决问题的过程进行编程。仔细思考一下，我们在学习和工作中，当我们去实现某项功能或完成某项任务时，是不是会不自觉的按部就班的罗列出我们要做的事情？而当我们按着我们罗列的步骤去解决问题时，实质上就是按照面向过程的思想去解决问题。我们罗列的步骤就是过程，按照步骤解决问题就是面向过程。 传统的面向过程的编程思想总结起来就八个字——自顶向下，逐步细化！ 实现步骤如下： 将要实现的功能描述为一个从开始到结束按部就班的连续的步骤（过程）； 依次逐步完成这些步骤，如果某一步的难度较大，又可以将该步骤再次细化为若干个子步骤，以此类推，一直到结束得到想要的结果； 程序的主体是函数，一个函数就是一个封装起来的模块，可以实现一定的功能，各个子步骤往往就是通过各个函数来完成的，从而实现代码的重用和模块化编程！ 面向过程，就是按照我们分析好了的步骤，按部就班的依次执行就行了！所以当我们用面向过程的思想去编程或解决问题时，首先一定要把详细的实现过程弄清楚。一旦过程设计清楚，代码的实现简直轻而易举。 二、面向对象 讨论完了面向过程，我们再来认识下面向对象。所谓的面向对象，就是在编程的时候尽可能的去模拟真实的现实世界，按照现实世界中的逻辑去处理一个问题，分析问题中参与其中的有哪些实体，这些实体应该有什么属性和方法，我们如何通过调用这些实体的属性和方法去解决问题。当我们使用面向对象进行编程时，一定要建立这样一个观念：万物皆对象！ 现实世界中，任何一个操作或者是业务逻辑的实现都需要一个实体来完成，也就是说，实体就是动作的支配者，没有实体，就肯定没有动作发生！ 有动词就一定有实现这个动作的实体！ 所谓的模拟现实世界，就是使计算机的编程语言在解决相关业务逻辑的方式，与真实的业务逻辑的发生保持一致！需要使每一个动作的背后都一个完成这个动作的实体！ 因为任何功能的实现都是依赖于一个具体的实体的“动作|操作|行动”，可以看作是一个又一个的实体在发挥其各自的“能力”并在内部进行协调有序的调用过程！ 当采用面向对象的思想解决问题时，可分为下面几步： 分析哪些动作是由哪些实体发出的； 定义这些实体，为其增加相应的属性和功能； 让实体去执行相应的功能或动作。 贴图加深理解 这张图里就把苹果放进冰箱这件事，分别用面向过程和面向对象来实现。面向过程更像是我们日常的行为一步一步的做，站在第一人称视角；而面向对象，把冰箱和人看成两个对象，赋予特定行为和属性，类似于第三人称视角。 三、面向对象和面向过程的比较在我们将面向过程和面向对象讨论完后，会明显的感觉两者之间有着很大的区别。面向过程简单直接，易于入门理解，模块化程度较低。而面向对象相对于面向过程较为复杂，不易理解，模块化程度较高。可总结为下面三点： 都可以实现代码重用和模块化编程，但是面对对象的模块化更深，数据更封闭，也更安全！因为面向对象的封装性更强！ 面对对象的思维方式更加贴近于现实生活，更容易解决大型的复杂的业务逻辑 从前期开发角度上来看，面对对象远比面向过程要复杂，但是从维护和扩展功能的角度上来看，面对对象远比面向过程要简单！ 如何选择面向对象还是面向过程，对于一个有着丰富开发经验的老手来说，这是个得心应手的过程。而对于一个新手而言，其实从两者的对比就可以看出，当我们的业务逻辑比较简单时，使用面向过程能更快的实现。但是当我们的业务逻辑比较复杂时，为了将来的维护和扩展，还是面向对象更为靠谱点！]]></content>
      <categories>
        <category>编程思想</category>
      </categories>
      <tags>
        <tag>面向对象和面向过程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3动画]]></title>
    <url>%2F2019%2F06%2F16%2Fcss3%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[## 什么是 CSS3 中的动画？ 动画是使元素从一种样式逐渐变化为另一种样式的效果。 您可以改变任意多的样式任意多的次数。 @keyframes 语法：@keyframes animationname {keyframes-selector {css-styles;}} 通过 @keyframes 规则，您能够创建动画。 创建动画的原理是，将一套 CSS 样式逐渐变化为另一套样式。 在动画过程中，您能够多次改变这套 CSS 样式。 以百分比来规定改变发生的时间，或者通过关键词 “from” 和 “to”，等价于 0% 和 100%。 0% 是动画的开始时间，100% 动画的结束时间。 为了获得最佳的浏览器支持，您应该始终定义 0% 和 100% 选择器。 CSS3 动画属性 实例运行名为 myfirst 的动画，其中设置了所有动画属性：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; div &#123; width: 100px; height: 100px; background: red; position: relative; animation-name: myfirst; animation-duration: 5s; animation-timing-function: linear; animation-delay: 2s; animation-iteration-count: infinite; /* 规定动画应该无限次播放。 */ animation-direction: alternate; /*动画应该轮流反向播放。*/ animation-play-state: running; /*规定动画正在播放。*/ &#125; @keyframes myfirst &#123; 0% &#123; background: red; left: 0px; top: 0px; &#125; 25% &#123; background: yellow; left: 200px; top: 0px; &#125; 50% &#123; background: blue; left: 200px; top: 200px; &#125; 75% &#123; background: green; left: 0px; top: 200px; &#125; 100% &#123; background: red; left: 0px; top: 0px; &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 另外一种简洁写法： 1234div&#123; animation: myfirst 5s linear 2s infinite alternate;&#125;]]></content>
      <categories>
        <category>H5/C3</category>
      </categories>
      <tags>
        <tag>css3动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis与mysql的区别和使用]]></title>
    <url>%2F2019%2F06%2F13%2Fredis%E4%B8%8Emysql%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[## 区别 类型 redis是一个key-value存储系统,是nosql,即非关系型数据库,和memcached都是缓存数据库. mysql是关系型数据库 存储 redis用于存储使用相对频繁的数据到内存中, mysql用于存放持久化数据到磁盘中 速度 redis读取速度快 mysql相对速度较慢 数据类型 redis数据类型:字符串类型（string），散列类型（hash），列表类型（list），集合类型（set），有序集合类型（zset） mysql数据类型,大致三类:数值,日期,字符使用一般来说，mysql用于写入和更新，redis用于读取。 这样就说 mysql-&gt;redis的同步用的比较多。 mysql作为数据持久化和管理比redis好太多，redis大多只用来做 数据读取缓存、队列、锁、等等的使用. 因为需求的不同，要根据具体业务场景去选型,一般都是配合使用.]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs连接mysql]]></title>
    <url>%2F2019%2F06%2F11%2Fnodejs%E8%BF%9E%E6%8E%A5mysql%2F</url>
    <content type="text"><![CDATA[## nodejs连接mysql 想要成为一个全栈工程师，自然需要会后端，那nodejs连接mysql就更不能不会了。 首先安装sql依赖：npm i sql 编写代码连接 1234567891011121314151617181920212223242526const mysql = require('mysql')// 创建链接对象const con = mysql.createConnection(&#123; host: 'localhost', user: 'root', password: '123456', port: '3306', database: 'myblog'&#125;)// 开始链接con.connect()// 执行 sql 语句const sql = 'select * from users;'con.query(sql,(err,result)=&gt; &#123; if(err)&#123; console.error(err) return &#125; console.log(result)&#125;)// 关闭链接con.end() 运行 ：node index.js 如果遇到报错： Client does not support authentication protocol requested by server 可看这篇文章:连接MySQL报错：Client does not support authentication protocol requested by server]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>nodejs连接mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[连接MySQL报错：Client does not support authentication protocol requested by server]]></title>
    <url>%2F2019%2F06%2F11%2F%E8%BF%9E%E6%8E%A5MySQL%E6%8A%A5%E9%94%99%EF%BC%9AClient%20does%20not%20support%20authentication%20protocol%20requested%20by%20server%2F</url>
    <content type="text"><![CDATA[## 在使用nodejs连接MySQL报错： Client does not support authentication protocol requested by server; consider upgrading MySQL client大概意思是：客户端不支持服务器请求的身份验证协议;考虑升级MySQL客户端 原因：将mysql升级到5.x版本后，用客户端登录时出现了 Client does not support authentication protocol requested by server错误，是由于新旧版本的mysql的密码算法不同引起 解决方法如下：登录mysql，输入如下命令即可。 12alter user 'root'@'localhost' identified with mysql_native_password by '123456';flush privileges; 这样就能解决这个问题了。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL报错</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP的三次握手与四次挥手 TCP]]></title>
    <url>%2F2019%2F06%2F09%2FTCP%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%2F</url>
    <content type="text"><![CDATA[## TCP的位置 TCP工作在网络OSI的七层模型中的第四层——Transport层，IP在第三层——Network层，ARP在第二层——Data Link层； 在第二层上的数据，我们把它叫Frame，在第三层上的数据叫Packet，第四层的数据叫Segment。 数据从应用层发下来，会在每一层都会加上头部信息，进行封装，然后再发送到数据接收端。这个基本的流程你需要知道，就是每个数据都会经过数据的封装和解封装的过程。 在OSI七层模型中，每一层的作用和对应的协议如下： 三次握手第一次握手：主机A发送位码为syn＝1,随机产生seq number=x的数据包到服务器，客户端进入SYN_SEND状态，等待服务器的确认；主机B由SYN=1知道，A要求建立联机； 第二次握手：主机B收到请求后要确认联机信息，向A发送ack number(主机A的seq+1),syn=1,ack=1,随机产生seq=y的包,此时服务器进入SYN_RECV状态; 第三次握手：主机A收到后检查ack number是否正确，即第一次发送的seq number+1,以及位码ack是否为1，若正确，主机A会再发送ack number(主机B的seq+1),ack=1，主机B收到后确认seq值与ack=1则连接建立成功。客户端和服务器端都进入ESTABLISHED状 态，完成TCP三次握手。 TCP位码,有6种标示:SYN(synchronous建立联机) ACK(acknowledgement 确认) PSH(push传送) FIN(finish结束) RST(reset重置) URG(urgent紧急) Sequence number(顺序号码) Acknowledge number(确认号码) 四次挥手第一次挥手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了； 第二次挥手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我也没有数据要发送了，可以进行关闭连接了； 第三次挥手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入CLOSE_WAIT状态； 第四次挥手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。 问题1.为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？ 虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。 2.client发送完最后一个ack之后，进入time_wait状态，但是他怎么知道server有没有收到这个ack呢？莫非sever也要等待一段时间，如果收到了这个ack就close，如果没有收到就再发一个fin给client？这么说server最后也有一个time_wait哦？求解答！ 因为网络原因，主动关闭的一方发送的这个ACK包很可能延迟，从而触发被动连接一方重传FIN包。极端情况下，这一去一回，就是两倍的MSL时长。如果主动关闭的一方跳过TIME_WAIT直接进入CLOSED，或者在TIME_WAIT停留的时长不足两倍的MSL，那么当被动 关闭的一方早先发出的延迟包到达后，就可能出现类似下面的问题：1.旧的TCP连接已经不存在了，系统此时只能返回RST包2.新的TCP连接被建立起来了，延迟包可能干扰新的连接，这就是为什么time_wait需要等待2MSL时长的原因。]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[一张图理清Vue中的生命周期和钩子函数]]></title>
    <url>%2F2019%2F06%2F04%2F%E4%B8%80%E5%BC%A0%E5%9B%BE%E7%90%86%E6%B8%85Vue%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[## 前言 Vue 框架的入口就是 Vue 实例，其实就是框架中的 view model ，它包含页面中的业务处理逻辑、数据模型等，它的生命周期中有多个事件钩子，让我们在控制整个Vue实例的过程时更容易形成好的逻辑。 贴图下面的图片是在官方文档的图片上进行了解释说明，帮大家更好的理解这张图。 代码贴上一个小案例辅助理解 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src="lib/vue.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="app"&gt; &lt;input type="button" value="修改" @click="msg='no'"&gt; &lt;h3 id="h3"&gt;&#123;&#123; msg &#125;&#125;&lt;/h3&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el:'#app', data:&#123; msg:'ok' &#125;, methods:&#123; show()&#123; console.log('执行了show方法'); &#125; &#125;, beforeCreate()&#123;// 这是我们遇到的第一个生命周期函数，表示实例完全被创建出来之前，会执行它// console.log(this.msg);// this.show() // 注意： 在 beforeCreate 生命周期函数执行的时候，data 和 methods 中的 数据都还没有没初始化 &#125;, created()&#123; // 这是遇到的第二个生命周期函数 console.log(this.msg); this.show() &#125;, beforeMount()&#123; // 这是遇到的第3个生命周期函数，表示 模板已经在内存中编辑完成了，但是尚未把 模板渲染到 页面中 console.log(document.getElementById('h3').innerText); // 在 beforeMount 执行的时候，页面中的元素，还没有被真正替换过来，只是之前写的一些模板字符串 &#125;, mounted()&#123; // 这是遇到的第4个生命周期函数，表示，内存中的模板，已经真实的挂载到了页面中，用户已经可以看到渲染好的页面了 console.log(document.getElementById('h3').innerText); // 注意： mounted 是 实例创建期间的最后一个生命周期函数，当执行完 mounted 就表示，实例已经被完全创建好了，此时， // 03如果没有其它操作的话，这个实例，就静静的 躺在我们的内存中，一动不动 &#125;, // 接下来的是运行中的两个事件 beforeUpdate()&#123; // 这时候，表示 我们的界面还没有被更新【数据被更新了吗？ 数据肯定被更新了】 console.log('界面上元素的内容：'+document.getElementById('h3').innerText); console.log(' data中的msg数据是：'+ this.msg); // 得出结论： 当执行 beforeUpdate 的时候，页面中的显示的数据，还是旧的，此时 data 数据是最新的，页面尚未和 最新的数据保持同步 &#125;, updated()&#123; console.log('界面上元素的内容：'+document.getElementById('h3').innerText); console.log(' data中的msg数据是：'+ this.msg); &#125; &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>生命周期和钩子函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新版本vue中没有dev-server.js文件，如何进行后台数据模拟？]]></title>
    <url>%2F2019%2F06%2F04%2F%E6%96%B0%E7%89%88%E6%9C%ACvue%E4%B8%AD%E6%B2%A1%E6%9C%89dev-server.js%E6%96%87%E4%BB%B6%EF%BC%8C%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%90%8E%E5%8F%B0%E6%95%B0%E6%8D%AE%E6%A8%A1%E6%8B%9F%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[## 前言 今天在写一个vue项目时，发现build中并没有dev-server.js文件，那如何进行后台数据模拟呢？ 解决方法最新的vue里dev-server.js被替换成了webpack-dev-conf.js 在模拟后台数据的时候直接在webpack-dev-conf.js文件中修改 第一步:在const portfinder = require(‘portfinder’)后面添加1234const express = require('express') const app = express()//请求servervar appData = require('../data.json')//加载本地数据文件var seller = appData.seller//获取对应的本地数据var goods = appData.goods var ratings = appData.ratings var apiRoutes = express.Router() app.use('/api', apiRoutes)//通过路由请求数据 第二步：找到devServer,在里面加上before（）方法1234567891011121314151617181920212223242526272829303132333435363738devServer: &#123; clientLogLevel: 'warning', historyApiFallback: true, hot: true, compress: true, host: HOST || config.dev.host, port: PORT || config.dev.port, open: config.dev.autoOpenBrowser, overlay: config.dev.errorOverlay ? &#123; warnings: false, errors: true &#125; : false, publicPath: config.dev.assetsPublicPath, proxy: config.dev.proxyTable, quiet: true, // necessary for FriendlyErrorsPlugin watchOptions: &#123; poll: config.dev.poll, &#125;, //第二步找到devServer,在里面添加before(app) &#123; app.get('/api/seller', (req, res) =&gt; &#123; res.json(&#123; errno: 0, data: seller &#125;)//接口返回json数据，上面配置的数据seller就赋值给data请求后调用 &#125;), app.get('/api/goods', (req, res) =&gt; &#123; res.json(&#123; errno: 0, data: goods &#125;) &#125;), app.get('/api/ratings', (req, res) =&gt; &#123; res.json(&#123; errno: 0, data: ratings &#125;) &#125;)&#125; 注意：要确保项目根目录有data.json，这里提供一个json数据1234567891011121314151617181920212223242526272829303132333435363738&#123; "seller": &#123; "name": "粥品香坊（回龙观）", "description": "蜂鸟专送", "deliveryTime": 38, "score": 4.2, "serviceScore": 4.1, "foodScore": 4.3, "rankRate": 69.2, "minPrice": 20, "deliveryPrice": 4, "ratingCount": 24, "sellCount": 90, "bulletin": "粥品香坊其烹饪粥料的秘方源于中国千年古法，在融和现代制作工艺，由世界烹饪大师屈浩先生领衔研发。坚守纯天然、0添加的良心品质深得消费者青睐，发展至今成为粥类的引领品牌。是2008年奥运会和2013年园博会指定餐饮服务商。", "supports": [ &#123; "type": 0, "description": "在线支付满28减5" &#125;, &#123; "type": 1, "description": "VC无限橙果汁全场8折" &#125;, &#123; "type": 2, "description": "单人精彩套餐" &#125;, &#123; "type": 3, "description": "该商家支持发票,请下单写好发票抬头" &#125;, &#123; "type": 4, "description": "已加入“外卖保”计划,食品安全保障" &#125; ], "avatar": "http://static.galileo.xiaojukeji.com/static/tms/seller_avatar_256px.jpg", "pics": [ "http://fuss10.elemecdn.com/8/71/c5cf5715740998d5040dda6e66abfjpeg.jpeg?imageView2/1/w/180/h/180", "http://fuss10.elemecdn.com/b/6c/75bd250e5ba69868f3b1178afbda3jpeg.jpeg?imageView2/1/w/180/h/180", "http://fuss10.elemecdn.com/f/96/3d608c5811bc2d902fc9ab9a5baa7jpeg.jpeg?imageView2/1/w/180/h/180", "http://fuss10.elemecdn.com/6/ad/779f8620ff49f701cd4c58f6448b6jpeg.jpeg?imageView2/1/w/180/h/180" ], "infos": [ "该商家支持发票,请下单写好发票抬头", "品类:其他菜系,包子粥店", "北京市昌平区回龙观西大街龙观置业大厦底商B座102单元1340", "营业时间:10:00-20:30" ] &#125;&#125;]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>dev-server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mock数据时，http___localhost_8080_#_api_goods 无法访问到数据]]></title>
    <url>%2F2019%2F06%2F04%2Fmock%E6%95%B0%E6%8D%AE%E6%97%B6%EF%BC%8Chttp___localhost_8080_%23_api_goods%20%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE%E5%88%B0%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[## 前言 在mock数据时，http://localhost:8080/#/api/goods 无法访问到数据，经过查询发现是将build目录下的webpack.dev.conf.js文件出问题了 解决将build目录下的webpack.dev.conf.js文件改为： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102'use strict'const utils = require('./utils')const webpack = require('webpack')const config = require('../config')const merge = require('webpack-merge')const baseWebpackConfig = require('./webpack.base.conf')const HtmlWebpackPlugin = require('html-webpack-plugin')const FriendlyErrorsPlugin = require('friendly-errors-webpack-plugin')const portfinder = require('portfinder') const appData = require('../data.json')const seller = appData.sellerconst goods = appData.goodsconst ratings = appData.ratings const devWebpackConfig = merge(baseWebpackConfig, &#123; module: &#123; rules: utils.styleLoaders(&#123; sourceMap: config.dev.cssSourceMap, usePostCSS: true &#125;) &#125;, // cheap-module-eval-source-map is faster for development devtool: config.dev.devtool, // these devServer options should be customized in /config/index.js devServer: &#123; before(app) &#123; app.get('/api/seller', function(req, res) &#123; res.json(&#123; errno: 0, data: seller &#125;) &#125;); app.get('/api/goods', function(req, res) &#123; res.json(&#123; errno: 0, data: goods &#125;) &#125;); app.get('/api/ratings', function(req, res) &#123; res.json(&#123; errno: 0, data: ratings &#125;) &#125;); &#125;, clientLogLevel: 'warning', historyApiFallback: true, hot: true, host: process.env.HOST || config.dev.host, port: process.env.PORT || config.dev.port, open: config.dev.autoOpenBrowser, overlay: config.dev.errorOverlay ? &#123; warnings: false, errors: true, &#125; : false, publicPath: config.dev.assetsPublicPath, proxy: config.dev.proxyTable, quiet: true, // necessary for FriendlyErrorsPlugin watchOptions: &#123; poll: config.dev.poll, &#125; &#125;, plugins: [ new webpack.DefinePlugin(&#123; 'process.env': require('../config/dev.env') &#125;), new webpack.HotModuleReplacementPlugin(), new webpack.NamedModulesPlugin(), // HMR shows correct file names in console on update. new webpack.NoEmitOnErrorsPlugin(), // https://github.com/ampedandwired/html-webpack-plugin new HtmlWebpackPlugin(&#123; filename: 'index.html', template: 'index.html', inject: true &#125;), ]&#125;) module.exports = new Promise((resolve, reject) =&gt; &#123; portfinder.basePort = process.env.PORT || config.dev.port portfinder.getPort((err, port) =&gt; &#123; if (err) &#123; reject(err) &#125; else &#123; // publish the new Port, necessary for e2e tests process.env.PORT = port // add port to devServer config devWebpackConfig.devServer.port = port // Add FriendlyErrorsPlugin devWebpackConfig.plugins.push(new FriendlyErrorsPlugin(&#123; compilationSuccessInfo: &#123; messages: [`Your application is running here: http://$&#123;config.dev.host&#125;:$&#123;port&#125;`], &#125;, onErrors: config.dev.notifyOnErrors ? utils.createNotifierCallback() : undefined &#125;)) resolve(devWebpackConfig) &#125; &#125;)&#125;) 注意如果devServer下面的before(app)里面的内容要根据自己数据名称进行修改，修改时文件头部const也要跟着一起修改。]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>mock数据</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue组件间传值]]></title>
    <url>%2F2019%2F06%2F04%2FVue%E7%BB%84%E4%BB%B6%E9%97%B4%E4%BC%A0%E5%80%BC%2F</url>
    <content type="text"><![CDATA[# Vue组件间传值 父组件向子组件传递数据在 Vue 中，通过 props 向子组件传递数据。 子组件部分：123456789&lt;template&gt; &lt;header class="header"&gt; &lt;div id="1ogo"&gt;&#123;&#123;1ogo&#125;&#125;&lt;/div&gt; &lt;ul class="nav"&gt; &lt;li v-for="nav in navs"&gt;&#123;&#123;nav.li&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/header&gt;&lt;/template&gt; 这是 header.vue 的 HTML 部分，logo 是在 data 中定义的变量。如果需要从父组件获取 logo 的值，就需要使用 props: [‘logo’] 123456789101112&lt;script&gt; export default&#123; name:'headerDiv', data()&#123; return&#123; navs:[ &#123;1i:'主页'&#125;,&#123;1i:'日志'&#125;,&#123;1i:'说说'&#125;,&#123;1i:'主页'&#125;,&#123;1i:'相册&#125; ] &#125;, props:['logo'] &#125;&lt;/script&gt; 父组件部分：12345&lt;template&gt; &lt;div id="app"&gt; &lt;HeaderDiv :logo="logoMsg"&gt;&lt;/HeaderDiv&gt; &lt;/div&gt;&lt;/template&gt; 在调用组件的时候，使用 v-bind 将 logo 的值绑定为 App.vue 中定义的变量 logoMsg 1234567891011121314&lt;script&gt; import HeaderDiv from'./components/header' export default&#123; name:'app', data()&#123; return&#123; logoMsg:'WiseWrong' &#125; &#125;, components:&#123; HeaderDiv &#125; &#125;&lt;/script&gt; 然后就能将App.vue中 logoMsg 的值传给 header.vue 了： 子组件向父组件传递数据子组件主要通过事件传递数据给父组件 子组件部分12345678910&lt;template&gt; &lt;section&gt; &lt;div class="login"&gt; &lt;label&gt; &lt;span&gt;用户名：&lt;/span&gt; &lt;input v-model="username"@change="setUser"/&gt; &lt;/label&gt; &lt;div&gt; &lt;/section&gt;&lt;/template&gt; 这是 login.vue 的 HTML 部分，当的值发生变化的时候，将 username 传递给 App.vue首先声明一个了方法 setUser，用 change 事件来调用 setUser123456789101112131415&lt;script&gt; export default&#123; name:' login', data()&#123; return&#123; username:'' &#125; &#125;, methods:&#123; setUser: function()&#123; this.$emit(' transferUser', this. username) &#125; &#125; &#125;&lt;/script&gt; 在 setUser 中，使用了 $emit 来遍历 transferUser 事件，并返回 this.username其中 transferUser 是一个自定义的事件，功能类似于一个中转，this.username 将通过这个事件传递给父组件 父组件部分123456&lt;template&gt; &lt;div id="app"&gt; &lt;LoginDiv @transferUser="getUser"&gt;&lt;/LoginDiv&gt; &lt;p&gt;用户名为：&#123;&#123;user&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt; 在父组件 App.vue 中，声明了一个方法 getUser，用 transferUser 事件调用 getUser 方法，获取到从子组件传递过来的参数 username1234567891011121314151617&lt;script&gt; import LoginDiv from'./components/login' export default &#123; name:' app', data()&#123; return&#123; user:'' &#125; &#125;, methods:&#123; getUser(msg)&#123; this. user=msg &#125;, components:&#123; LoginDiv &#125; &#125;&lt;/script&gt; getUser 方法中的参数 msg 就是从子组件传递过来的参数 username]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>组件间传值</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js 2.0 中#$on与$emit如何理解使用]]></title>
    <url>%2F2019%2F06%2F04%2FVue.js%202.0%20%E4%B8%AD%23%24on%E4%B8%8E%24emit%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[## 先看看官方文档的解释 vm.$on( event, callback ) 参数 {string | Array} event (数组只在 2.2.0+ 中支持) {Function} callback 用法 监听当前实例上的自定义事件。事件可以由vm.$emit触发。回调函数会接收所有传入事件触发函数的额外参数。 示例 12345vm.$on('test', function (msg) &#123; console.log(msg)&#125;)vm.$emit('test', 'hi')// =&gt; "hi" 这里$emit监听test事件，附加参数（hi）都会传给监听器回调。然后$on和$emit监听同一个事件，接收到$emit传过来的数据（hi），然后通过回调函数打印出来。 vm.$emit( eventName, […args] ) 参数 {string} eventName […args] 用法 触发当前实例上的事件。附加参数都会传给监听器回调。 示例 先定义一个计数组件123456789101112131415161718192021Vue.component('simple-com',&#123; template:'&lt;button v-on:click="incresone"&gt;&#123;&#123;count&#125;&#125;&lt;/button&gt;', data:function()&#123; return &#123; count:0 &#125; &#125;, methods:&#123; incresone:function()&#123; this.count+=1 //监听自定义的事件 this.$on('increment',function(msg)&#123; //获取$emit方法传递的第二个参数 console.log(msg); alert("1"); &#125;) //触发自定义的事件 this.$emit('increment',this.count) &#125; &#125; &#125;) 使用组件 1234&lt;simple-com v-on:increment="incretol"&gt;&lt;/simple-com&gt;&lt;simple-com v-on:increment="incretol"&gt;&lt;/simple-com&gt;&lt;simple-com v-on:increment="incretol"&gt;&lt;/simple-com&gt;&lt;p&gt;&#123;&#123;total&#125;&#125;&lt;/p&gt; 实例化vue的代码 1234567891011var vm = new Vue(&#123; el:"#app", data: &#123; total:0 &#125; methods:&#123; incretol:function()&#123; this.total+=1 &#125; &#125;&#125;) 当我点击计数的时候，$on监听increment事件，当increment事件执行时，便会弹出1，然后再继续执行后面的代码。]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>$on和$emit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue2.x过渡(transition)与动画(animationend)]]></title>
    <url>%2F2019%2F06%2F04%2Fvue2.x%E8%BF%87%E6%B8%A1(transition)%E4%B8%8E%E5%8A%A8%E7%94%BB(animationend)%2F</url>
    <content type="text"><![CDATA[## transition Vue 提供了 transition 的封装组件，在下列情形中，可以给任何元素和组件添加进入/离开过渡 条件渲染 (使用 v-if) 条件展示 (使用 v-show) 动态组件 组件根节点 示例： 12345678&lt;div id="demo"&gt; &lt;button v-on:click="show = !show"&gt; Toggle &lt;/button&gt; &lt;transition name="fade"&gt; &lt;p v-if="show"&gt;hello&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt; 123456new Vue(&#123; el: '#demo', data: &#123; show: true &#125;&#125;) 123456.fade-enter-active, .fade-leave-active &#123; transition: opacity .5s;&#125;.fade-enter, .fade-leave-to /* .fade-leave-active below version 2.1.8 */ &#123; opacity: 0;&#125; 点击Toggle按钮实现淡入淡出 过渡的类名在进入/离开的过渡中，会有 6 个 class 切换。 1.v-enter：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除。 2.v-enter-active：定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。 3.v-enter-to: 2.1.8版及以上 定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 v-enter 被移除)，在过渡/动画完成之后移除。 4.v-leave: 定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。 5.v-leave-active：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。 6.v-leave-to: 2.1.8版及以上 定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 v-leave 被删除)，在过渡/动画完成之后移除。 贴图方便理解 对于这些在过渡中切换的类名来说，如果你使用一个没有名字的 \，则 v- 是这些类名的默认前缀。如果你使用了 \，那么 v-enter 会替换为 my-transition-enter。v-enter-active 和 v-leave-active 可以控制进入/离开过渡的不同的缓和曲线。 小例子12345678&lt;div id="example-1"&gt; &lt;button @click="show = !show"&gt; Toggle render &lt;/button&gt; &lt;transition name="slide-fade"&gt; &lt;p v-if="show"&gt;hello&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt; 123456new Vue(&#123; el: '#example-1', data: &#123; show: true &#125;&#125;) 12345678910111213/* 可以设置不同的进入和离开动画 *//* 设置持续时间和动画函数 */.slide-fade-enter-active &#123; transition: all .3s ease;&#125;.slide-fade-leave-active &#123; transition: all .8s cubic-bezier(1.0, 0.5, 0.8, 1.0);&#125;.slide-fade-enter, .slide-fade-leave-to/* .slide-fade-leave-active for below version 2.1.8 */ &#123; transform: translateX(10px); opacity: 0;&#125; 点击按钮实现hello向右缓动消失，在点击向左缓动出现 CSS 动画CSS 动画用法同 CSS 过渡，区别是在动画中 v-enter 类名在节点插入 DOM 后不会立即删除，而是在 animationend 事件触发时删除。 示例：(省略了兼容性前缀) 123456&lt;div id="example-2"&gt; &lt;button @click="show = !show"&gt;Toggle show&lt;/button&gt; &lt;transition name="bounce"&gt; &lt;p v-if="show"&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris facilisis enim libero, at lacinia diam fermentum id. Pellentesque habitant morbi tristique senectus et netus.&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt; 123456new Vue(&#123; el: '#example-2', data: &#123; show: true &#125;&#125;) 1234567891011121314151617.bounce-enter-active &#123; animation: bounce-in .5s;&#125;.bounce-leave-active &#123; animation: bounce-in .5s reverse;&#125;@keyframes bounce-in &#123; 0% &#123; transform: scale(0); &#125; 50% &#123; transform: scale(1.5); &#125; 100% &#123; transform: scale(1); &#125;&#125; 点击按钮，这段文本内容或弹跳出现，在点击弹跳消失]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>transition,animationend</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解设备像素比devicePixelRatio]]></title>
    <url>%2F2019%2F06%2F04%2F%E7%90%86%E8%A7%A3%E8%AE%BE%E5%A4%87%E5%83%8F%E7%B4%A0%E6%AF%94devicePixelRatio%2F</url>
    <content type="text"><![CDATA[## 定义 window.devicePixelRatio是设备上物理像素和设备独立像素(device-independent pixels (dips))的比例。公式表示就是：window.devicePixelRatio = 物理像素 / dips 理解移动端的设备多种多样，不同的设备又有不同的分辨率，低一点的有 800 400，中等的有 1280 720，高的有 1920 * 1080，甚至还有更高的 4k 屏等。我们在开发移动端页面时，将视口（viewport）设置为设备宽度（device-width）后，同一份页面在这些不同的设备上会出现相同的表现。为什么这些设备拥有不同的分辨率，而在渲染页面时表现都一样呢？其实这是由设备像素比造成的。设备像素比是怎么发挥作用的呢？要理解这个问题，需要三块预备知识： 设备独立像素 DPI/PPI CSS 中的像素 设备独立像素设备的独立像素是和设备的分辨率相关联的，比如 IPhone6 的分辨率为 1334 750，那么表示该手机的屏幕上有 1366 750 个物理像素，而 Galaxy S5 的屏幕上有 1280*720 个像素。 PPI/DPI表示每英寸所包含的像素点数目，数值越高，说明屏幕能以更高密度显示图像 计算公式——以 IPhone6 为例，可以计算出的 IPhone6 的 PPI 为：325.16。该结果表示在 IPhone6 上，每英寸有 325.16 个物理像素，四舍五入为 325 个物理像素。可以发现：这个 PPI 的值近似等于 IPhone6 这个设备的水平物理像素的一半，也即： 1750 / 325 = 2 这个由设备水平物理像素和设备 PPI/DPI 计算出来出来的比值就是设备像素比。 CSS 中的像素CSS 中的像素是一个相对值，不是绝对值，因此1px 的 CSS 像素并不一定等于 1px 的物理像素。需要注意的是，CSS 中的像素单位是抽象的，只是一种规范，最终的显示是取决于物理设备的。物理设备根据某种规则，决定该采用几个物理像素去显示 1px 的 CSS 像素，这个规则就是设备像素比。 设备像素比当设备像素比为1:1时，使用1（1×1）个设备像素显示1个CSS像素； 当设备像素比为2:1时，使用4（2×2）个设备像素显示1个CSS像素； 当设备像素比为3:1时，使用9（3×3）个设备像素显示1个CSS像素。 如下图所示： 前面已经说到过，设备像素比等于设备的水平物理像素和设备 PPI 的比值。设备像素比的意义就是决定了用多少个物理像素去显示 1px 的 CSS 像素。比如在 IPhone6 中，设备像素比为 2，那么在 IPhone6 上就会使用 22 = 4 个物理像素去显示 1px 的 CSS 像素。因此，如果我们给一个 DIV 元素设置 300px 300px 的样式，那么其在 IPhone6 上将会占用 600 600 个物理像素。这就是为什么明明 IPhone6 的分辨率为 1334 750（物理像素），而将 DIV 元素的宽度设置成 300px 后，其几乎占满了水平屏幕的原因。上例在 IPhone 中的渲染效果也可以理解为：在分辨率为 667 325（设备宽度不变），设备像素比为 1 的设备上显示 300px 宽度的 DIV 的效果。既然设备像素比为 1，那么也可以这么理解：上例在 IPhone6 中的显示效果相当于在 667 325 的 Chrome 浏览器下的显示效果。Galaxy S5 的设备像素比为 3，因此在 Galaxy S5 中的显示效果可以理解为在 660 * 360 的 Chrome 浏览器下的显示效果。这也解释了为什么不同分辨率的设备，对于 300px 宽度的 DIV 展示效果基本一致的情况。 window.devicePixelRatiowindow 对象有个 devicePixelRatio 属性，其中也保存了设备像素比的值，因此我们不必经过上面的公式计算，就可以直接获取到设备像素比的值。注意：你可以为这个 window.devicePixelRatio 重新赋值，但并不会对最终的显示造成任何的影响 12window.devicePixelRatio = 10window.devicePixelRatio // 10 上面重新设置了 window.devicePixelRatio 的值，但不会影响浏览器的显示效果，也就是说，手动设置 window.devicePixelRatio 是没有任何用处的。 注意我们需要记住一点：1px 的 CSS 像素并不一定等于 1px 的物理像素，不同的设备会根据其对应设备像素比决定使用多少个物理像素显示 1px 的 CSS 像素。另外，在移动端不建议使用 px 作为布局单位，而是应该使用 rem 或者百分比作为布局单位。]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>devicePixelRatio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端 1px 像素问题及解决办法]]></title>
    <url>%2F2019%2F06%2F04%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%201px%20%E5%83%8F%E7%B4%A0%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[## 移动端1px变粗的原因 为什么移动端css里面写了1px, 实际看起来比1px粗. 其实原因很好理解:这2个’px’的含义是不一样的. 移动端html的header总会有一句 1&lt;meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"&gt; 这句话定义了本页面的viewport的宽度为设备宽度,初始缩放值和最大缩放值都为1,并禁止了用户缩放. viewport通俗的讲是浏览器上可用来显示页面的区域, 这个区域是可能比屏幕大的. 根据这篇文章http://www.cnblogs.com/2050/p/3877280.html的分析, 手机存在一个能完美适配的理想viewport, 分辨率相差很大的手机的理想viewport的宽度可能是一样的, 这样做的目的是为了保证同样的css在不同屏幕下的显示效果是一致的, 上面的meta实际上是设置了ideal viewport的宽度. 以实际举例: iphone3和iphone4的屏幕宽度分别是320px,640px, 但是它们的ideal viewport的宽度都是320px, 设置了设备宽度后, 320px宽的元素都能100%的填充满屏幕宽. 不同手机的ideal viewport宽度是不一样的, 常见的有320px, 360px, 384px. iphone系列的这个值在6之前都是320px, 控制viewport的好处就在于一套css可以适配多个机型. 看懂的人应该已经明白 1px变粗的原因了, viewport的设置和屏幕物理分辨率是按比例而不是相同的. 移动端window对象有个devicePixelRatio属性, 它表示设备物理像素和css像素的比例, 在retina屏的iphone手机上, 这个值为2或3, css里写的1px长度映射到物理像素上就有2px或3px那么长. 对于设备像素比（devicePixelRatio）不了解的可以看看这篇文章：理解设备像素比devicePixelRatio 1px解决方案1、 媒体查询利用设备像素比缩放，设置小数像素优点：简单，好理解缺点：兼容性差，目前之余IOS8+才支持，在IOS7及其以下、安卓系统都是显示0px。 IOS8下已经支持带小数的px值, media query对应devicePixelRatio有个查询值-webkit-min-device-pixel-ratio, css可以写成这样 1234567.border &#123; border: 1px solid #999 &#125;@media screen and (-webkit-min-device-pixel-ratio: 2) &#123; .border &#123; border: 0.5px solid #999 &#125;&#125;@media screen and (-webkit-min-device-pixel-ratio: 3) &#123; .border &#123; border: 0.333333px solid #999 &#125;&#125; 如果使用less/sass的话只是加了1句mixin 2.设置 border-image 方案缺点：需要制作图片，圆角可能出现模糊这样的1张6X6的图片, 9宫格等分填充border-image, 这样元素的4个边框宽度都只有1px 123456@media screen and (-webkit-min-device-pixel-ratio: 2)&#123; .border&#123; border: 1px solid transparent; border-image: url(border.gif) 2 repeat; &#125;&#125; 图片可以用gif, png, base64多种格式, 以上是上下左右四条边框的写法, 需要单一边框只要定义单一边框的border, 代码比较直观. 3、background-image 渐变实现除了使用图片外，当然也能使用纯css来实现，百度糯米团就是采用的这种方案。缺点：因为每个边框都是线性渐变颜色实现，因此无法实现圆角。 12345678910.border &#123; background-image:linear-gradient(180deg, red, red 50%, transparent 50%), linear-gradient(270deg, red, red 50%, transparent 50%), linear-gradient(0deg, red, red 50%, transparent 50%), linear-gradient(90deg, red, red 50%, transparent 50%); background-size: 100% 1px,1px 100% ,100% 1px, 1px 100%; background-repeat: no-repeat; background-position: top, right top, bottom, left top; padding: 10px;&#125; 原理：将原本1个物理像素的边框大小利用线性渐变分割成几个部分（百分比控制），实现小于1像素效果。 linear-gradient：指定线性渐变，接受大于等于3个参数，第一个为渐变旋转角度，第二个开始为渐变的颜色和到哪个位置（百分比）全部变为该颜色，该例子中，第一句就是，渐变方向旋转180度，即从上往下（默认为0度从下往上），从红色开始渐变，到50%的位置还是红色，再渐变为继承父元素颜色。 4、box-shadow利用阴影也可以实现，优点是没有圆角问题，缺点是颜色不好控制 123div &#123; -webkit-box-shadow: 0 1px 1px -1px rgba(0, 0, 0, 0.5);&#125; box-shadow属性的用法：box-shadow: h-shadow v-shadow [blur] [spread] [color] [inset] 参数分别表示: 水平阴影位置，垂直阴影位置，模糊距离， 阴影尺寸，阴影颜色，将外部阴影改为内部阴影，后四个可选。该例中为何将阴影尺寸设置为负数？设置成-1px 是为了让阴影尺寸稍小于div元素尺寸，这样左右两边的阴影就不会暴露出来，实现只有底部一边有阴影的效果。从而实现分割线效果（单边边框）。 5、viewport + rem该方案是对上述方案的优化，整体思路就是利用viewport + rem + js 动态的修改页面的缩放比例，实现小于1像素的显示。缺点：以为缩放涉及全局的rem单位，比较适合新项目，对于老项目可能要涉及到比较多的改动。 在页面初始化时，在头部引入原始默认状态如下： 1&lt;meta name="viewport" id="WebViewport" content="initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"&gt; 接下来的任务就是js的动态修改缩放比 以及 实现rem根元素字体大小的设置。 12345678910111213var viewport = document.querySelector("meta[name=viewport]")if (window.devicePixelRatio == 1) &#123; viewport.setAttribute('content', 'width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no')&#125; if (window.devicePixelRatio == 2) &#123; viewport.setAttribute('content', 'width=device-width, initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no')&#125; if (window.devicePixelRatio == 3) &#123; viewport.setAttribute('content', 'width=device-width, initial-scale=0.333333333, maximum-scale=0.333333333, minimum-scale=0.333333333, user-scalable=no')&#125; var docEl = document.documentElement;var fontsize = 10 * (docEl.clientWidth / 320) + 'px';docEl.style.fontSize = fontsize; 6、transform: scale(0.5) 方案 - 推荐: 很灵活 1.) 设置height: 1px，根据媒体查询结合transform缩放为相应尺寸。 1234567div &#123; height:1px; background:#000; -webkit-transform: scaleY(0.5); -webkit-transform-origin:0 0; overflow: hidden;&#125; 2.) 用::after和::befor,设置border-bottom：1px solid #000,然后在缩放-webkit-transform: scaleY(0.5);可以实现两根边线的需求 12345div::after&#123; content:'';width:100%; border-bottom:1px solid #000; transform: scaleY(0.5);&#125; 3.) 用::after设置border：1px solid #000; width:200%; height:200%,然后再缩放scaleY(0.5); 优点可以实现圆角，京东就是这么实现的，缺点是按钮添加active比较麻烦。 12345678910111213.div::after &#123; content: ''; width: 200%; height: 200%; position: absolute; top: 0; left: 0; border: 1px solid #bfbfbf; border-radius: 4px; -webkit-transform: scale(0.5,0.5); transform: scale(0.5,0.5); -webkit-transform-origin: top left;&#125; 7、媒体查询 + transfrom 对方案1的优化1234567891011121314/* 2倍屏 */@media only screen and (-webkit-min-device-pixel-ratio: 2.0) &#123; .border-bottom::after &#123; -webkit-transform: scaleY(0.5); transform: scaleY(0.5); &#125;&#125;/* 3倍屏 */@media only screen and (-webkit-min-device-pixel-ratio: 3.0) &#123; .border-bottom::after &#123; -webkit-transform: scaleY(0.33); transform: scaleY(0.33); &#125;&#125;]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>移动端1px像素</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git常用命令]]></title>
    <url>%2F2019%2F06%2F04%2Fgit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[@[toc] 一般配置git –version //查看git的版本信息git config –global user.email //获取当前登录的用户git config –global user.email //获取当前登录用户的邮箱 登录gitgit config –global user.email ‘userName’ //设置git账户，userName为你的git账号git config –global user.email ‘email’ git常用命令git init在本地新建一个repo,进入一个项目目录,执行git init,会初始化一个repo,并在当前文件夹下创建一个.git文件夹. git clone一般的格式是git clone [url].获取一个url对应的远程Git repo, 创建一个local copy.clone下来的repo会以url最后一个斜线后面的名称命名,创建一个文件夹,如果想要指定特定的名称,可以git clone [url] newname指定. git status查询repo的状态.git status:显示工作目录和暂存区的状态git status -s: -s表示short, -s的输出标记会有两列,第一列是对staging区域而言,第二列是对working目录而言. git log show commit history of a branch. git log –oneline –number: 每条log只显示一行,显示number条. git log –oneline –graph: 可以图形化地表示出分支合并历史. git log branchname可以显示特定分支的log. git log –oneline branch1 \^branch2,可以查看在分支1,却不在分支2中的提交.\^表示排除这个分支(Window下可能要给^branch2加上引号). git log –decorate会显示出tag信息. git log –author=[author name] 可以指定作者的提交历史. git log –since –before –until –after 根据提交时间筛选log. –no-merges可以将merge的commits排除在外. git log –grep 根据commit信息过滤log: git log –grep=keywords 默认情况下, git log –grep –author是OR的关系,即满足一条即被返回,如果你想让它们是AND的关系,可以加上–all-match的option. git log -S: filter by introduced diff. 比如: git log -SmethodName (注意S和后面的词之间没有等号分隔). git log -p: show patch introduced at each commit. 每一个提交都是一个快照(snapshot),Git会把每次提交的diff计算出来,作为一个patch显示给你看. 另一种方法是git show [SHA]. git log –stat: show diffstat of changes introduced at each commit. 同样是用来看改动的相对信息的,–stat比-p的输出更简单一些. git add在提交之前,Git有一个暂存区(staging area),可以放入新添加的文件或者加入新的改动. commit时提交的改动是上一次加入到staging area中的改动,而不是我们disk上的改动. git add . 会递归地添加当前工作目录中的所有文件. git diff不加参数的git diff: show diff of unstaged changes. 此命令比较的是工作目录中当前文件和暂存区域快照之间的差异,也就是修改之后还没有暂存起来的变化内容. 若要看已经暂存起来的文件和上次提交时的快照之间的差异,可以用: git diff –cached 命令. show diff of staged changes. (Git 1.6.1 及更高版本还允许使用 git diff –staged，效果是相同的). git diff HEAD show diff of all staged or unstated changes. 也即比较woking directory和上次提交之间所有的改动. 如果想看自从某个版本之后都改动了什么,可以用: git diff [version tag] 跟log命令一样,diff也可以加上–stat参数来简化输出. git diff [branchA] [branchB]可以用来比较两个分支. 它实际上会返回一个由A到B的patch,不是我们想要的结果. 一般我们想要的结果是两个分支分开以后各自的改动都是什么,是由命令: git diff [branchA]…[branchB]给出的. 实际上它是:git diff $(git merge-base [branchA] [branchB]) [branchB]的结果. git commit提交已经被add进来的改动. git commit -m “the commit message” git commit -a 会先把所有已经track的文件的改动add进来,然后提交(有点像svn的一次提交,不用先暂存). 对于没有track的文件,还是需要git add一下. git commit –amend 增补提交. 会使用与当前提交节点相同的父节点进行一次新的提交,旧的提交将会被取消. git resetundo changes and commits. 这里的HEAD关键字指的是当前分支最末梢最新的一个提交.也就是版本库中该分支上的最新版本. git reset HEAD: unstage files from index and reset pointer to HEAD 这个命令用来把不小心add进去的文件从staged状态取出来,可以单独针对某一个文件操作: git reset HEAD - - filename, 这个- - 也可以不加. git reset –soft move HEAD to specific commit reference, index and staging are untouched. git reset –hard unstage files AND undo any changes in the working directory since last commit. 使用git reset —hard HEAD进行reset,即上次提交之后,所有staged的改动和工作目录的改动都会消失,还原到上次提交的状态. 这里的HEAD可以被写成任何一次提交的SHA-1. 不带soft和hard参数的git reset,实际上带的是默认参数mixed. 总结: git reset –mixed id,是将git的HEAD变了(也就是提交记录变了),但文件并没有改变，(也就是working tree并没有改变). 取消了commit和add的内容. git reset –soft id. 实际上，是git reset –mixed id 后,又做了一次git add.即取消了commit的内容. git reset –hard id.是将git的HEAD变了,文件也变了. 按改动范围排序如下: soft (commit) &lt; mixed (commit + add) &lt; hard (commit + add + local working) git revert反转撤销提交.只要把出错的提交(commit)的名字(reference)作为参数传给命令就可以了. git revert HEAD: 撤销最近的一个提交. git revert会创建一个反向的新提交,可以通过参数-n来告诉Git先不要提交. git rmgit rm file: 从staging区移除文件,同时也移除出工作目录. git rm –cached: 从staging区移除文件,但留在工作目录中. git rm –cached从功能上等同于git reset HEAD,清除了缓存区,但不动工作目录树. git cleangit clean是从工作目录中移除没有track的文件. 通常的参数是git clean -df: -d表示同时移除目录,-f表示force,因为在git的配置文件中, clean.requireForce=true,如果不加-f,clean将会拒绝执行. git mvgit rm - - cached orig; mv orig new; git add new git stash 把当前的改动压入一个栈. git stash将会把当前目录和index中的所有改动(但不包括未track的文件)压入一个栈,然后留给你一个clean的工作状态,即处于上一次最新提交处. git stash list会显示这个栈的list. git stash apply:取出stash中的上一个项目(stash@{0}),并且应用于当前的工作目录. 也可以指定别的项目,比如git stash apply stash@{1}. 如果你在应用stash中项目的同时想要删除它,可以用git stash pop 删除stash中的项目: git stash drop: 删除上一个,也可指定参数删除指定的一个项目. git stash clear: 删除所有项目. git branch git branch可以用来列出分支,创建分支和删除分支. git branch -v可以看见每一个分支的最后一次提交. git branch: 列出本地所有分支,当前分支会被星号标示出. git branch (branchname): 创建一个新的分支(当你用这种方式创建分支的时候,分支是基于你的上一次提交建立的). git branch -d (branchname): 删除一个分支. 删除remote的分支: git push (remote-name) :(branch-name): delete a remote branch. 这个是因为完整的命令形式是: git push remote-name local-branch:remote-branch 而这里local-branch的部分为空,就意味着删除了remote-branch git checkout git checkout (branchname) 切换到一个分支. git checkout -b (branchname): 创建并切换到新的分支. 这个命令是将git branch newbranch和git checkout newbranch合在一起的结果. checkout还有另一个作用:替换本地改动: git checkout –\ 此命令会使用HEAD中的最新内容替换掉你的工作目录中的文件.已添加到暂存区的改动以及新文件都不会受到影响. 注意:git checkout filename会删除该文件中所有没有暂存和提交的改动,这个操作是不可逆的. git merge把一个分支合并进当前的分支. git merge [alias]/[branch] 把远程分支merge到当前分支. 如果出现冲突,需要手动修改,可以用git mergetool. 解决冲突的时候可以用到git diff,解决完之后用git add添加,即表示冲突已经被resolved. git tag tag a point in history as import. 会在一个提交上建立永久性的书签,通常是发布一个release版本或者ship了什么东西之后加tag. 比如: git tag v1.0 git tag -a v1.0, -a参数会允许你添加一些信息,即make an annotated tag. 当你运行git tag -a命令的时候,Git会打开一个编辑器让你输入tag信息. 我们可以利用commit SHA来给一个过去的提交打tag: git tag -a v0.9 XXXX push的时候是不包含tag的,如果想包含,可以在push时加上–tags参数. fetch的时候,branch HEAD可以reach的tags是自动被fetch下来的, tags that aren’t reachable from branch heads will be skipped.如果想确保所有的tags都被包含进来,需要加上–tags选项. git remotelist, add and delete remote repository aliases. 因为不需要每次都用完整的url,所以Git为每一个remote repo的url都建立一个别名,然后用git remote来管理这个list. git remote: 列出remote aliases. 如果你clone一个project,Git会自动将原来的url添加进来,别名就叫做:origin. git remote -v:可以看见每一个别名对应的实际url. git remote add [alias] [url]: 添加一个新的remote repo. git remote rm [alias]: 删除一个存在的remote alias. git remote rename [old-alias] [new-alias]: 重命名. git remote set-url [alias] [url]:更新url. 可以加上—push和fetch参数,为同一个别名set不同的存取地址. git fetchdownload new branches and data from a remote repository. 可以git fetch [alias]取某一个远程repo,也可以git fetch –all取到全部repo fetch将会取到所有你本地没有的数据,所有取下来的分支可以被叫做remote branches,它们和本地分支一样(可以看diff,log等,也可以merge到其他分支),但是Git不允许你checkout到它们. git pull fetch from a remote repo and try to merge into the current branch. pull == fetch + merge FETCH_HEAD git pull会首先执行git fetch,然后执行git merge,把取来的分支的head merge到当前分支.这个merge操作会产生一个新的commit. 如果使用–rebase参数,它会执行git rebase来取代原来的git merge. git rebase –rebase不会产生合并的提交,它会将本地的所有提交临时保存为补丁(patch),放在”.git/rebase”目录中,然后将当前分支更新到最新的分支尖端,最后把保存的补丁应用到分支上. rebase的过程中,也许会出现冲突,Git会停止rebase并让你解决冲突,在解决完冲突之后,用git add去更新这些内容,然后无需执行commit,只需要: git rebase –continue就会继续打余下的补丁. git rebase –abort将会终止rebase,当前分支将会回到rebase之前的状态. git pushpush your new branches and data to a remote repository. git push [alias] [branch] 将会把当前分支merge到alias上的[branch]分支.如果分支已经存在,将会更新,如果不存在,将会添加这个分支. 如果有多个人向同一个remote repo push代码, Git会首先在你试图push的分支上运行git log,检查它的历史中是否能看到server上的branch现在的tip,如果本地历史中不能看到server的tip,说明本地的代码不是最新的,Git会拒绝你的push,让你先fetch,merge,之后再push,这样就保证了所有人的改动都会被考虑进来. git refloggit reflog是对reflog进行管理的命令,reflog是git用来记录引用变化的一种机制,比如记录分支的变化或者是HEAD引用的变化. 当git reflog不指定引用的时候,默认列出HEAD的reflog. HEAD@{0}代表HEAD当前的值,HEAD@{3}代表HEAD在3次变化之前的值. git会将变化记录到HEAD对应的reflog文件中,其路径为.git/logs/HEAD, 分支的reflog文件都放在.git/logs/refs目录下的子目录中. 特殊符号: \^代表父提交,当一个提交有多个父提交时,可以通过在\^后面跟上一个数字,表示第几个父提交: ^相当于\^1. ~\相当于连续的\个^. Git常用命令速查表]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webStrom_phpStrom使用箭头函数报错解决方法]]></title>
    <url>%2F2019%2F06%2F04%2FwebStrom_phpStrom%E4%BD%BF%E7%94%A8%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[### webStrom/phpStrom使用箭头函数报错 在webStrom/phpStrom下写箭头函数会出现代码爆红，但执行并不会出错。像这样: 解决方法 点击窗口左上角File-&gt;Setttings-&gt;Languages &amp; FrameWorks-&gt;JavaScript 在右边找到JavaScript Language version下拉框中版本改为ECMAScript6 将\改写成\这个时候就不会在报错了。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于webpack命令提示安装webpack-cli，安装了以后又显示“Cannot find module 'webpack'”的解决方法]]></title>
    <url>%2F2019%2F06%2F04%2F%E5%85%B3%E4%BA%8Ewebpack%E5%91%BD%E4%BB%A4%E6%8F%90%E7%A4%BA%E5%AE%89%E8%A3%85webpack-cli%EF%BC%8C%E5%AE%89%E8%A3%85%E4%BA%86%E4%BB%A5%E5%90%8E%E5%8F%88%E6%98%BE%E7%A4%BA%E2%80%9CCannot%20find%20module%20'webpack'%E2%80%9D%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[## webpack 初次安装只有webpack遇到了许多问题，记录以下，分享给其他遇到相同问题的小伙伴。 问题一：We will use “npm” to install the CLI via “npm install -D”.12345678BlinkdeMacBook-Pro:05-01 blink$ webpackOne CLI for webpack must be installed. These are recommended choices, delivered as separate packages: - webpack-cli (https://github.com/webpack/webpack-cli) The original webpack full-featured CLI. - webpack-command (https://github.com/webpack-contrib/webpack-command) A lightweight, opinionated webpack CLI.We will use "npm" to install the CLI via "npm install -D".Which one do you like to install (webpack-cli/webpack-command): 在使用npm i webpack -g安装了webpack以后，使用时出现了这个，让我们去安装webpack-cli。 解决方案直接安装webpack-cli就是了,需要注意的是后面记得加 -g进行全局安装 1cnpm install webpack-cli -g 问题二：Cannot find module ‘webpack这就很奇怪了，前面刚刚安装了咋显示找不到，然后找了好几种解决方案好像都不行了，不过倒腾了一会发现是webpack4这个版本的原因，那就好解决了，换一个版本安装就是了。 解决方案安装webpack3的版本就行了，我安装的是3.6.01cnpm install webpack@3.6.0 -g]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git出现Unable to create 'E__xxx_.git_index.lock'_ File exists.的解决办法]]></title>
    <url>%2F2019%2F06%2F04%2FGit%E5%87%BA%E7%8E%B0Unable%20to%20create%20'E__xxx_.git_index.lock'_%20File%20exists.%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[在使用git时，在执行完”git add readme.txt”命令后，在执行commit时，由于命令写错，没有写提交日志，再次更正提交就出现上述错误：Unable to create ‘E:/xxx/.git/index.lock’: File exists 解决方案：在.git同级目录，执行rm -f .git/index.lock 将文件删除即可提交成功]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git Filename too long解决方案]]></title>
    <url>%2F2019%2F06%2F04%2Fgit%20Filename%20too%20long%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[## 问题 git clone代码时提示Filename too long，一般是在windows下出现的问题。 解决方法用管理员打开命令窗口，输入git config –system core.longpaths true解决。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue.js - day1]]></title>
    <url>%2F2019%2F06%2F04%2FVue.js%20-%20Day1%2F</url>
    <content type="text"><![CDATA[# Vue.js - Day1 笔记配套源码 @[toc] 什么是Vue.js Vue.js 是目前最火的一个前端框架，React是最流行的一个前端框架（React除了开发网站，还可以开发手机App， Vue语法也是可以用于进行手机App开发的，需要借助于Weex） Vue.js 是前端的主流框架之一，和Angular.js、React.js 一起，并成为前端三大主流框架！ Vue.js 是一套构建用户界面的框架，只关注视图层，它不仅易于上手，还便于与第三方库或既有项目整合。（Vue有配套的第三方类库，可以整合起来做大型项目的开发） 前端的主要工作？主要负责MVC中的V这一层；主要工作就是和界面打交道，来制作前端页面效果； 为什么要学习流行框架 企业为了提高开发效率：在企业中，时间就是效率，效率就是金钱； 企业中，使用框架，能够提高开发的效率； 提高开发效率的发展历程：原生JS -&gt; Jquery之类的类库 -&gt; 前端模板引擎 -&gt; Angular.js / Vue.js（能够帮助我们减少不必要的DOM操作；提高渲染效率；双向数据绑定的概念【通过框架提供的指令，我们前端程序员只需要关心数据的业务逻辑，不再关心DOM是如何渲染的了】） 在Vue中，一个核心的概念，就是让用户不再操作DOM元素，解放了用户的双手，让程序员可以更多的时间去关注业务逻辑； 增强自己就业时候的竞争力 人无我有，人有我优 你平时不忙的时候，都在干嘛？ 框架和库的区别 框架：是一套完整的解决方案；对项目的侵入性较大，项目如果需要更换框架，则需要重新架构整个项目。 node 中的 express； 库（插件）：提供某一个小功能，对项目的侵入性较小，如果某个库无法完成某些需求，可以很容易切换到其它库实现需求。 从Jquery 切换到 Zepto 从 EJS 切换到 art-template Node（后端）中的 MVC 与 前端中的 MVVM 之间的区别 MVC 是后端的分层开发概念； MVVM是前端视图层的概念，主要关注于 视图层分离，也就是说：MVVM把前端的视图层，分为了 三部分 Model, View , VM ViewModel 为什么有了MVC还要有MVVM Vue.js 基本代码 和 MVVM 之间的对应关系Vue之 - 基本的代码结构和插值表达式、v-cloakVue指令之v-text和v-htmlVue指令之v-bind的三种用法 直接使用指令v-bind 使用简化指令: 在绑定的时候，拼接绑定内容：:title=&quot;btnTitle + &#39;, 这是追加的内容&#39;&quot; Vue指令之v-on和跑马灯效果跑马灯效果 HTML结构： 12345678910&lt;div id="app"&gt; &lt;p&gt;&#123;&#123;info&#125;&#125;&lt;/p&gt; &lt;input type="button" value="开启" v-on:click="go"&gt; &lt;input type="button" value="停止" v-on:click="stop"&gt; &lt;/div&gt; Vue实例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; info: '猥琐发育，别浪~！', intervalId: null &#125;, methods: &#123; go() &#123; // 如果当前有定时器在运行，则直接return if (this.intervalId != null) &#123; return; &#125; // 开始定时器 this.intervalId = setInterval(() =&gt; &#123; this.info = this.info.substring(1) + this.info.substring(0, 1); &#125;, 500); &#125;, stop() &#123; clearInterval(this.intervalId); &#125; &#125; &#125;); Vue指令之v-on的缩写和事件修饰符事件修饰符： .stop 阻止冒泡 .prevent 阻止默认事件 .capture 添加事件侦听器时使用事件捕获模式 .self 只当事件在该元素本身（比如不是子元素）触发时触发回调 .once 事件只触发一次 Vue指令之v-model和双向数据绑定简易计算器案例 HTML 代码结构 123456789101112131415161718192021222324&lt;div id="app"&gt; &lt;input type="text" v-model="n1"&gt; &lt;select v-model="opt"&gt; &lt;option value="0"&gt;+&lt;/option&gt; &lt;option value="1"&gt;-&lt;/option&gt; &lt;option value="2"&gt;*&lt;/option&gt; &lt;option value="3"&gt;÷&lt;/option&gt; &lt;/select&gt; &lt;input type="text" v-model="n2"&gt; &lt;input type="button" value="=" v-on:click="getResult"&gt; &lt;input type="text" v-model="result"&gt;&lt;/div&gt; Vue实例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; n1: 0, n2: 0, result: 0, opt: '0' &#125;, methods: &#123; getResult() &#123; switch (this.opt) &#123; case '0': this.result = parseInt(this.n1) + parseInt(this.n2); break; case '1': this.result = parseInt(this.n1) - parseInt(this.n2); break; case '2': this.result = parseInt(this.n1) * parseInt(this.n2); break; case '3': this.result = parseInt(this.n1) / parseInt(this.n2); break; &#125; &#125; &#125; &#125;); 在Vue中使用样式使用class样式 数组 1&lt;h1 :class="['red', 'thin']"&gt;这是一个邪恶的H1&lt;/h1&gt; 数组中使用三元表达式 1&lt;h1 :class="['red', 'thin', isactive?'active':'']"&gt;这是一个邪恶的H1&lt;/h1&gt; 数组中嵌套对象 1&lt;h1 :class="['red', 'thin', &#123;'active': isactive&#125;]"&gt;这是一个邪恶的H1&lt;/h1&gt; 直接使用对象 1&lt;h1 :class="&#123;red:true, italic:true, active:true, thin:true&#125;"&gt;这是一个邪恶的H1&lt;/h1&gt; 使用内联样式 直接在元素上通过 :style 的形式，书写样式对象 1&lt;h1 :style="&#123;color: 'red', 'font-size': '40px'&#125;"&gt;这是一个善良的H1&lt;/h1&gt; 将样式对象，定义到 data 中，并直接引用到 :style 中 在data上定义样式： 123data: &#123; h1StyleObj: &#123; color: 'red', 'font-size': '40px', 'font-weight': '200' &#125;&#125; 在元素中，通过属性绑定的形式，将样式对象应用到元素中： 1&lt;h1 :style="h1StyleObj"&gt;这是一个善良的H1&lt;/h1&gt; 在 :style 中通过数组，引用多个 data 上的样式对象 在data上定义样式： 1234data: &#123; h1StyleObj: &#123; color: 'red', 'font-size': '40px', 'font-weight': '200' &#125;, h1StyleObj2: &#123; fontStyle: 'italic' &#125;&#125; 在元素中，通过属性绑定的形式，将样式对象应用到元素中： 1&lt;h1 :style="[h1StyleObj, h1StyleObj2]"&gt;这是一个善良的H1&lt;/h1&gt; Vue指令之v-for和key属性 迭代数组 123&lt;ul&gt; &lt;li v-for="(item, i) in list"&gt;索引：&#123;&#123;i&#125;&#125; --- 姓名：&#123;&#123;item.name&#125;&#125; --- 年龄：&#123;&#123;item.age&#125;&#125;&lt;/li&gt;&lt;/ul&gt; 迭代对象中的属性 1234&lt;!-- 循环遍历对象身上的属性 --&gt; &lt;div v-for="(val, key, i) in userInfo"&gt;&#123;&#123;val&#125;&#125; --- &#123;&#123;key&#125;&#125; --- &#123;&#123;i&#125;&#125;&lt;/div&gt; 迭代数字 12&lt;p v-for="i in 10"&gt;这是第 &#123;&#123;i&#125;&#125; 个P标签&lt;/p&gt; 2.2.0+ 的版本里，当在组件中使用 v-for 时，key 现在是必须的。 当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用 “就地复用” 策略。如果数据项的顺序被改变，Vue将不是移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。 为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性。 Vue指令之v-if和v-show 一般来说，v-if 有更高的切换消耗而 v-show 有更高的初始渲染消耗。因此，如果需要频繁切换 v-show 较好，如果在运行时条件不大可能改变 v-if 较好。 品牌管理案例添加新品牌删除品牌根据条件筛选品牌 1.x 版本中的filterBy指令，在2.x中已经被废除： filterBy - 指令 12345678910111213141516&lt;tr v-for="item in list | filterBy searchName in 'name'"&gt; &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.ctime&#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;a href="#" @click.prevent="del(item.id)"&gt;删除&lt;/a&gt; &lt;/td&gt;&lt;/tr&gt; 在2.x版本中手动实现筛选的方式： 筛选框绑定到 VM 实例中的 searchName 属性： 1234&lt;hr&gt; 输入筛选名称：&lt;input type="text" v-model="searchName"&gt; 在使用 v-for 指令循环每一行数据的时候，不再直接 item in list，而是 in 一个 过滤的methods 方法，同时，把过滤条件searchName传递进去： 1234567891011121314151617181920&lt;tbody&gt; &lt;tr v-for="item in search(searchName)"&gt; &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.ctime&#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;a href="#" @click.prevent="del(item.id)"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; search 过滤方法中，使用 数组的 filter 方法进行过滤： 12345678910search(name) &#123; return this.list.filter(x =&gt; &#123; return x.name.indexOf(name) != -1; &#125;);&#125; Vue调试工具vue-devtools的安装步骤和使用Vue.js devtools - 翻墙安装方式 - 推荐 过滤器概念：Vue.js 允许你自定义过滤器，可被用作一些常见的文本格式化。过滤器可以用在两个地方：mustache 插值和 v-bind 表达式。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符指示； 私有过滤器 HTML元素： 12&lt;td&gt;&#123;&#123;item.ctime | dataFormat('yyyy-mm-dd')&#125;&#125;&lt;/td&gt; 私有 filters 定义方式： 1234567891011121314151617181920212223242526272829303132333435363738394041424344filters: &#123; // 私有局部过滤器，只能在 当前 VM 对象所控制的 View 区域进行使用 dataFormat(input, pattern = "") &#123; // 在参数列表中 通过 pattern="" 来指定形参默认值，防止报错 var dt = new Date(input); // 获取年月日 var y = dt.getFullYear(); var m = (dt.getMonth() + 1).toString().padStart(2, '0'); var d = dt.getDate().toString().padStart(2, '0'); // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日 // 否则，就返回 年-月-日 时：分：秒 if (pattern.toLowerCase() === 'yyyy-mm-dd') &#123; return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;`; &#125; else &#123; // 获取时分秒 var hh = dt.getHours().toString().padStart(2, '0'); var mm = dt.getMinutes().toString().padStart(2, '0'); var ss = dt.getSeconds().toString().padStart(2, '0'); return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;`; &#125; &#125; &#125; 使用ES6中的字符串新方法 String.prototype.padStart(maxLength, fillString=’’) 或 String.prototype.padEnd(maxLength, fillString=’’)来填充字符串； 全局过滤器123456789101112131415161718192021222324252627282930313233343536373839404142// 定义一个全局过滤器Vue.filter('dataFormat', function (input, pattern = '') &#123; var dt = new Date(input); // 获取年月日 var y = dt.getFullYear(); var m = (dt.getMonth() + 1).toString().padStart(2, '0'); var d = dt.getDate().toString().padStart(2, '0'); // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日 // 否则，就返回 年-月-日 时：分：秒 if (pattern.toLowerCase() === 'yyyy-mm-dd') &#123; return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;`; &#125; else &#123; // 获取时分秒 var hh = dt.getHours().toString().padStart(2, '0'); var mm = dt.getMinutes().toString().padStart(2, '0'); var ss = dt.getSeconds().toString().padStart(2, '0'); return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;`; &#125;&#125;); 注意：当有局部和全局两个名称相同的过滤器时候，会以就近原则进行调用，即：局部过滤器优先于全局过滤器被调用！ 键盘修饰符以及自定义键盘修饰符1.x中自定义键盘修饰符【了解即可】12Vue.directive('on').keyCodes.f2 = 113; 2.x中自定义键盘修饰符 通过Vue.config.keyCodes.名称 = 按键值来自定义案件修饰符的别名： 12Vue.config.keyCodes.f2 = 113; 使用自定义的按键修饰符： 12&lt;input type="text" v-model="name" @keyup.f2="add"&gt; 自定义指令 自定义全局和局部的 自定义指令： 123456789101112131415161718192021222324252627282930313233343536// 自定义全局指令 v-focus，为绑定的元素自动获取焦点：Vue.directive('focus', &#123; inserted: function (el) &#123; // inserted 表示被绑定元素插入父节点时调用 el.focus(); &#125;&#125;);// 自定义局部指令 v-color 和 v-font-weight，为绑定的元素设置指定的字体颜色 和 字体粗细： directives: &#123; color: &#123; // 为元素设置指定的字体颜色 bind(el, binding) &#123; el.style.color = binding.value; &#125; &#125;, 'font-weight': function (el, binding2) &#123; // 自定义指令的简写形式，等同于定义了 bind 和 update 两个钩子函数 el.style.fontWeight = binding2.value; &#125; &#125; 自定义指令的使用方式： 12&lt;input type="text" v-model="searchName" v-focus v-color="'red'" v-font-weight="900"&gt; Vue 1.x 中 自定义元素指令【已废弃,了解即可】12345Vue.elementDirective('red-color', &#123; bind: function () &#123; this.el.style.color = 'red'; &#125;&#125;); 使用方式：1&lt;red-color&gt;1232&lt;/red-color&gt; 相关文章 vue.js 1.x 文档 vue.js 2.x 文档 String.prototype.padStart(maxLength, fillString) js 里面的键盘事件对应的键码 Vue.js双向绑定的实现原理]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue.js - day2]]></title>
    <url>%2F2019%2F06%2F04%2FVue.js%20-%20Day2%2F</url>
    <content type="text"><![CDATA[[TOC] Vue.js - Day2品牌管理案例添加新品牌删除品牌根据条件筛选品牌 1.x 版本中的filterBy指令，在2.x中已经被废除： filterBy - 指令 12345678910111213141516&lt;tr v-for="item in list | filterBy searchName in 'name'"&gt; &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.ctime&#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;a href="#" @click.prevent="del(item.id)"&gt;删除&lt;/a&gt; &lt;/td&gt;&lt;/tr&gt; 在2.x版本中手动实现筛选的方式： 筛选框绑定到 VM 实例中的 searchName 属性： 1234&lt;hr&gt; 输入筛选名称：&lt;input type="text" v-model="searchName"&gt; 在使用 v-for 指令循环每一行数据的时候，不再直接 item in list，而是 in 一个 过滤的methods 方法，同时，把过滤条件searchName传递进去： 1234567891011121314151617181920&lt;tbody&gt; &lt;tr v-for="item in search(searchName)"&gt; &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.ctime&#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;a href="#" @click.prevent="del(item.id)"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; search 过滤方法中，使用 数组的 filter 方法进行过滤： 12345678910search(name) &#123; return this.list.filter(x =&gt; &#123; return x.name.indexOf(name) != -1; &#125;);&#125; Vue调试工具vue-devtools的安装步骤和使用Vue.js devtools - 翻墙安装方式 - 推荐 过滤器概念：Vue.js 允许你自定义过滤器，可被用作一些常见的文本格式化。过滤器可以用在两个地方：mustache 插值和 v-bind 表达式。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符指示； 私有过滤器 HTML元素： 12&lt;td&gt;&#123;&#123;item.ctime | dataFormat('yyyy-mm-dd')&#125;&#125;&lt;/td&gt; 私有 filters 定义方式： 1234567891011121314151617181920212223242526272829303132333435363738394041424344filters: &#123; // 私有局部过滤器，只能在 当前 VM 对象所控制的 View 区域进行使用 dataFormat(input, pattern = "") &#123; // 在参数列表中 通过 pattern="" 来指定形参默认值，防止报错 var dt = new Date(input); // 获取年月日 var y = dt.getFullYear(); var m = (dt.getMonth() + 1).toString().padStart(2, '0'); var d = dt.getDate().toString().padStart(2, '0'); // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日 // 否则，就返回 年-月-日 时：分：秒 if (pattern.toLowerCase() === 'yyyy-mm-dd') &#123; return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;`; &#125; else &#123; // 获取时分秒 var hh = dt.getHours().toString().padStart(2, '0'); var mm = dt.getMinutes().toString().padStart(2, '0'); var ss = dt.getSeconds().toString().padStart(2, '0'); return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;`; &#125; &#125; &#125; 使用ES6中的字符串新方法 String.prototype.padStart(maxLength, fillString=’’) 或 String.prototype.padEnd(maxLength, fillString=’’)来填充字符串； 全局过滤器123456789101112131415161718192021222324252627282930313233343536373839404142// 定义一个全局过滤器Vue.filter('dataFormat', function (input, pattern = '') &#123; var dt = new Date(input); // 获取年月日 var y = dt.getFullYear(); var m = (dt.getMonth() + 1).toString().padStart(2, '0'); var d = dt.getDate().toString().padStart(2, '0'); // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日 // 否则，就返回 年-月-日 时：分：秒 if (pattern.toLowerCase() === 'yyyy-mm-dd') &#123; return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;`; &#125; else &#123; // 获取时分秒 var hh = dt.getHours().toString().padStart(2, '0'); var mm = dt.getMinutes().toString().padStart(2, '0'); var ss = dt.getSeconds().toString().padStart(2, '0'); return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;`; &#125;&#125;); 注意：当有局部和全局两个名称相同的过滤器时候，会以就近原则进行调用，即：局部过滤器优先于全局过滤器被调用！ 键盘修饰符以及自定义键盘修饰符1.x中自定义键盘修饰符【了解即可】12Vue.directive('on').keyCodes.f2 = 113; 2.x中自定义键盘修饰符 通过Vue.config.keyCodes.名称 = 按键值来自定义案件修饰符的别名： 12Vue.config.keyCodes.f2 = 113; 使用自定义的按键修饰符： 12&lt;input type="text" v-model="name" @keyup.f2="add"&gt; 自定义指令 自定义全局和局部的 自定义指令： 123456789101112131415161718192021222324252627282930313233343536// 自定义全局指令 v-focus，为绑定的元素自动获取焦点：Vue.directive('focus', &#123; inserted: function (el) &#123; // inserted 表示被绑定元素插入父节点时调用 el.focus(); &#125;&#125;);// 自定义局部指令 v-color 和 v-font-weight，为绑定的元素设置指定的字体颜色 和 字体粗细： directives: &#123; color: &#123; // 为元素设置指定的字体颜色 bind(el, binding) &#123; el.style.color = binding.value; &#125; &#125;, 'font-weight': function (el, binding2) &#123; // 自定义指令的简写形式，等同于定义了 bind 和 update 两个钩子函数 el.style.fontWeight = binding2.value; &#125; &#125; 自定义指令的使用方式： 12&lt;input type="text" v-model="searchName" v-focus v-color="'red'" v-font-weight="900"&gt; Vue 1.x 中 自定义元素指令【已废弃,了解即可】12345Vue.elementDirective('red-color', &#123; bind: function () &#123; this.el.style.color = 'red'; &#125;&#125;); 使用方式：1&lt;red-color&gt;1232&lt;/red-color&gt; vue实例的生命周期 什么是生命周期：从Vue实例创建、运行、到销毁期间，总是伴随着各种各样的事件，这些事件，统称为生命周期！ 生命周期钩子：就是生命周期事件的别名而已； 生命周期钩子 = 生命周期函数 = 生命周期事件 主要的生命周期函数分类： 创建期间的生命周期函数： beforeCreate：实例刚在内存中被创建出来，此时，还没有初始化好 data 和 methods 属性 created：实例已经在内存中创建OK，此时 data 和 methods 已经创建OK，此时还没有开始 编译模板 beforeMount：此时已经完成了模板的编译，但是还没有挂载到页面中 mounted：此时，已经将编译好的模板，挂载到了页面指定的容器中显示 运行期间的生命周期函数： beforeUpdate：状态更新之前执行此函数， 此时 data 中的状态值是最新的，但是界面上显示的 数据还是旧的，因为此时还没有开始重新渲染DOM节点 updated：实例更新完毕之后调用此函数，此时 data 中的状态值 和 界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了！ 销毁期间的生命周期函数： beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。 destroyed：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 vue-resource 实现 get, post, jsonp请求除了 vue-resource 之外，还可以使用 axios 的第三方包实现实现数据的请求 之前的学习中，如何发起数据请求？ 常见的数据请求类型？ get post jsonp 测试的URL请求资源地址： get请求地址： http://vue.studyit.io/api/getlunbo post请求地址：http://vue.studyit.io/api/post jsonp请求地址：http://vue.studyit.io/api/jsonp JSONP的实现原理 由于浏览器的安全性限制，不允许AJAX访问 协议不同、域名不同、端口号不同的 数据接口，浏览器认为这种访问不安全； 可以通过动态创建script标签的形式，把script标签的src属性，指向数据接口的地址，因为script标签不存在跨域限制，这种数据获取方式，称作JSONP（注意：根据JSONP的实现原理，知晓，JSONP只支持Get请求）； 具体实现过程： 先在客户端定义一个回调方法，预定义对数据的操作； 再把这个回调方法的名称，通过URL传参的形式，提交到服务器的数据接口； 服务器数据接口组织好要发送给客户端的数据，再拿着客户端传递过来的回调方法名称，拼接出一个调用这个方法的字符串，发送给客户端去解析执行； 客户端拿到服务器返回的字符串之后，当作Script脚本去解析执行，这样就能够拿到JSONP的数据了； 带大家通过 Node.js ，来手动实现一个JSONP的请求例子；1234567891011121314151617181920212223242526272829303132333435const http = require('http');// 导入解析 URL 地址的核心模块const urlModule = require('url');const server = http.createServer();// 监听 服务器的 request 请求事件，处理每个请求server.on('request', (req, res) =&gt; &#123; const url = req.url; // 解析客户端请求的URL地址 var info = urlModule.parse(url, true); // 如果请求的 URL 地址是 /getjsonp ，则表示要获取JSONP类型的数据 if (info.pathname === '/getjsonp') &#123; // 获取客户端指定的回调函数的名称 var cbName = info.query.callback; // 手动拼接要返回给客户端的数据对象 var data = &#123; name: 'zs', age: 22, gender: '男', hobby: ['吃饭', '睡觉', '运动'] &#125; // 拼接出一个方法的调用，在调用这个方法的时候，把要发送给客户端的数据，序列化为字符串，作为参数传递给这个调用的方法： var result = `$&#123;cbName&#125;($&#123;JSON.stringify(data)&#125;)`; // 将拼接好的方法的调用，返回给客户端去解析执行 res.end(result); &#125; else &#123; res.end('404'); &#125;&#125;);server.listen(3000, () =&gt; &#123; console.log('server running at http://127.0.0.1:3000');&#125;); vue-resource 的配置步骤： 直接在页面中，通过script标签，引入 vue-resource 的脚本文件； 注意：引用的先后顺序是：先引用 Vue 的脚本文件，再引用 vue-resource 的脚本文件； 发送get请求： 12345getInfo() &#123; // get 方式获取数据 this.$http.get('http://127.0.0.1:8899/api/getlunbo').then(res =&gt; &#123; console.log(res.body); &#125;)&#125; 发送post请求： 12345678910postInfo() &#123; var url = 'http://127.0.0.1:8899/api/post'; // post 方法接收三个参数： // 参数1： 要请求的URL地址 // 参数2： 要发送的数据对象 // 参数3： 指定post提交的编码类型为 application/x-www-form-urlencoded this.$http.post(url, &#123; name: 'zs' &#125;, &#123; emulateJSON: true &#125;).then(res =&gt; &#123; console.log(res.body); &#125;);&#125; 发送JSONP请求获取数据： 123456jsonpInfo() &#123; // JSONP形式从服务器获取数据 var url = 'http://127.0.0.1:8899/api/jsonp'; this.$http.jsonp(url).then(res =&gt; &#123; console.log(res.body); &#125;);&#125; 配置本地数据库和数据接口API 先解压安装 PHPStudy; 解压安装 Navicat 这个数据库可视化工具，并激活； 打开 Navicat 工具，新建空白数据库，名为 dtcmsdb4; 双击新建的数据库，连接上这个空白数据库，在新建的数据库上右键 -&gt; 运行SQL文件，选择并执行 dtcmsdb4.sql 这个数据库脚本文件；如果执行不报错，则数据库导入完成； 进入文件夹 vuecms3_nodejsapi 内部，执行 npm i 安装所有的依赖项； 先确保本机安装了 nodemon, 没有安装，则运行 npm i nodemon -g 进行全局安装，安装完毕后，进入到 vuecms3_nodejsapi目录 -&gt; src目录 -&gt; 双击运行 start.bat 如果API启动失败，请检查 PHPStudy 是否正常开启，同时，检查 app.js 中第 14行 中数据库连接配置字符串是否正确；PHPStudy 中默认的 用户名是root，默认的密码也是root 品牌管理改造展示品牌列表添加品牌数据删除品牌数据Vue中的动画为什么要有动画：动画能够提高用户的体验，帮助用户更好的理解页面中的功能； 使用过渡类名 HTML结构： 1234567&lt;div id="app"&gt; &lt;input type="button" value="动起来" @click="myAnimate"&gt; &lt;!-- 使用 transition 将需要过渡的元素包裹起来 --&gt; &lt;transition name="fade"&gt; &lt;div v-show="isshow"&gt;动画哦&lt;/div&gt; &lt;/transition&gt; &lt;/div&gt; VM 实例： 123456789101112// 创建 Vue 实例，得到 ViewModelvar vm = new Vue(&#123; el: '#app', data: &#123; isshow: false &#125;, methods: &#123; myAnimate() &#123; this.isshow = !this.isshow; &#125; &#125;&#125;); 定义两组类样式： 12345678910111213/* 定义进入和离开时候的过渡状态 */ .fade-enter-active, .fade-leave-active &#123; transition: all 0.2s ease; position: absolute; &#125; /* 定义进入过渡的开始状态 和 离开过渡的结束状态 */ .fade-enter, .fade-leave-to &#123; opacity: 0; transform: translateX(100px); &#125; 使用第三方 CSS 动画库 导入动画类库： 1&lt;link rel="stylesheet" type="text/css" href="./lib/animate.css"&gt; 定义 transition 及属性： 123456&lt;transition enter-active-class="fadeInRight" leave-active-class="fadeOutRight" :duration="&#123; enter: 500, leave: 800 &#125;"&gt; &lt;div class="animated" v-show="isshow"&gt;动画哦&lt;/div&gt;&lt;/transition&gt; 使用动画钩子函数 定义 transition 组件以及三个钩子函数： 123456789&lt;div id="app"&gt; &lt;input type="button" value="切换动画" @click="isshow = !isshow"&gt; &lt;transition @before-enter="beforeEnter" @enter="enter" @after-enter="afterEnter"&gt; &lt;div v-if="isshow" class="show"&gt;OK&lt;/div&gt; &lt;/transition&gt; &lt;/div&gt; 定义三个 methods 钩子方法： 12345678910111213methods: &#123; beforeEnter(el) &#123; // 动画进入之前的回调 el.style.transform = 'translateX(500px)'; &#125;, enter(el, done) &#123; // 动画进入完成时候的回调 el.offsetWidth; el.style.transform = 'translateX(0px)'; done(); &#125;, afterEnter(el) &#123; // 动画进入完成之后的回调 this.isshow = !this.isshow; &#125; &#125; 定义动画过渡时长和样式： 123.show&#123; transition: all 0.4s ease; &#125; v-for 的列表过渡 定义过渡样式： 123456789101112&lt;style&gt; .list-enter, .list-leave-to &#123; opacity: 0; transform: translateY(10px); &#125; .list-enter-active, .list-leave-active &#123; transition: all 0.3s ease; &#125;&lt;/style&gt; 定义DOM结构，其中，需要使用 transition-group 组件把v-for循环的列表包裹起来： 1234567&lt;div id="app"&gt; &lt;input type="text" v-model="txt" @keyup.enter="add"&gt; &lt;transition-group tag="ul" name="list"&gt; &lt;li v-for="(item, i) in list" :key="i"&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/transition-group&gt;&lt;/div&gt; 定义 VM中的结构： 1234567891011121314// 创建 Vue 实例，得到 ViewModelvar vm = new Vue(&#123; el: '#app', data: &#123; txt: '', list: [1, 2, 3, 4] &#125;, methods: &#123; add() &#123; this.list.push(this.txt); this.txt = ''; &#125; &#125;&#125;); 列表的排序过渡&lt;transition-group&gt; 组件还有一个特殊之处。不仅可以进入和离开动画，还可以改变定位。要使用这个新功能只需了解新增的 v-move 特性，它会在元素的改变定位的过程中应用。 v-move 和 v-leave-active 结合使用，能够让列表的过渡更加平缓柔和：123456.v-move&#123; transition: all 0.8s ease;&#125;.v-leave-active&#123; position: absolute;&#125; 相关文章 vue.js 1.x 文档 vue.js 2.x 文档 String.prototype.padStart(maxLength, fillString) js 里面的键盘事件对应的键码 pagekit/vue-resource navicat如何导入sql文件和导出sql文件 贝塞尔在线生成器]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue.js - day3]]></title>
    <url>%2F2019%2F06%2F04%2FVue.js%20-%20Day3%2F</url>
    <content type="text"><![CDATA[@[toc] Vue.js - Day3定义Vue组件什么是组件： 组件的出现，就是为了拆分Vue实例的代码量的，能够让我们以不同的组件，来划分不同的功能模块，将来我们需要什么样的功能，就可以去调用对应的组件即可；组件化和模块化的不同： 模块化： 是从代码逻辑的角度进行划分的；方便代码分层开发，保证每个功能模块的职能单一； 组件化： 是从UI界面的角度进行划分的；前端的组件化，方便UI组件的重用；全局组件定义的三种方式 使用 Vue.extend 配合 Vue.component 方法：1234var login = Vue.extend(&#123; template: '&lt;h1&gt;登录&lt;/h1&gt;' &#125;); Vue.component('login', login); 直接使用 Vue.component 方法： 123Vue.component('register', &#123; template: '&lt;h1&gt;注册&lt;/h1&gt;' &#125;); 将模板字符串，定义到script标签种： 123&lt;script id="tmpl" type="x-template"&gt; &lt;div&gt;&lt;a href="#"&gt;登录&lt;/a&gt; | &lt;a href="#"&gt;注册&lt;/a&gt;&lt;/div&gt; &lt;/script&gt; 同时，需要使用 Vue.component 来定义组件：123Vue.component('account', &#123; template: '#tmpl' &#125;); 注意： 组件中的DOM结构，有且只能有唯一的根元素（Root Element）来进行包裹！ 组件中展示数据和响应事件 在组件中，data需要被定义为一个方法，例如： 12345678910111213Vue.component('account', &#123; template: '#tmpl', data() &#123; return &#123; msg: '大家好！' &#125; &#125;, methods:&#123; login()&#123; alert('点击了登录按钮'); &#125; &#125; &#125;); 在子组件中，如果将模板字符串，定义到了script标签中，那么，要访问子组件身上的data属性中的值，需要使用this来访问； 【重点】为什么组件中的data属性必须定义为一个方法并返回一个对象 通过计数器案例演示 使用components属性定义局部子组件 组件实例定义方式： 123456789101112131415161718&lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125;, components: &#123; // 定义子组件 account: &#123; // account 组件 template: '&lt;div&gt;&lt;h1&gt;这是Account组件&#123;&#123;name&#125;&#125;&lt;/h1&gt;&lt;login&gt;&lt;/login&gt;&lt;/div&gt;', // 在这里使用定义的子组件 components: &#123; // 定义子组件的子组件 login: &#123; // login 组件 template: "&lt;h3&gt;这是登录组件&lt;/h3&gt;" &#125; &#125; &#125; &#125; &#125;); &lt;/script&gt; 引用组件： 123&lt;div id="app"&gt; &lt;account&gt;&lt;/account&gt; &lt;/div&gt; 使用flag标识符结合v-if和v-else切换组件 页面结构： 12345&lt;div id="app"&gt; &lt;input type="button" value="toggle" @click="flag=!flag"&gt; &lt;my-com1 v-if="flag"&gt;&lt;/my-com1&gt; &lt;my-com2 v-else="flag"&gt;&lt;/my-com2&gt; &lt;/div&gt; Vue实例定义： 123456789101112131415161718&lt;script&gt; Vue.component('myCom1', &#123; template: '&lt;h3&gt;奔波霸&lt;/h3&gt;' &#125;) Vue.component('myCom2', &#123; template: '&lt;h3&gt;霸波奔&lt;/h3&gt;' &#125;) // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; flag: true &#125;, methods: &#123;&#125; &#125;); &lt;/script&gt; 使用:is属性来切换不同的子组件,并添加切换动画 组件实例定义方式： 12345678910111213141516171819202122// 登录组件 const login = Vue.extend(&#123; template: `&lt;div&gt; &lt;h3&gt;登录组件&lt;/h3&gt; &lt;/div&gt;` &#125;); Vue.component('login', login); // 注册组件 const register = Vue.extend(&#123; template: `&lt;div&gt; &lt;h3&gt;注册组件&lt;/h3&gt; &lt;/div&gt;` &#125;); Vue.component('register', register); // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; comName: 'login' &#125;, methods: &#123;&#125; &#125;); 使用component标签，来引用组件，并通过:is属性来指定要加载的组件： 12345678&lt;div id="app"&gt; &lt;a href="#" @click.prevent="comName='login'"&gt;登录&lt;/a&gt; &lt;a href="#" @click.prevent="comName='register'"&gt;注册&lt;/a&gt; &lt;hr&gt; &lt;transition mode="out-in"&gt; &lt;component :is="comName"&gt;&lt;/component&gt; &lt;/transition&gt;&lt;/div&gt; 添加切换样式： 1234567891011121314151617&lt;style&gt; .v-enter, .v-leave-to &#123; opacity: 0; transform: translateX(30px); &#125; .v-enter-active, .v-leave-active &#123; position: absolute; transition: all 0.3s ease; &#125; h3&#123; margin: 0; &#125;&lt;/style&gt; 父组件向子组件传值 组件实例定义方式，注意：一定要使用props属性来定义父组件传递过来的数据 123456789101112131415&lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; msg: '这是父组件中的消息' &#125;, components: &#123; son: &#123; template: '&lt;h1&gt;这是子组件 --- &#123;&#123;finfo&#125;&#125;&lt;/h1&gt;', props: ['finfo'] &#125; &#125; &#125;); &lt;/script&gt; 使用v-bind或简化指令，将数据传递到子组件中： 123&lt;div id="app"&gt; &lt;son :finfo="msg"&gt;&lt;/son&gt; &lt;/div&gt; 子组件向父组件传值 原理：父组件将方法的引用，传递到子组件内部，子组件在内部调用父组件传递过来的方法，同时把要发送给父组件的数据，在调用方法的时候当作参数传递进去； 父组件将方法的引用传递给子组件，其中，getMsg是父组件中methods中定义的方法名称，func是子组件调用传递过来方法时候的方法名称 1&lt;son @func="getMsg"&gt;&lt;/son&gt; 子组件内部通过this.$emit(&#39;方法名&#39;, 要传递的数据)方式，来调用父组件中的方法，同时把数据传递给父组件使用 12345678910111213141516171819202122232425262728293031323334&lt;div id="app"&gt; &lt;!-- 引用父组件 --&gt; &lt;son @func="getMsg"&gt;&lt;/son&gt; &lt;!-- 组件模板定义 --&gt; &lt;script type="x-template" id="son"&gt; &lt;div&gt; &lt;input type="button" value="向父组件传值" @click="sendMsg" /&gt; &lt;/div&gt; &lt;/script&gt; &lt;/div&gt; &lt;script&gt; // 子组件的定义方式 Vue.component('son', &#123; template: '#son', // 组件模板Id methods: &#123; sendMsg() &#123; // 按钮的点击事件 this.$emit('func', 'OK'); // 调用父组件传递过来的方法，同时把数据传递出去 &#125; &#125; &#125;); // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123; getMsg(val)&#123; // 子组件中，通过 this.$emit() 实际调用的方法，在此进行定义 alert(val); &#125; &#125; &#125;); &lt;/script&gt; 评论列表案例目标：主要练习父子组件之间传值 使用 this.$refs 来获取元素和组件123456789101112131415161718192021222324252627282930313233343536&lt;div id="app"&gt; &lt;div&gt; &lt;input type="button" value="获取元素内容" @click="getElement" /&gt; &lt;!-- 使用 ref 获取元素 --&gt; &lt;h1 ref="myh1"&gt;这是一个大大的H1&lt;/h1&gt; &lt;hr&gt; &lt;!-- 使用 ref 获取子组件 --&gt; &lt;my-com ref="mycom"&gt;&lt;/my-com&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; Vue.component('my-com', &#123; template: '&lt;h5&gt;这是一个子组件&lt;/h5&gt;', data() &#123; return &#123; name: '子组件' &#125; &#125; &#125;); // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123; getElement() &#123; // 通过 this.$refs 来获取元素 console.log(this.$refs.myh1.innerText); // 通过 this.$refs 来获取组件 console.log(this.$refs.mycom.name); &#125; &#125; &#125;);&lt;/script&gt; 什么是路由 对于普通的网站，所有的超链接都是URL地址，所有的URL地址都对应服务器上对应的资源； 对于单页面应用程序来说，主要通过URL中的hash(#号)来实现不同页面之间的切换，同时，hash有一个特点：HTTP请求中不会包含hash相关的内容；所以，单页面程序中的页面跳转主要用hash实现； 在单页面应用程序中，这种通过hash改变来切换页面的方式，称作前端路由（区别于后端路由）； 在 vue 中使用 vue-router 导入 vue-router 组件类库： 12&lt;!-- 1. 导入 vue-router 组件类库 --&gt; &lt;script src="./lib/vue-router-2.7.0.js"&gt;&lt;/script&gt; 使用 router-link 组件来导航 123&lt;!-- 2. 使用 router-link 组件来导航 --&gt;&lt;router-link to="/login"&gt;登录&lt;/router-link&gt;&lt;router-link to="/register"&gt;注册&lt;/router-link&gt; 使用 router-view 组件来显示匹配到的组件 12&lt;!-- 3. 使用 router-view 组件来显示匹配到的组件 --&gt;&lt;router-view&gt;&lt;/router-view&gt; 创建使用Vue.extend创建组件 123456789// 4.1 使用 Vue.extend 来创建登录组件var login = Vue.extend(&#123; template: '&lt;h1&gt;登录组件&lt;/h1&gt;'&#125;);// 4.2 使用 Vue.extend 来创建注册组件var register = Vue.extend(&#123; template: '&lt;h1&gt;注册组件&lt;/h1&gt;'&#125;); 创建一个路由 router 实例，通过 routers 属性来定义路由匹配规则 1234567// 5. 创建一个路由 router 实例，通过 routers 属性来定义路由匹配规则 var router = new VueRouter(&#123; routes: [ &#123; path: '/login', component: login &#125;, &#123; path: '/register', component: register &#125; ] &#125;); 使用 router 属性来使用路由规则 12345// 6. 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', router: router // 使用 router 属性来使用路由规则 &#125;); 设置路由高亮设置路由切换动效在路由规则中定义参数 在规则中定义参数： 1&#123; path: '/register/:id', component: register &#125; 通过 this.$route.params来获取路由中的参数： 123var register = Vue.extend(&#123; template: '&lt;h1&gt;注册组件 --- &#123;&#123;this.$route.params.id&#125;&#125;&lt;/h1&gt;' &#125;); 使用 children 属性实现路由嵌套1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;div id="app"&gt; &lt;router-link to="/account"&gt;Account&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;&lt;script&gt; // 父路由中的组件 const account = Vue.extend(&#123; template: `&lt;div&gt; 这是account组件 &lt;router-link to="/account/login"&gt;login&lt;/router-link&gt; | &lt;router-link to="/account/register"&gt;register&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;` &#125;); // 子路由中的 login 组件 const login = Vue.extend(&#123; template: '&lt;div&gt;登录组件&lt;/div&gt;' &#125;); // 子路由中的 register 组件 const register = Vue.extend(&#123; template: '&lt;div&gt;注册组件&lt;/div&gt;' &#125;); // 路由实例 var router = new VueRouter(&#123; routes: [ &#123; path: '/', redirect: '/account/login' &#125;, // 使用 redirect 实现路由重定向 &#123; path: '/account', component: account, children: [ // 通过 children 数组属性，来实现路由的嵌套 &#123; path: 'login', component: login &#125;, // 注意，子路由的开头位置，不要加 / 路径符 &#123; path: 'register', component: register &#125; ] &#125; ] &#125;); // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125;, components: &#123; account &#125;, router: router &#125;);&lt;/script&gt; 命名视图实现经典布局 标签代码结构： 1234567&lt;div id="app"&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;div class="content"&gt; &lt;router-view name="a"&gt;&lt;/router-view&gt; &lt;router-view name="b"&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt; JS代码： 12345678910111213141516171819202122232425262728293031323334&lt;script&gt; var header = Vue.component('header', &#123; template: '&lt;div class="header"&gt;header&lt;/div&gt;' &#125;); var sidebar = Vue.component('sidebar', &#123; template: '&lt;div class="sidebar"&gt;sidebar&lt;/div&gt;' &#125;); var mainbox = Vue.component('mainbox', &#123; template: '&lt;div class="mainbox"&gt;mainbox&lt;/div&gt;' &#125;); // 创建路由对象 var router = new VueRouter(&#123; routes: [ &#123; path: '/', components: &#123; default: header, a: sidebar, b: mainbox &#125; &#125; ] &#125;); // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125;, router &#125;); &lt;/script&gt; CSS 样式： 12345678910111213141516171819&lt;style&gt; .header &#123; border: 1px solid red; &#125; .content&#123; display: flex; &#125; .sidebar &#123; flex: 2; border: 1px solid green; height: 500px; &#125; .mainbox&#123; flex: 8; border: 1px solid blue; height: 500px; &#125;&lt;/style&gt; watch属性的使用考虑一个问题：想要实现 名 和 姓 两个文本框的内容改变，则全名的文本框中的值也跟着改变；（用以前的知识如何实现？？？） 监听data中属性的改变： 1234567891011121314151617181920212223242526&lt;div id="app"&gt; &lt;input type="text" v-model="firstName"&gt; + &lt;input type="text" v-model="lastName"&gt; = &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; firstName: 'jack', lastName: 'chen', fullName: 'jack - chen' &#125;, methods: &#123;&#125;, watch: &#123; 'firstName': function (newVal, oldVal) &#123; // 第一个参数是新数据，第二个参数是旧数据 this.fullName = newVal + ' - ' + this.lastName; &#125;, 'lastName': function (newVal, oldVal) &#123; this.fullName = this.firstName + ' - ' + newVal; &#125; &#125; &#125;); &lt;/script&gt; 监听路由对象的改变： 1234567891011121314151617181920212223242526272829303132333435363738&lt;div id="app"&gt; &lt;router-link to="/login"&gt;登录&lt;/router-link&gt; &lt;router-link to="/register"&gt;注册&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script&gt; var login = Vue.extend(&#123; template: '&lt;h1&gt;登录组件&lt;/h1&gt;' &#125;); var register = Vue.extend(&#123; template: '&lt;h1&gt;注册组件&lt;/h1&gt;' &#125;); var router = new VueRouter(&#123; routes: [ &#123; path: "/login", component: login &#125;, &#123; path: "/register", component: register &#125; ] &#125;); // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125;, router: router, watch: &#123; '$route': function (newVal, oldVal) &#123; if (newVal.path === '/login') &#123; console.log('这是登录组件'); &#125; &#125; &#125; &#125;); &lt;/script&gt; computed计算属性的使用 默认只有getter的计算属性： 12345678910111213141516171819202122&lt;div id="app"&gt; &lt;input type="text" v-model="firstName"&gt; + &lt;input type="text" v-model="lastName"&gt; = &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; firstName: 'jack', lastName: 'chen' &#125;, methods: &#123;&#125;, computed: &#123; // 计算属性； 特点：当计算属性中所以来的任何一个 data 属性改变之后，都会重新触发 本计算属性 的重新计算，从而更新 fullName 的值 fullName() &#123; return this.firstName + ' - ' + this.lastName; &#125; &#125; &#125;); &lt;/script&gt; 定义有getter和setter的计算属性： 123456789101112131415161718192021222324252627282930313233343536&lt;div id="app"&gt; &lt;input type="text" v-model="firstName"&gt; &lt;input type="text" v-model="lastName"&gt; &lt;!-- 点击按钮重新为 计算属性 fullName 赋值 --&gt; &lt;input type="button" value="修改fullName" @click="changeName"&gt; &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; firstName: 'jack', lastName: 'chen' &#125;, methods: &#123; changeName() &#123; this.fullName = 'TOM - chen2'; &#125; &#125;, computed: &#123; fullName: &#123; get: function () &#123; return this.firstName + ' - ' + this.lastName; &#125;, set: function (newVal) &#123; var parts = newVal.split(' - '); this.firstName = parts[0]; this.lastName = parts[1]; &#125; &#125; &#125; &#125;); &lt;/script&gt; watch、computed和methods之间的对比 computed属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。主要当作属性来使用； methods方法表示一个具体的操作，主要书写业务逻辑； watch一个对象，键是需要观察的表达式，值是对应回调函数。主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作；可以看作是computed和methods的结合体； nrm的安装使用作用：提供了一些最常用的NPM包镜像地址，能够让我们快速的切换安装包时候的服务器地址；什么是镜像：原来包刚一开始是只存在于国外的NPM服务器，但是由于网络原因，经常访问不到，这时候，我们可以在国内，创建一个和官网完全一样的NPM服务器，只不过，数据都是从人家那里拿过来的，除此之外，使用方式完全一样； 运行npm i nrm -g全局安装nrm包； 使用nrm ls查看当前所有可用的镜像源地址以及当前所使用的镜像源地址； 使用nrm use npm或nrm use taobao切换不同的镜像源地址； 相关文件 URL中的hash（井号）]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue.js - day4]]></title>
    <url>%2F2019%2F06%2F04%2FVue.js%20-%20Day4%2F</url>
    <content type="text"><![CDATA[@[toc] Vue.js - Day4父组件向子组件传值 组件实例定义方式，注意：一定要使用props属性来定义父组件传递过来的数据 123456789101112131415&lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; msg: '这是父组件中的消息' &#125;, components: &#123; son: &#123; template: '&lt;h1&gt;这是子组件 --- &#123;&#123;finfo&#125;&#125;&lt;/h1&gt;', props: ['finfo'] &#125; &#125; &#125;); &lt;/script&gt; 使用v-bind或简化指令，将数据传递到子组件中： 123&lt;div id="app"&gt; &lt;son :finfo="msg"&gt;&lt;/son&gt; &lt;/div&gt; 子组件向父组件传值 原理：父组件将方法的引用，传递到子组件内部，子组件在内部调用父组件传递过来的方法，同时把要发送给父组件的数据，在调用方法的时候当作参数传递进去； 父组件将方法的引用传递给子组件，其中，getMsg是父组件中methods中定义的方法名称，func是子组件调用传递过来方法时候的方法名称 1&lt;son @func="getMsg"&gt;&lt;/son&gt; 子组件内部通过this.$emit(&#39;方法名&#39;, 要传递的数据)方式，来调用父组件中的方法，同时把数据传递给父组件使用 12345678910111213141516171819202122232425262728293031323334&lt;div id="app"&gt; &lt;!-- 引用父组件 --&gt; &lt;son @func="getMsg"&gt;&lt;/son&gt; &lt;!-- 组件模板定义 --&gt; &lt;script type="x-template" id="son"&gt; &lt;div&gt; &lt;input type="button" value="向父组件传值" @click="sendMsg" /&gt; &lt;/div&gt; &lt;/script&gt; &lt;/div&gt; &lt;script&gt; // 子组件的定义方式 Vue.component('son', &#123; template: '#son', // 组件模板Id methods: &#123; sendMsg() &#123; // 按钮的点击事件 this.$emit('func', 'OK'); // 调用父组件传递过来的方法，同时把数据传递出去 &#125; &#125; &#125;); // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123; getMsg(val)&#123; // 子组件中，通过 this.$emit() 实际调用的方法，在此进行定义 alert(val); &#125; &#125; &#125;); &lt;/script&gt; 组件中data和props的区别评论列表案例目标：主要练习父子组件之间传值 使用 this.$refs 来获取元素和组件123456789101112131415161718192021222324252627282930313233343536&lt;div id="app"&gt; &lt;div&gt; &lt;input type="button" value="获取元素内容" @click="getElement" /&gt; &lt;!-- 使用 ref 获取元素 --&gt; &lt;h1 ref="myh1"&gt;这是一个大大的H1&lt;/h1&gt; &lt;hr&gt; &lt;!-- 使用 ref 获取子组件 --&gt; &lt;my-com ref="mycom"&gt;&lt;/my-com&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; Vue.component('my-com', &#123; template: '&lt;h5&gt;这是一个子组件&lt;/h5&gt;', data() &#123; return &#123; name: '子组件' &#125; &#125; &#125;); // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123; getElement() &#123; // 通过 this.$refs 来获取元素 console.log(this.$refs.myh1.innerText); // 通过 this.$refs 来获取组件 console.log(this.$refs.mycom.name); &#125; &#125; &#125;);&lt;/script&gt; 什么是路由 后端路由：对于普通的网站，所有的超链接都是URL地址，所有的URL地址都对应服务器上对应的资源； 前端路由：对于单页面应用程序来说，主要通过URL中的hash(#号)来实现不同页面之间的切换，同时，hash有一个特点：HTTP请求中不会包含hash相关的内容；所以，单页面程序中的页面跳转主要用hash实现； 在单页面应用程序中，这种通过hash改变来切换页面的方式，称作前端路由（区别于后端路由）； 在 vue 中使用 vue-router 导入 vue-router 组件类库： 12&lt;!-- 1. 导入 vue-router 组件类库 --&gt; &lt;script src="./lib/vue-router-2.7.0.js"&gt;&lt;/script&gt; 使用 router-link 组件来导航 123&lt;!-- 2. 使用 router-link 组件来导航 --&gt;&lt;router-link to="/login"&gt;登录&lt;/router-link&gt;&lt;router-link to="/register"&gt;注册&lt;/router-link&gt; 使用 router-view 组件来显示匹配到的组件 12&lt;!-- 3. 使用 router-view 组件来显示匹配到的组件 --&gt;&lt;router-view&gt;&lt;/router-view&gt; 创建使用Vue.extend创建组件 123456789// 4.1 使用 Vue.extend 来创建登录组件var login = Vue.extend(&#123; template: '&lt;h1&gt;登录组件&lt;/h1&gt;'&#125;);// 4.2 使用 Vue.extend 来创建注册组件var register = Vue.extend(&#123; template: '&lt;h1&gt;注册组件&lt;/h1&gt;'&#125;); 创建一个路由 router 实例，通过 routers 属性来定义路由匹配规则 1234567// 5. 创建一个路由 router 实例，通过 routers 属性来定义路由匹配规则 var router = new VueRouter(&#123; routes: [ &#123; path: '/login', component: login &#125;, &#123; path: '/register', component: register &#125; ] &#125;); 使用 router 属性来使用路由规则 12345// 6. 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', router: router // 使用 router 属性来使用路由规则 &#125;); 使用tag属性指定router-link渲染的标签类型设置路由重定向设置路由高亮设置路由切换动效在路由规则中定义参数 在规则中定义参数： 1&#123; path: '/register/:id', component: register &#125; 通过 this.$route.params来获取路由中的参数： 123var register = Vue.extend(&#123; template: '&lt;h1&gt;注册组件 --- &#123;&#123;this.$route.params.id&#125;&#125;&lt;/h1&gt;' &#125;); 使用 children 属性实现路由嵌套1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;div id="app"&gt; &lt;router-link to="/account"&gt;Account&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;&lt;script&gt; // 父路由中的组件 const account = Vue.extend(&#123; template: `&lt;div&gt; 这是account组件 &lt;router-link to="/account/login"&gt;login&lt;/router-link&gt; | &lt;router-link to="/account/register"&gt;register&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;` &#125;); // 子路由中的 login 组件 const login = Vue.extend(&#123; template: '&lt;div&gt;登录组件&lt;/div&gt;' &#125;); // 子路由中的 register 组件 const register = Vue.extend(&#123; template: '&lt;div&gt;注册组件&lt;/div&gt;' &#125;); // 路由实例 var router = new VueRouter(&#123; routes: [ &#123; path: '/', redirect: '/account/login' &#125;, // 使用 redirect 实现路由重定向 &#123; path: '/account', component: account, children: [ // 通过 children 数组属性，来实现路由的嵌套 &#123; path: 'login', component: login &#125;, // 注意，子路由的开头位置，不要加 / 路径符 &#123; path: 'register', component: register &#125; ] &#125; ] &#125;); // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125;, components: &#123; account &#125;, router: router &#125;);&lt;/script&gt; 命名视图实现经典布局 标签代码结构： 1234567&lt;div id="app"&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;div class="content"&gt; &lt;router-view name="a"&gt;&lt;/router-view&gt; &lt;router-view name="b"&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt; JS代码： 12345678910111213141516171819202122232425262728293031323334&lt;script&gt; var header = Vue.component('header', &#123; template: '&lt;div class="header"&gt;header&lt;/div&gt;' &#125;); var sidebar = Vue.component('sidebar', &#123; template: '&lt;div class="sidebar"&gt;sidebar&lt;/div&gt;' &#125;); var mainbox = Vue.component('mainbox', &#123; template: '&lt;div class="mainbox"&gt;mainbox&lt;/div&gt;' &#125;); // 创建路由对象 var router = new VueRouter(&#123; routes: [ &#123; path: '/', components: &#123; default: header, a: sidebar, b: mainbox &#125; &#125; ] &#125;); // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125;, router &#125;); &lt;/script&gt; CSS 样式： 12345678910111213141516171819&lt;style&gt; .header &#123; border: 1px solid red; &#125; .content&#123; display: flex; &#125; .sidebar &#123; flex: 2; border: 1px solid green; height: 500px; &#125; .mainbox&#123; flex: 8; border: 1px solid blue; height: 500px; &#125;&lt;/style&gt; watch属性的使用考虑一个问题：想要实现 名 和 姓 两个文本框的内容改变，则全名的文本框中的值也跟着改变；（用以前的知识如何实现？？？） 监听data中属性的改变： 1234567891011121314151617181920212223242526&lt;div id="app"&gt; &lt;input type="text" v-model="firstName"&gt; + &lt;input type="text" v-model="lastName"&gt; = &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; firstName: 'jack', lastName: 'chen', fullName: 'jack - chen' &#125;, methods: &#123;&#125;, watch: &#123; 'firstName': function (newVal, oldVal) &#123; // 第一个参数是新数据，第二个参数是旧数据 this.fullName = newVal + ' - ' + this.lastName; &#125;, 'lastName': function (newVal, oldVal) &#123; this.fullName = this.firstName + ' - ' + newVal; &#125; &#125; &#125;); &lt;/script&gt; 监听路由对象的改变： 1234567891011121314151617181920212223242526272829303132333435363738&lt;div id="app"&gt; &lt;router-link to="/login"&gt;登录&lt;/router-link&gt; &lt;router-link to="/register"&gt;注册&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script&gt; var login = Vue.extend(&#123; template: '&lt;h1&gt;登录组件&lt;/h1&gt;' &#125;); var register = Vue.extend(&#123; template: '&lt;h1&gt;注册组件&lt;/h1&gt;' &#125;); var router = new VueRouter(&#123; routes: [ &#123; path: "/login", component: login &#125;, &#123; path: "/register", component: register &#125; ] &#125;); // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125;, router: router, watch: &#123; '$route': function (newVal, oldVal) &#123; if (newVal.path === '/login') &#123; console.log('这是登录组件'); &#125; &#125; &#125; &#125;); &lt;/script&gt; computed计算属性的使用 默认只有getter的计算属性： 12345678910111213141516171819202122&lt;div id="app"&gt; &lt;input type="text" v-model="firstName"&gt; + &lt;input type="text" v-model="lastName"&gt; = &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; firstName: 'jack', lastName: 'chen' &#125;, methods: &#123;&#125;, computed: &#123; // 计算属性； 特点：当计算属性中所以来的任何一个 data 属性改变之后，都会重新触发 本计算属性 的重新计算，从而更新 fullName 的值 fullName() &#123; return this.firstName + ' - ' + this.lastName; &#125; &#125; &#125;); &lt;/script&gt; 定义有getter和setter的计算属性： 123456789101112131415161718192021222324252627282930313233343536&lt;div id="app"&gt; &lt;input type="text" v-model="firstName"&gt; &lt;input type="text" v-model="lastName"&gt; &lt;!-- 点击按钮重新为 计算属性 fullName 赋值 --&gt; &lt;input type="button" value="修改fullName" @click="changeName"&gt; &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; firstName: 'jack', lastName: 'chen' &#125;, methods: &#123; changeName() &#123; this.fullName = 'TOM - chen2'; &#125; &#125;, computed: &#123; fullName: &#123; get: function () &#123; return this.firstName + ' - ' + this.lastName; &#125;, set: function (newVal) &#123; var parts = newVal.split(' - '); this.firstName = parts[0]; this.lastName = parts[1]; &#125; &#125; &#125; &#125;); &lt;/script&gt; watch、computed和methods之间的对比 computed属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。主要当作属性来使用； methods方法表示一个具体的操作，主要书写业务逻辑； watch一个对象，键是需要观察的表达式，值是对应回调函数。主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作；可以看作是computed和methods的结合体； nrm的安装使用作用：提供了一些最常用的NPM包镜像地址，能够让我们快速的切换安装包时候的服务器地址；什么是镜像：原来包刚一开始是只存在于国外的NPM服务器，但是由于网络原因，经常访问不到，这时候，我们可以在国内，创建一个和官网完全一样的NPM服务器，只不过，数据都是从人家那里拿过来的，除此之外，使用方式完全一样； 运行npm i nrm -g全局安装nrm包； 使用nrm ls查看当前所有可用的镜像源地址以及当前所使用的镜像源地址； 使用nrm use npm或nrm use taobao切换不同的镜像源地址； 相关文件 URL中的hash（井号）]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue.js - day5]]></title>
    <url>%2F2019%2F06%2F04%2FVue.js%20-%20Day5%20-%20Webpack%2F</url>
    <content type="text"><![CDATA[@[toc] Vue.js - Day5 - Webpack在网页中会引用哪些常见的静态资源？ JS .js .jsx .coffee .ts（TypeScript 类 C# 语言） CSS .css .less .sass .scss Images .jpg .png .gif .bmp .svg 字体文件（Fonts） .svg .ttf .eot .woff .woff2 模板文件 .ejs .jade .vue【这是在webpack中定义组件的方式，推荐这么用】 网页中引入的静态资源多了以后有什么问题？？？ 网页加载速度慢， 因为 我们要发起很多的二次请求； 要处理错综复杂的依赖关系 如何解决上述两个问题 合并、压缩、精灵图、图片的Base64编码 可以使用之前学过的requireJS、也可以使用webpack可以解决各个包之间的复杂依赖关系； 什么是webpack?webpack 是前端的一个项目构建工具，它是基于 Node.js 开发出来的一个前端工具； 如何完美实现上述的2种解决方案 使用Gulp， 是基于 task 任务的； 使用Webpack， 是基于整个项目进行构建的； 借助于webpack这个前端自动化构建工具，可以完美实现资源的合并、打包、压缩、混淆等诸多功能。 根据官网的图片介绍webpack打包的过程 webpack官网 webpack安装的两种方式 运行npm i webpack -g全局安装webpack，这样就能在全局使用webpack的命令 在项目根目录中运行npm i webpack --save-dev安装到项目依赖中 初步使用webpack打包构建列表隔行变色案例 运行npm init初始化项目，使用npm管理项目中的依赖包 创建项目基本的目录结构 使用cnpm i jquery --save安装jquery类库 创建main.js并书写各行变色的代码逻辑： 1234567// 导入jquery类库 import $ from 'jquery' // 设置偶数行背景色，索引从0开始，0是偶数 $('#list li:even').css('backgroundColor','lightblue'); // 设置奇数行背景色 $('#list li:odd').css('backgroundColor','pink'); 直接在页面上引用main.js会报错，因为浏览器不认识import这种高级的JS语法，需要使用webpack进行处理，webpack默认会把这种高级的语法转换为低级的浏览器能识别的语法； 运行webpack 入口文件路径 输出文件路径对main.js进行处理：1webpack src/js/main.js dist/bundle.js 使用webpack的配置文件简化打包时候的命令 在项目根目录中创建webpack.config.js 由于运行webpack命令的时候，webpack需要指定入口文件和输出文件的路径，所以，我们需要在webpack.config.js中配置这两个路径：1234567891011// 导入处理路径的模块var path = require('path');// 导出一个配置对象，将来webpack在启动的时候，会默认来查找webpack.config.js，并读取这个文件中导出的配置对象，来进行打包处理module.exports = &#123; entry: path.resolve(__dirname, 'src/js/main.js'), // 项目入口文件 output: &#123; // 配置输出选项 path: path.resolve(__dirname, 'dist'), // 配置输出的路径 filename: 'bundle.js' // 配置输出的文件名 &#125;&#125; 实现webpack的实时打包构建 由于每次重新修改代码之后，都需要手动运行webpack打包的命令，比较麻烦，所以使用webpack-dev-server来实现代码实时打包编译，当修改代码之后，会自动进行打包构建。 运行cnpm i webpack-dev-server --save-dev安装到开发依赖 安装完成之后，在命令行直接运行webpack-dev-server来进行打包，发现报错，此时需要借助于package.json文件中的指令，来进行运行webpack-dev-server命令，在scripts节点下新增&quot;dev&quot;: &quot;webpack-dev-server&quot;指令，发现可以进行实时打包，但是dist目录下并没有生成bundle.js文件，这是因为webpack-dev-server将打包好的文件放在了内存中 把bundle.js放在内存中的好处是：由于需要实时打包编译，所以放在内存中速度会非常快 这个时候访问webpack-dev-server启动的http://localhost:8080/网站，发现是一个文件夹的面板，需要点击到src目录下，才能打开我们的index首页，此时引用不到bundle.js文件，需要修改index.html中script的src属性为:&lt;script src=&quot;../bundle.js&quot;&gt;&lt;/script&gt; 为了能在访问http://localhost:8080/的时候直接访问到index首页，可以使用--contentBase src指令来修改dev指令，指定启动的根目录：1"dev": "webpack-dev-server --contentBase src" 同时修改index页面中script的src属性为&lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt; 使用html-webpack-plugin插件配置启动页面由于使用--contentBase指令的过程比较繁琐，需要指定启动的目录，同时还需要修改index.html中script标签的src属性，所以推荐大家使用html-webpack-plugin插件配置启动页面. 运行cnpm i html-webpack-plugin --save-dev安装到开发依赖 修改webpack.config.js配置文件如下： 123456789101112131415161718// 导入处理路径的模块var path = require('path');// 导入自动生成HTMl文件的插件var htmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; entry: path.resolve(__dirname, 'src/js/main.js'), // 项目入口文件 output: &#123; // 配置输出选项 path: path.resolve(__dirname, 'dist'), // 配置输出的路径 filename: 'bundle.js' // 配置输出的文件名 &#125;, plugins:[ // 添加plugins节点配置插件 new htmlWebpackPlugin(&#123; template:path.resolve(__dirname, 'src/index.html'),//模板路径 filename:'index.html'//自动生成的HTML文件的名称 &#125;) ]&#125; 修改package.json中script节点中的dev指令如下： 1"dev": "webpack-dev-server" 将index.html中script标签注释掉，因为html-webpack-plugin插件会自动把bundle.js注入到index.html页面中！ 实现自动打开浏览器、热更新和配置浏览器的默认端口号注意：热更新在JS中表现的不明显，可以从一会儿要讲到的CSS身上进行介绍说明！ 方式1： 修改package.json的script节点如下，其中--open表示自动打开浏览器，--port 4321表示打开的端口号为4321，--hot表示启用浏览器热更新：1"dev": "webpack-dev-server --hot --port 4321 --open" 方式2： 修改webpack.config.js文件，新增devServer节点如下： 12345devServer:&#123; hot:true, open:true, port:4321 &#125; 在头部引入webpack模块： 1var webpack = require('webpack'); 在plugins节点下新增： 1new webpack.HotModuleReplacementPlugin() 使用webpack打包css文件 运行cnpm i style-loader css-loader --save-dev 修改webpack.config.js这个配置文件： 12345module: &#123; // 用来配置第三方loader模块的 rules: [ // 文件的匹配规则 &#123; test: /\.css$/, use: ['style-loader', 'css-loader'] &#125;//处理css文件的规则 ] &#125; 注意：use表示使用哪些模块来处理test所匹配到的文件；use中相关loader模块的调用顺序是从后向前调用的； 使用webpack打包less文件 运行cnpm i less-loader less -D 修改webpack.config.js这个配置文件：1&#123; test: /\.less$/, use: ['style-loader', 'css-loader', 'less-loader'] &#125;, 使用webpack打包sass文件 运行cnpm i sass-loader node-sass --save-dev 在webpack.config.js中添加处理sass文件的loader模块：1&#123; test: /\.scss$/, use: ['style-loader', 'css-loader', 'sass-loader'] &#125; 使用webpack处理css中的路径 运行cnpm i url-loader file-loader --save-dev 在webpack.config.js中添加处理url路径的loader模块： 1&#123; test: /\.(png|jpg|gif)$/, use: 'url-loader' &#125; 可以通过limit指定进行base64编码的图片大小；只有小于指定字节（byte）的图片才会进行base64编码： 1&#123; test: /\.(png|jpg|gif)$/, use: 'url-loader?limit=43960' &#125;, 使用babel处理高级JS语法 运行cnpm i babel-core babel-loader babel-plugin-transform-runtime --save-dev安装babel的相关loader包 运行cnpm i babel-preset-es2015 babel-preset-stage-0 --save-dev安装babel转换的语法 在webpack.config.js中添加相关loader模块，其中需要注意的是，一定要把node_modules文件夹添加到排除项： 1&#123; test: /\.js$/, use: 'babel-loader', exclude: /node_modules/ &#125; 在项目根目录中添加.babelrc文件，并修改这个配置文件如下： 1234&#123; "presets":["es2015", "stage-0"], "plugins":["transform-runtime"]&#125; 注意：语法插件babel-preset-es2015可以更新为babel-preset-env，它包含了所有的ES相关的语法； 相关文章babel-preset-env：你需要的唯一Babel插件Runtime transform 运行时编译es6]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue.js - day6]]></title>
    <url>%2F2019%2F06%2F04%2FVue.js%20-%20day6%2F</url>
    <content type="text"><![CDATA[[TOC] Vue.js - day6注意：有时候使用npm i node-sass -D装不上，这时候，就必须使用 cnpm i node-sass -D 在普通页面中使用render函数渲染组件在webpack中配置.vue组件页面的解析 运行cnpm i vue -S将vue安装为运行依赖； 运行cnpm i vue-loader vue-template-compiler -D将解析转换vue的包安装为开发依赖； 运行cnpm i style-loader css-loader -D将解析转换CSS的包安装为开发依赖，因为.vue文件中会写CSS样式； 在webpack.config.js中，添加如下module规则： 123456789101112module: &#123; rules: [ &#123; test: /\.css$/, use: ['style-loader', 'css-loader'] &#125;, &#123; test: /\.vue$/, use: 'vue-loader' &#125; ] &#125; 创建App.js组件页面： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;template&gt; &lt;!-- 注意：在 .vue 的组件中，template 中必须有且只有唯一的根元素进行包裹，一般都用 div 当作唯一的根元素 --&gt; &lt;div&gt; &lt;h1&gt;这是APP组件 - &#123;&#123;msg&#125;&#125;&lt;/h1&gt; &lt;h3&gt;我是h3&lt;/h3&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// 注意：在 .vue 的组件中，通过 script 标签来定义组件的行为，需要使用 ES6 中提供的 export default 方式，导出一个vue实例对象export default &#123; data() &#123; return &#123; msg: 'OK' &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;h1 &#123; color: red;&#125;&lt;/style&gt; 创建main.js入口文件： 12345678910111213141516171819202122// 导入 Vue 组件import Vue from 'vue'// 导入 App组件import App from './components/App.vue'// 创建一个 Vue 实例，使用 render 函数，渲染指定的组件var vm = new Vue(&#123; el: '#app', render: c =&gt; c(App)&#125;); 在使用webpack构建的Vue项目中使用模板对象？ 在webpack.config.js中添加resolve属性：12345resolve: &#123; alias: &#123; 'vue$': 'vue/dist/vue.esm.js' &#125; &#125; ES6中语法使用总结 使用 export default 和 export 导出模块中的成员; 对应ES5中的 module.exports 和 export 使用 import ** from ** 和 import &#39;路径&#39; 还有 import {a, b} from &#39;模块标识&#39; 导入其他模块 使用箭头函数：(a, b)=&gt; { return a-b; } 在vue组件页面中，集成vue-router路由模块vue-router官网 导入路由模块： 12import VueRouter from 'vue-router' 安装路由模块： 12Vue.use(VueRouter); 导入需要展示的组件: 1234import login from './components/account/login.vue'import register from './components/account/register.vue' 创建路由对象: 1234567891011121314var router = new VueRouter(&#123; routes: [ &#123; path: '/', redirect: '/login' &#125;, &#123; path: '/login', component: login &#125;, &#123; path: '/register', component: register &#125; ]&#125;); 将路由对象，挂载到 Vue 实例上: 12345678910111213141516var vm = new Vue(&#123; el: '#app', // render: c =&gt; &#123; return c(App) &#125; render(c) &#123; return c(App); &#125;, router // 将路由对象，挂载到 Vue 实例上&#125;); 改造App.vue组件，在 template 中，添加router-link和router-view： 12345678&lt;router-link to="/login"&gt;登录&lt;/router-link&gt;&lt;router-link to="/register"&gt;注册&lt;/router-link&gt;&lt;router-view&gt;&lt;/router-view&gt; 组件中的css作用域问题抽离路由为单独的模块使用 饿了么的 MintUI 组件Github 仓储地址 Mint-UI官方文档 导入所有MintUI组件： 12import MintUI from 'mint-ui' 导入样式表： 12import 'mint-ui/lib/style.css' 在 vue 中使用 MintUI： 12Vue.use(MintUI) 使用的例子： 12&lt;mt-button type="primary" size="large"&gt;primary&lt;/mt-button&gt; 使用 MUI 组件官网首页 文档地址 导入 MUI 的样式表： 12import '../lib/mui/css/mui.min.css' 在webpack.config.js中添加新的loader规则： 12&#123; test: /\.(png|jpg|gif|ttf)$/, use: 'url-loader' &#125; 根据官方提供的文档和example，尝试使用相关的组件 将项目源码托管到oschina中 点击头像 -&gt; 修改资料 -&gt; SSH公钥 如何生成SSH公钥 创建自己的空仓储，使用 git config --global user.name &quot;用户名&quot; 和 git config --global user.email ***@**.com 来全局配置提交时用户的名称和邮箱 使用 git init 在本地初始化项目 使用 touch README.md 和 touch .gitignore 来创建项目的说明文件和忽略文件； 使用 git add . 将所有文件托管到 git 中 使用 git commit -m &quot;init project&quot; 将项目进行本地提交 使用 git remote add origin 仓储地址将本地项目和远程仓储连接，并使用origin最为远程仓储的别名 使用 git push -u origin master 将本地代码push到仓储中 App.vue 组件的基本设置 头部的固定导航栏使用 Mint-UI 的 Header 组件； 底部的页签使用 mui 的 tabbar; 购物车的图标，使用 icons-extra 中的 mui-icon-extra mui-icon-extra-cart，同时，应该把其依赖的字体图标文件 mui-icons-extra.ttf，复制到 fonts 目录下！ 将底部的页签，改造成 router-link 来实现单页面的切换； Tab Bar 路由激活时候设置高亮的两种方式： 全局设置样式如下： 123456.router-link-active&#123; color:#007aff !important; &#125; 或者在 new VueRouter 的时候，通过 linkActiveClass 来指定高亮的类： 1234567891011121314// 创建路由对象 var router = new VueRouter(&#123; routes: [ &#123; path: '/', redirect: '/home' &#125; ], linkActiveClass: 'mui-active' &#125;); 实现 tabbar 页签不同组件页面的切换 将 tabbar 改造成 router-link 形式，并指定每个连接的 to 属性； 在入口文件中导入需要展示的组件，并创建路由对象： 12345678910111213141516171819202122232425262728293031323334// 导入需要展示的组件import Home from './components/home/home.vue'import Member from './components/member/member.vue'import Shopcar from './components/shopcar/shopcar.vue'import Search from './components/search/search.vue'// 创建路由对象var router = new VueRouter(&#123; routes: [ &#123; path: '/', redirect: '/home' &#125;, &#123; path: '/home', component: Home &#125;, &#123; path: '/member', component: Member &#125;, &#123; path: '/shopcar', component: Shopcar &#125;, &#123; path: '/search', component: Search &#125; ], linkActiveClass: 'mui-active'&#125;); 使用 mt-swipe 轮播图组件 假数据： 12345678910lunbo: [ 'http://www.itcast.cn/images/slidead/BEIJING/2017440109442800.jpg', 'http://www.itcast.cn/images/slidead/BEIJING/2017511009514700.jpg', 'http://www.itcast.cn/images/slidead/BEIJING/2017421414422600.jpg' ] 引入轮播图组件： 123456789101112131415161718&lt;!-- Mint-UI 轮播图组件 --&gt; &lt;div class="home-swipe"&gt; &lt;mt-swipe :auto="4000"&gt; &lt;mt-swipe-item v-for="(item, i) in lunbo" :key="i"&gt; &lt;img :src="item" alt=""&gt; &lt;/mt-swipe-item&gt; &lt;/mt-swipe&gt; &lt;/div&gt; &lt;/div&gt; 在.vue组件中使用vue-resource获取数据 运行cnpm i vue-resource -S安装模块 导入 vue-resource 组件 12import VueResource from 'vue-resource' 在vue中使用 vue-resource 组件 12Vue.use(VueResource);]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue.js - day9]]></title>
    <url>%2F2019%2F06%2F04%2Fvue.js%20-%20day.9%2F</url>
    <content type="text"><![CDATA[概念：vuex 是 Vue 配套的 公共数据管理工具，它可以把一些共享的数据，保存到 vuex 中，方便 整个程序中的任何组件直接获取或修改我们的公共数据；]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue.js--day8]]></title>
    <url>%2F2019%2F06%2F04%2Fvue.js%20-%20day8%2F</url>
    <content type="text"><![CDATA[day8使用mui的tab-top-webview-main完成分类滑动栏兼容问题 和 App.vue 中的 router-link 身上的类名 mui-tab-item 存在兼容性问题，导致tab栏失效，可以把mui-tab-item改名为mui-tab-item1，并复制相关的类样式，来解决这个问题； 123456789101112131415161718192021222324252627282930.mui-bar-tab .mui-tab-item1.mui-active &#123; color: #007aff;&#125;.mui-bar-tab .mui-tab-item1 &#123; display: table-cell; overflow: hidden; width: 1%; height: 50px; text-align: center; vertical-align: middle; white-space: nowrap; text-overflow: ellipsis; color: #929292;&#125;.mui-bar-tab .mui-tab-item1 .mui-icon &#123; top: 3px; width: 24px; height: 24px; padding-top: 0; padding-bottom: 0;&#125;.mui-bar-tab .mui-tab-item1 .mui-icon~.mui-tab-label &#123; font-size: 11px; display: block; overflow: hidden; text-overflow: ellipsis;&#125; tab-top-webview-main组件第一次显示到页面中的时候，无法被滑动的解决方案： 先导入 mui 的JS文件: 1import mui from '../../../lib/mui/js/mui.min.js' 在 组件的 mounted 事件钩子中，注册 mui 的滚动事件： 123456mounted() &#123; // 需要在组件的 mounted 事件钩子中，注册 mui 的 scroll 滚动事件 mui('.mui-scroll-wrapper').scroll(&#123; deceleration: 0.0005 //flick 减速系数，系数越大，滚动速度越慢，滚动距离越小，默认值0.0006 &#125;); &#125; 滑动的时候报警告：Unable to preventDefault inside passive event listener due to target being treated as passive. See https://www.chromestatus.com/features/5093566007214080 1解决方法，可以加上* &#123; touch-action: none; &#125; 这句样式去掉。 原因：（是chrome为了提高页面的滑动流畅度而新折腾出来的一个东西） http://www.cnblogs.com/pearl07/p/6589114.htmlhttps://developer.mozilla.org/zh-CN/docs/Web/CSS/touch-action 移除严格模式babel-plugin-transform-remove-strict-mode vue-preview一个Vue集成PhotoSwipe图片预览插件]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue.js - day10]]></title>
    <url>%2F2019%2F06%2F04%2Fvue.js%20-%20day10%2F</url>
    <content type="text"><![CDATA[[TOC] Day10开启Apache的gzip压缩要让apache支持gzip功能，要用到deflate_Module和headers_Module。打开apache的配置文件httpd.conf，大约在105行左右，找到以下两行内容：（这两行不是连续在一起的）12#LoadModule deflate_module modules/mod_deflate.so#LoadModule headers_module modules/mod_headers.so 然后将其前面的“#”注释删掉，表示开启gzip压缩功能。开启以后还需要进行相关配置。在httpd.conf文件的最后添加以下内容即可：12345&lt;IfModule deflate_module&gt; #必须的，就像一个开关一样，告诉apache对传输到浏览器的内容进行压缩 SetOutputFilter DEFLATE DeflateCompressionLevel 9&lt;/IfModule&gt; 最少需要加上以上内容，才可以生gzip功能生效。由于没有做其它的额外配置，所以其它相关的配置均使用Apache的默认设置。这里说一下参数“DeflateCompressionLevel”，它表示压缩级别，值从1到9，值越大表示压缩的越厉害。 使用ngrok将本机映射为一个外网的Web服务器注意：由于默认使用的美国的服务器进行中间转接，所以访问速度炒鸡慢，访问时可启用FQ软件，提高网页打开速度！]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue.js - day7]]></title>
    <url>%2F2019%2F06%2F04%2Fvue.js%20-%20day7%2F</url>
    <content type="text"><![CDATA[[TOC] day7使用mui的tab-top-webview-main完成分类滑动栏兼容问题 和 App.vue 中的 router-link 身上的类名 mui-tab-item 存在兼容性问题，导致tab栏失效，可以把mui-tab-item改名为mui-tab-item1，并复制相关的类样式，来解决这个问题； 123456789101112131415161718192021222324252627282930.mui-bar-tab .mui-tab-item1.mui-active &#123; color: #007aff;&#125;.mui-bar-tab .mui-tab-item1 &#123; display: table-cell; overflow: hidden; width: 1%; height: 50px; text-align: center; vertical-align: middle; white-space: nowrap; text-overflow: ellipsis; color: #929292;&#125;.mui-bar-tab .mui-tab-item1 .mui-icon &#123; top: 3px; width: 24px; height: 24px; padding-top: 0; padding-bottom: 0;&#125;.mui-bar-tab .mui-tab-item1 .mui-icon~.mui-tab-label &#123; font-size: 11px; display: block; overflow: hidden; text-overflow: ellipsis;&#125; tab-top-webview-main组件第一次显示到页面中的时候，无法被滑动的解决方案： 先导入 mui 的JS文件: 1import mui from '../../../lib/mui/js/mui.min.js' 在 组件的 mounted 事件钩子中，注册 mui 的滚动事件： 123456mounted() &#123; // 需要在组件的 mounted 事件钩子中，注册 mui 的 scroll 滚动事件 mui('.mui-scroll-wrapper').scroll(&#123; deceleration: 0.0005 //flick 减速系数，系数越大，滚动速度越慢，滚动距离越小，默认值0.0006 &#125;); &#125; 滑动的时候报警告：Unable to preventDefault inside passive event listener due to target being treated as passive. See https://www.chromestatus.com/features/5093566007214080 1解决方法，可以加上* &#123; touch-action: none; &#125; 这句样式去掉。 原因：（是chrome为了提高页面的滑动流畅度而新折腾出来的一个东西） http://www.cnblogs.com/pearl07/p/6589114.htmlhttps://developer.mozilla.org/zh-CN/docs/Web/CSS/touch-action 移除严格模式babel-plugin-transform-remove-strict-mode vue-preview一个Vue集成PhotoSwipe图片预览插件]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js 第6天]]></title>
    <url>%2F2019%2F06%2F04%2FNode.js%20%E7%AC%AC6%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[## 知识点 多人社区案例 复习 MongoDB 数据库 灵活 不用设计数据表 业务的改动不需要关心数据表结构 DBA 架构师 级别的工程师都需要掌握这项技能 设计 维护 分布式计算 mongoose mongodb 官方包也可以操作 MongoDB 数据库 第三方包：WordPress 项目开发团队 设计 Schema 发布 Model（得到模型构造函数） 查询 增加 修改 删除 Promise http://es6.ruanyifeng.com/#docs/promise callback hell 回调地狱 回调函数中套了回调函数 Promise(EcmaScript 6 中新增了一个语法 API) 容器 异步任务（pending） resolve reject then 方法获取容器的结果（成功的，失败的） then 方法支持链式调用 可以在 then 方法中返回一个 promise 对象，然后在后面的 then 方法中获取上一个 then 返回的 promise 对象的状态结果 上午总结下午总结总结 path 模块 dirname 和 filename 动态的 获取当前文件或者文件所处目录的绝对路径 用来解决文件操作路劲的相对路径问题 因为在文件操作中，相对路径相对于执行 node 命令所处的目录 所以为了尽量避免这个问题，都建议文件操作的相对路劲都转为：动态的绝对路径 方式：path.join(__dirname, &#39;文件名&#39;) art-template 模板引擎(include、block、extend) include extend block 表单同步提交和异步提交区别 以前没有 ajax 都是这么干的，甚至有些直接就是渲染了提示信息出来了 异步提交页面不会刷新，交互方式更灵活 Express 中配置使用 express-session 插件 概述案例中注册-登陆-退出的前后端交互实现流程 path 模块 dirname 和 filename 动态的 获取当前文件或者文件所处目录的绝对路径 用来解决文件操作路劲的相对路径问题 因为在文件操作中，相对路径相对于执行 node 命令所处的目录 所以为了尽量避免这个问题，都建议文件操作的相对路劲都转为：动态的绝对路径 方式：path.join(__dirname, &#39;文件名&#39;) art-template 模板引擎(include、block、extend) include extend block 动手写一写 表单同步提交和异步提交区别 字符串交互 请求（报文、具有一定格式的字符串） HTTP 就是 Web 中的沟通语言 服务器响应（字符串） 01 服务器端重定向针对异步请求无效 Express 中配置使用 express-session 插件 插件也是工具 你只需要明确你的目标就可以了 我们最终的目标就是使用 Session 来帮我们管理一些敏感信息数据状态，例如保存登陆状态 写 Session req.session.xxx = xx 读 Session req.session.xxx 删除 Session req.session.xxx = null 更严谨的做法是 delete 语法 delete req.session.xxx 概述案例中注册-登陆-退出的前后端交互实现流程]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>node学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js 第5天 --- MongoDB]]></title>
    <url>%2F2019%2F06%2F04%2FNode.js%20%E7%AC%AC5%E5%A4%A9%20---%20MongoDB%2F</url>
    <content type="text"><![CDATA[## 知识点 Express MongoDB 项目 一天半的时间 复习 文件路径中的 / 和模块标识中的 / Express 中配置使用 art-template 模板引擎 Express 中配置使用 body-parser Express 中配置处理静态资源 CRUD 案例中单独提取路由模块 上午总结 回调函数 异步编程 如果需要得到一个函数内部异步操作的结果，这是时候必须通过回调函数来获取 在调用的位置传递一个函数进来 在封装的函数内部调用传递进来的函数 find、findIndex、forEach 数组的遍历方法，都是对函数作为参数一种运用 every some includes map reduce package-lock.json 文件的作用 下载速度快了 锁定版本 JavaScript 模块化 Node 中的 CommonJS 浏览器中的 AMD require.js CMD sea.js EcmaScript 官方在 EcmaScript 6 中增加了官方支持 EcmaScript 6 后面我们会学，编译工具 MongoDB 数据库 MongoDB 的数据存储结构 数据库 集合（表） 文档（表记录） MongoDB 官方有一个 mongodb 的包可以用来操作 MongoDB 数据库 这个确实和强大，但是比较原始，麻烦，所以咱们不使用它 mongoose 真正在公司进行开发，使用的是 mongoose 这个第三方包 它是基于 MongoDB 官方的 mongodb 包进一步做了封装 可以提高开发效率 让你操作 MongoDB 数据库更方便 掌握使用 mongoose 对数据集合进行基本的 CRUD 把之前的 crud 案例改为了 MongoDB 数据库版本 使用 Node 操作 mysql 数据库 下午总结目标]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>node学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js 第4天 --- express]]></title>
    <url>%2F2019%2F06%2F04%2FNode.js%20%E7%AC%AC4%E5%A4%A9%20---%20express%2F</url>
    <content type="text"><![CDATA[## 知识点 Express 基于文件做一套 CRUD 复习 jQuery 的 each 和 原生的 JavaScript 方法 forEach 301 和 302 的区别 模块中导出单个成员和导出多个成员的方式 module.exports = xxx 通过多次：exports.xxx = xxx 导出多个也可以：moudle.exports = {多个成员} module.exports 和 exports 的区别 exports 只是 module.exports 的一个引用而已，目的只是为了简化写法 每个模块最终 return 的是 module.exports require 方法加载规则 优先从缓存加载 核心模块 路径形式的模块 ./xxx ../xxxx /xxxx / 在这里表示的是磁盘根路径 c:/xxx 第三方模块 第三方模块的标识就是第三方模块的名称（不可能有第三方模块和核心模块的名字一致） npm 开发人员可以把写好的框架、库发布到 npm 上 使用者在使用的时候就可以很方便的通过 npm 来下载 使用方式：var 名字 = require(&#39;npm install 的那个包名&#39;) node_modules node_modules/express node_modules/express/package.json node_modules/express/package.json main 如果 package.json 或者 package.json main 不成立，则查找备选项：index.js 如果以上条件都不成立，则继续进入上一级目录中的 node_modules 按照上面的规则继续查找 如果直到当前文件模块所属磁盘根目录都找不到，最后报错：can not find module xxx package.json 包描述文件 就是产品的说明书 dependencies 属性，用来保存项目的第三方包依赖项信息 所以建议每个项目都要有且只有一个 package.json (存放在项目的根目录) 我们可以通过 npm init [--yes] 来生成 package.json 文件 同样的，为了保存依赖项信息，我们每次安装第三方包的时候都要加上：--save 选项。 npm 常用命令 install uninstall Express 基本使用 模块标识中的 / 和文件操作路径中的 /上午总结 文件路径中的 / 和模块标识中的 / nodemon Express art-template 模板引擎的配置 body-parser 解析表单 POST 请求体 详解了 express 静态服务 API app.use(‘/public/‘, express.static(‘./public’)) crud 下午总结目标 文件路径中的 / 和模块标识中的 / Express 中配置使用 art-template 模板引擎 Express 中配置使用 body-parser Express 中配置处理静态资源 CRUD 案例中单独提取路由模块]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>node学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js 第3天 --- exports 和 module.exports ,each和forEach的区别]]></title>
    <url>%2F2019%2F06%2F04%2FNode.js%20%E7%AC%AC3%E5%A4%A9%20---%20exports%20%E5%92%8C%20module.exports%20%2Ceach%E5%92%8CforEach%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[知识点 增删改查 登陆 注册 头像 服务端图片 水印 图片水印 找回密码 密码修改 模块系统 核心模块 第三方模块 自己写的模块 加载规则以及加载机制 循环加载 npm package.json Express 第三方 Web 开发框架 高度封装了 http 模块 更加专注于业务，而非底层细节 知其所以然 增删改查 使用文件来保存数据（锻炼异步编码） MongoDB （所有方法都封装好了） 复习 网站开发模型 黑盒子、哑巴 写代码让它变得更智能 按照你设计好的套路供用户使用 在 Node 中使用 art-template 模板引擎 安装 加载 template.render() 客户端渲染和服务端渲染的区别 最少两次请求，发起 ajax 在客户端使用模板引擎渲染 客户端拿到的就是服务端已经渲染好的 处理留言本案例首页数据列表渲染展示 处理留言本案例发表留言功能 路径 设计好的请求路径 $GET 直接或查询字符串数据 Node 中需要咱们自己动手来解析 url.parse() /pinglun?name=jack&amp;message=hello split(‘?’) name=jack&amp;message=hello split(‘&amp;’) name=jack message=hello forEach() name=jack.split(‘=’) 0 key 1 value 掌握如何解析请求路径中的查询字符串 url.parse() 如何在 Node 中实现服务器重定向 header(‘location’) 301 永久重定向 浏览器会记住 a.com b.com a 浏览器不会请求 a 了 直接去跳到 b 了 302 临时重定向 浏览器不记忆 a.com b.com a.com 还会请求 a a 告诉浏览器你往 b Node 中的 Console（REPL）使用 上午总结 jQuery 的 each 和 原生的 JavaScript 方法 forEach EcmaScript 5 提供的 不兼容 IE 8 jQuery 的 each 由 jQuery 这个第三方库提供 jQuery 2 以下的版本是兼容 IE 8 的 它的 each 方法主要用来遍历 jQuery 实例对象（伪数组） 同时它也可以作为低版本浏览器中 forEach 替代品 jQuery 的实例对象不能使用 forEach 方法，如果想要使用必须转为数组才可以使用 [].slice.call(jQuery实例对象) 模块中导出多个成员和导出单个成员 301 和 302 状态码区别 301 永久重定向，浏览器会记住 302 临时重定向 exports 和 module.exports 的区别 每个模块中都有一个 module 对象 module 对象中有一个 exports 对象 我们可以把需要导出的成员都挂载到 module.exports 接口对象中 也就是：moudle.exports.xxx = xxx 的方式 但是每次都 moudle.exports.xxx = xxx 很麻烦，点儿的太多了 所以 Node 为了你方便，同时在每一个模块中都提供了一个成员叫：exports exports === module.exports 结果为 trues 所以对于：moudle.exports.xxx = xxx 的方式 完全可以：expots.xxx = xxx 当一个模块需要导出单个成员的时候，这个时候必须使用：module.exports = xxx 的方式 不要使用 exports = xxx 不管用 因为每个模块最终向外 return 的是 module.exports 而 exports 只是 module.exports 的一个引用 所以即便你为 exports = xx 重新赋值，也不会影响 module.exports 但是有一种赋值方式比较特殊：exports = module.exports 这个用来重新建立引用关系的 之所以让大家明白这个道理，是希望可以更灵活的去用它 Node 是一个比肩 Java、PHP 的一个平台 JavaScript 既能写前端也能写服务端 12345678moudle.exports = &#123; a: 123&#125;// 重新建立 exports 和 module.exports 之间的引用关系exports = module.exportsexports.foo = 'bar' 12345678910111213141516171819202122232425262728Array.prototype.mySlice = function () &#123; var start = 0 var end = this.length if (arguments.length === 1) &#123; start = arguments[0] &#125; else if (arguments.length === 2) &#123; start = arguments[0] end = arguments[1] &#125; var tmp = [] for (var i = start; i &lt; end; i++) &#123; // fakeArr[0] // fakeArr[1] // fakeArr[2] tmp.push(this[i]) &#125; return tmp&#125;var fakeArr = &#123; 0: 'abc', 1: 'efg', 2: 'haha', length: 3&#125;// 所以你就得到了真正的数组。 [].mySlice.call(fakeArr) 下午总结 jQuery 的 each 和 原生的 JavaScript 方法 forEach 301 和 302 的区别 模块中导出单个成员和导出多个成员的方式 module.exports 和 exports 的区别 require 方法加载规则 优先从缓存加载 核心模块 路径形式的模块 第三方模块 node_modules package.json 包描述文件 dependencies 选项的作用:依赖 npm 常用命令 Express 基本使用]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>node学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js 第2天 ---代码风格，服务端渲染]]></title>
    <url>%2F2019%2F06%2F04%2FNode.js%20%E7%AC%AC2%E5%A4%A9%20---%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%EF%BC%8C%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93%2F</url>
    <content type="text"><![CDATA[### 代码风格 12345678910111213141516var foo = 'bar'var foo ='bar'var foo= 'bar'var foo = "bar"if (true) &#123; console.log('hello') &#125;if (true) &#123; console.log('hello') &#125;if (true )&#123; console.log('hello') &#125; 为了约定大家的代码风格，所以在社区中诞生了一些比较规范的代码风格规范：dnsajkndkjsabnjkdnjksandjknsajkdnjkasnjkdnjksandjknsajkdnjksajkdnas 推荐的两种代码风格 JavaScript Standard Style Airbnb JavaScript Style 总结 代码风格 无分号 ( [ ` 最好前面补分号，避免一些问题 《编写可维护的 JavaScript》 不仅是功能，还要写的漂亮 服务端渲染 说白了就是在服务端使用模板引擎 模板引擎最早诞生于服务端，后来才发展到了前端 服务端渲染和客户端渲染的区别 客户端渲染不利于 SEO 搜索引擎优化 服务端渲染是可以被爬虫抓取到的，客户端异步渲染是很难被爬虫抓取到的 所以你会发现真正的网站既不是纯异步也不是纯服务端渲染出来的 而是两者结合来做的 例如京东的商品列表就采用的是服务端渲染，目的是为了 SEO 搜索引擎优化 而它的商品评论列表为了用户体验，而且也不需要 SEO 优化，所以采用是客户端渲染]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>node学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js 第1天 --- 模块系统，HTTP]]></title>
    <url>%2F2019%2F06%2F04%2FNode.js%20%E7%AC%AC1%E5%A4%A9%20---%20%E6%A8%A1%E5%9D%97%E7%B3%BB%E7%BB%9F%EF%BC%8CHTTP%2F</url>
    <content type="text"><![CDATA[### 上午总结 基本网站开发能力 服务端 前端 运维部署 Node.js 是什么 JavaScript 运行时环境 既不是语言，也不是框架，它是一个平台 简单来讲就是Node.js可以解析和执行JavaScript代码 以前只有浏览器可以解析和执行JavaScript代码 也就是说现在的JavaScript完全可以脱离浏览器来运行，一切都归功于：Node.js Node.js 中的 JavaScript 没有 BOM、DOM EcmaScript 只有基本的 JavaScript 语言部分 在 Node 中为 JavaScript 提供了一些服务器级别的 API 文件操作的能力 网络服务的构建 网络通信 http服务器 等处理….. 构建于Chrome的V8引擎之上 代码只是具有特定格式的字符串而已 引擎可以认识它，引擎可以帮你去解析和执行 Google Chrome的V8引擎是目前公认的解析执行JavaScript代码最快的 Node.js的作者把Google Chrome中的V8引擎移植了出来，开发了一个独立的JavaScript运行时环境 Node.js能做什么 web服务后台啊 命令行工具 npm(node) git(c语言) hexo(node) 。。。 下午总结 Node 中的 JavaScript EcmaScript 变量 方法 数据类型 内置对象 Array Object Date Math 模块系统 在 Node 中没有全局作用域的概念 在 Node 中，只能通过 require 方法来加载执行多个 JavaScript 脚本文件 require 加载只能是执行其中的代码，文件与文件之间由于是模块作用域，所以不会有污染的问题 模块完全是封闭的 外部无法访问内部 内部也无法访问外部 模块作用域固然带来了一些好处，可以加载执行多个文件，可以完全避免变量命名冲突污染的问题 但是某些情况下，模块与模块是需要进行通信的 在每个模块中，都提供了一个对象：exports 该对象默认是一个空对象 你要做的就是把需要被外部访问使用的成员手动的挂载到 exports 接口对象中 然后谁来 require 这个模块，谁就可以得到模块内部的 exports 接口对象 还有其它的一些规则，具体后面讲，以及如何在项目中去使用这种编程方式，会通过后面的案例来处理 核心模块 核心模块是由 Node 提供的一个个的具名的模块，它们都有自己特殊的名称标识，例如 fs 文件操作模块 http 网络服务构建模块 os 操作系统信息模块 path 路径处理模块 。。。。 所有核心模块在使用的时候都必须手动的先使用 require 方法来加载，然后才可以使用，例如： var fs = require(&#39;fs&#39;) http require 端口号 ip 地址定位计算机 端口号定位具体的应用程序 Content-Type 服务器最好把每次响应的数据是什么内容类型都告诉客户端，而且要正确的告诉 不同的资源对应的 Content-Type 是不一样，具体参照：http://tool.oschina.net/commons 对于文本类型的数据，最好都加上编码，目的是为了防止中文解析乱码问题 通过网络发送文件 发送的并不是文件，本质上来讲发送是文件的内容 当浏览器收到服务器响应内容之后，就会根据你的 Content-Type 进行对应的解析处理]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>node学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[H5新增表单属性]]></title>
    <url>%2F2019%2F06%2F04%2FH5%E6%96%B0%E5%A2%9E%E8%A1%A8%E5%8D%95%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[### H5新增的input类型 1234567891011121314&lt;form&gt; 邮箱：&lt;input type="email"&gt;&lt;br/&gt; 数量：&lt;input type="number" value="20" max="25" min="18"&gt;&lt;br/&gt; 电话：&lt;input type="tel"&gt;&lt;br/&gt; 网址：&lt;input type="url"&gt;&lt;br/&gt; 范围：&lt;input type="range" max="100" min="0"&gt;&lt;br/&gt; 颜色：&lt;input type="color"&gt;&lt;br/&gt; 时间:&lt;input type="time"&gt;&lt;br/&gt; 日期：&lt;input type="date"&gt;&lt;br/&gt; 日期时间：&lt;input type="datetime-local"&gt;&lt;br/&gt; 月份：&lt;input type="month"&gt;&lt;br/&gt; 星期：&lt;input type="week"&gt;&lt;br/&gt; 提交：&lt;input type="submit"&gt; &lt;/form&gt; 在H5新增input类型帮我们省去了许多原来需要自己实现的功能。 email帮我们自动校验了格式。 tel由于全球号码格式不一样，格式不太好校验不过帮我们在移动端点击该输入框会切换到数字键盘。 url帮我们校验了格式不过需要注意的是网址前面需要加上：http://。 number 类型用于应该包含数值的输入域。还能设置输入数字的范围 range 类型用于应该包含一定范围内数字值的输入域。range 类型显示为滑动条。还能够设定数字的限定： 效果图： 浏览器支持需要注意的是新增的类型不是所有浏览器都兼容，部分兼容的呈现出来的效果也不一样。 表单其他新增属性placeholder:占位符，提示文本 autofocus:自动获取焦点 autocomplete:自动完成，on打开,off关闭 1.必须成功提交过 2.必须有name属性 required:必须输入，如果没有输入会阻止提交 pattern:正则表达式的验证 multiple:允许选择多个文件,在邮箱中允许输入多个邮箱地址，用,分割 1234567891011121314&lt;form action=""&gt; &lt;!--placeholder占位符，提示文本 --&gt; &lt;!-- autofocus自动获取焦点--&gt; &lt;!--autocomplete自动完成，on打开,off关闭 1.必须成功提交过 2.必须有name属性--&gt; 用户名：&lt;input type="text" name="userName" placeholder="请输入用户名" autofocus autocomplete="on"&gt;&lt;br/&gt; &lt;!-- tel并不会进行验证，只是会在移动端打开数字键盘--&gt; &lt;!-- required必须输入，如果没有输入会阻止提交--&gt; &lt;!-- pattern正则表达式的验证--&gt; 手机号:&lt;input type="tel" required pattern="^(\+86)?1\d&#123;10&#125;$"&gt;&lt;br/&gt; &lt;!-- multiple允许选择多个文件,在邮箱中允许输入多个邮箱地址，用,分割--&gt; 文件：&lt;input type="file" name="photo" multiple&gt;&lt;br/&gt; 邮箱：&lt;input type="email" multiple name="email"&gt; &lt;input type="submit"&gt; &lt;/form&gt; 效果图：]]></content>
      <categories>
        <category>H5/C3</category>
      </categories>
      <tags>
        <tag>h5表单属性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[H5多媒体标签--视频video和音频audio]]></title>
    <url>%2F2019%2F06%2F04%2FH5%E5%A4%9A%E5%AA%92%E4%BD%93%E6%A0%87%E7%AD%BE--%E8%A7%86%E9%A2%91video%E5%92%8C%E9%9F%B3%E9%A2%91audio%2F</url>
    <content type="text"><![CDATA[### audio–音频标签 标签属性 contrils:播放器的控制面板 autoplay:自动播放 loop:循环播放 src：文件地址 preload用来缓存大的文件其中有三个值可选 none：不缓存 auto：缓存(默认) metadata:缓存文件元信息 案例：1&lt;audio src="年少有为.mp3" controls autoplay loop&gt;浏览器不支持该标签时，才显示这部分文字&lt;/audio&gt; 效果图： video视频标签标签属性src:表示文件地址 contrils:播放器的控制面板 autoplay:自动播放 loop:循环播放 width:宽度 height:高度 preload用来缓存大的文件其中有三个值可选 none：不缓存 auto：缓存(默认) metadata:缓存文件元信息 poster:当前视频还没有完全下载，或者用户还没有点击播放前的默认显示封面。默认显示当前视频文件第一帧画面 注意事项：当设置宽高的时候，一般情况下只会设置宽度或高度，让其等比例缩放。如果同时设置宽度和高度，那么视频并不会真正调整到设置的宽高。 案例：1&lt;video src="李荣浩%20-%20年少有为.mp4" poster="1.jpg" controls width="800"&gt;&lt;/video&gt; 效果图： 重点说明source的使用因为不同浏览器支持的视频格式不一样，所以我们在进行视频添加的时候，需要考虑到浏览器是否支持。我们可以准备多个格式的视频文件，让浏览器自动选择 12345&lt;video&gt; &lt;source src="李荣浩%20-%20年少有为.mp4" type="video/mp4"&gt; &lt;source src="李荣浩%20-%20年少有为.flv" type="video/flv"&gt; 您的浏览器不支持当前的视频播放&lt;/video&gt; 浏览器视频格式兼容性参考图如下:]]></content>
      <categories>
        <category>H5/C3</category>
      </categories>
      <tags>
        <tag>video,autio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[H5全屏显示方法及浏览器兼容解决方案]]></title>
    <url>%2F2019%2F06%2F04%2FH5%E5%85%A8%E5%B1%8F%E6%98%BE%E7%A4%BA%E6%96%B9%E6%B3%95%E5%8F%8A%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[### 全屏操作的主要方法和属性 1.requestFullScreen():开启全屏显示 克服兼容性：不同浏览器需要添加不同的前缀: chrom:webkit firefox:moz ie:ms opera: o123456789101112131415/*添加三个按钮的点击事件*//*全屏操作*/document.querySelector("#full").onclick= function () &#123; /*使用能力测试添加不同浏览器下的前缀*/ if(div.requestFullScreen)&#123; div.requestFullScreen(); &#125;else if(div.webkitRequestFullScreen)&#123; div.webkitRequestFullScreen(); &#125; else if(div.mozRequestFullScreen)&#123; div.mozRequestFullScreen(); &#125;else if(div.msRequestFullScreen)&#123; div.msRequestFullScreen(); &#125;&#125; 2.cancelFullScreen():退出全屏显示 也添加前缀，在不同的浏览器下，退出全屏只能使用document来实现（整个文档退出） 1234567891011121314 /*退出全屏*/document.querySelector("#cancelFull").onclick= function () &#123; /*使用能力测试添加不同浏览器下的前缀*/ if(document.cancelFullScreen)&#123; document.cancelFullScreen(); &#125;else if(document.webkitCancelFullScreen)&#123; document.webkitCancelFullScreen(); &#125; else if(document.mozCancelFullScreen)&#123; document.mozCancelFullScreen(); &#125;else if(document.msCancelFullScreen)&#123; document.msCancelFullScreen(); &#125;&#125; 3.fullScreenElement:是否是全屏状态 添加前缀，要使用document进行判断 12345678document.querySelector("#isfull").onclick= function () &#123; /*两个细节:使用document判断 能力测试*/ if(document.fullscreenElement || document.webkitFullScreenElement || document.mozFullScreenElement || document.msFullScreenElement)&#123; alert(true); &#125;else&#123; alert(false); &#125;&#125; 效果图：]]></content>
      <categories>
        <category>H5/C3</category>
      </categories>
      <tags>
        <tag>H5全屏显示</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3---文本阴影]]></title>
    <url>%2F2019%2F06%2F04%2FCSS3---%E6%96%87%E6%9C%AC%E9%98%B4%E5%BD%B1%2F</url>
    <content type="text"><![CDATA[### CSS3 text-shadow 属性 实例基础的文本阴影效果： 123h1&#123; text-shadow: 5px 5px 5px #FF0000;&#125; 效果图： 语法text-shadow: h-shadow v-shadow blur color; 注释：text-shadow 属性向文本添加一个或多个阴影。该属性是逗号分隔的阴影列表，每个阴影有两个或三个长度值和一个可选的颜色值进行规定。省略的长度是 0。 值 描述 h-shadow 必需。水平阴影的位置。允许负值。 v-shadow 必需。垂直阴影的位置。允许负值。 blur 可选。模糊的距离。 color 可选。阴影的颜色。 小案例：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .demo&#123; font-size: 80px; background-color: #808080; width: 800px; margin: 30px auto; text-align: center; color: white; font-weight: bolder; &#125; .demo1&#123; text-shadow: -2px -2px 8px red; &#125; .demo2&#123; text-shadow: 0px 0px 30px #fff; &#125; .demo3&#123; text-shadow: 0px 0px 30px #fff,0px 0px 50px red; &#125; .demo4&#123; color: black; text-shadow: 0px 1px 0px #fff; &#125; .demo5&#123; color: white; text-shadow: -1px -1px 0px #eee,-2px -2px 0px #ddd ,-3px -3px 0px #ccc ,-4px -4px 0px #bbb; &#125; .demo6&#123; color: transparent; text-shadow: 0px 0px 8px hsla(30,100%,30%,1); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="demo demo1"&gt;好好学习，天天向上&lt;/div&gt;&lt;div class="demo demo2"&gt;好好学习，天天向上&lt;/div&gt;&lt;div class="demo demo3"&gt;好好学习，天天向上&lt;/div&gt;&lt;div class="demo demo4"&gt;好好学习，天天向上&lt;/div&gt;&lt;div class="demo demo5"&gt;好好学习，天天向上&lt;/div&gt;&lt;div class="demo demo6"&gt;好好学习，天天向上&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果图：]]></content>
      <categories>
        <category>H5/C3</category>
      </categories>
      <tags>
        <tag>text-shadow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3过渡效果transition----附手风琴案例]]></title>
    <url>%2F2019%2F06%2F04%2FCSS3%E8%BF%87%E6%B8%A1%E6%95%88%E6%9E%9Ctransition----%E9%99%84%E6%89%8B%E9%A3%8E%E7%90%B4%E6%A1%88%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[CSS3中新增的transform属性，实现了元素在变化过程中的过渡效果，实现了基本的动画。 定义和用法transition 属性是一个简写属性，用于设置四个过渡属性： transition-property 规定设置过渡效果的 CSS 属性的名称。 transition-duration 规定完成过渡效果需要多少秒或毫秒。 transition-timing-function 规定速度效果的速度曲线。 ①linear：线性过渡。②ease：平滑过渡，这是默认值③ease-in：由慢到快。④ease-out：由快到慢。⑤ease-in-out：由慢到快再到慢。 transition-delay 定义过渡效果何时开始。 浏览器兼容性问题基于webkit内核的私有属性是：-webkit-transition; 基于gecko内核的私有属性是：-moz-transition; 基于prestot内核的私有属性是：-o-transition; 实例：12345678div&#123;width:100px;transition: width 2s;-moz-transition: width 2s; /* Firefox 4 */-webkit-transition: width 2s; /* Safari 和 Chrome */-o-transition: width 2s; /* Opera */&#125; 手风琴案例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; *&#123; text-align: center; margin: 0px; padding: 0px; &#125; li&#123; list-style:none;; height: 30px; &#125; .mennu&#123; height: auto; width: 250px; margin: 50px auto; &#125; .item&#123; width: 100%; height: auto; &#125; .item:hover &gt; .itemBox&#123; height: 120px; &#125; .item &gt; h3&#123; background-color: skyblue; color: orange; height: 40px; line-height: 40px; border-bottom: 2px solid #ccc; &#125; .item &gt;.itemBox&#123; width: 100%; height: 0; overflow: hidden; /*添加过渡效果*/ transition-property: height; transition-duration: 1s; &#125; .item &gt;.itemBox &gt;ul&#123; background-color: yellowgreen; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="mennu"&gt; &lt;div class="item"&gt; &lt;h3&gt;国际新闻&lt;/h3&gt; &lt;div class="itemBox"&gt; &lt;ul&gt; &lt;li&gt;深圳市遇到有史以来最大台风&lt;/li&gt; &lt;li&gt;深圳市遇到有史以来最大台风&lt;/li&gt; &lt;li&gt;深圳市遇到有史以来最大台风&lt;/li&gt; &lt;li&gt;深圳市遇到有史以来最大台风&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;h3&gt;国内新闻&lt;/h3&gt; &lt;div class="itemBox"&gt; &lt;ul&gt; &lt;li&gt;深圳市遇到有史以来最大台风&lt;/li&gt; &lt;li&gt;深圳市遇到有史以来最大台风&lt;/li&gt; &lt;li&gt;深圳市遇到有史以来最大台风&lt;/li&gt; &lt;li&gt;深圳市遇到有史以来最大台风&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;h3&gt;省内新闻&lt;/h3&gt; &lt;div class="itemBox"&gt; &lt;ul&gt; &lt;li&gt;深圳市遇到有史以来最大台风&lt;/li&gt; &lt;li&gt;深圳市遇到有史以来最大台风&lt;/li&gt; &lt;li&gt;深圳市遇到有史以来最大台风&lt;/li&gt; &lt;li&gt;深圳市遇到有史以来最大台风&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;h3&gt;市内新闻&lt;/h3&gt; &lt;div class="itemBox"&gt; &lt;ul&gt; &lt;li&gt;深圳市遇到有史以来最大台风&lt;/li&gt; &lt;li&gt;深圳市遇到有史以来最大台风&lt;/li&gt; &lt;li&gt;深圳市遇到有史以来最大台风&lt;/li&gt; &lt;li&gt;深圳市遇到有史以来最大台风&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果图]]></content>
      <categories>
        <category>H5/C3</category>
      </categories>
      <tags>
        <tag>transition</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3伸缩布局注意点——携程网案例]]></title>
    <url>%2F2019%2F06%2F04%2FCSS3%E4%BC%B8%E7%BC%A9%E5%B8%83%E5%B1%80%E6%B3%A8%E6%84%8F%E7%82%B9%E2%80%94%E2%80%94%E6%90%BA%E7%A8%8B%E7%BD%91%E6%A1%88%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[#### 先贴两张效果图： 要求网页伸缩放大布局会自适应变换 用到的新属性display: flex Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。 flex: 当父元素使用display: flex后，子元素会具有弹性布局，子元素设置flex属性后面接数字，例如：flex:1，表示该子元素在该父元素的所有子元素中大小占一份，就会自适应宽度 box-sizing：border-box 为元素设定的宽度和高度决定了元素的边框盒。就是说，为元素指定的任何内边距和边框都将在已设定的宽度和高度内进行绘制。通过从已设定的宽度和高度分别减去边框和内边距才能得到内容的宽度和高度。 flex-wrap：wrap 让弹性盒元素在必要的时候拆行。使其不再收缩。 携程网案例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; *&#123; padding: 0; margin: 0; &#125; header&#123; width: 100%; display: flex; &#125; header &gt;a&#123; flex: 1; &#125; header &gt;a &gt;img&#123; width: 100%; &#125; main&#123; width: 100%; padding: 0 10px; /*设置盒模型*/ box-sizing: border-box; &#125; main &gt; .item&#123; width: 100%; height: 100px; background-color: #57c3ae; border-radius: 10px; margin-top: 10px; display: flex; &#125; main &gt; .item &gt;.left&#123; flex: 1; &#125; main &gt; .item &gt;.right&#123; flex: 2; /*设置换行显示*/ flex-wrap: wrap; /*设置为伸缩盒子*/ display: flex; &#125; main &gt; .item &gt;.right &gt;a&#123; /*如果想让子元素换行显示，必须为子元素设置宽度*/ box-sizing: border-box; width: 50%; display: block; text-align: center; line-height: 50px; color: #FFFFFF; text-decoration: none; border-left: 1px solid #fff; border-bottom: 1px solid #fff; &#125; main &gt;.item &gt;.right &gt;a:nth-last-child(-n+2)&#123; /*去除下面两个标签的下边框*/ border-bottom: none; &#125; main &gt;.item:nth-of-type(2)&#123; background-color:skyblue; &#125; main &gt;.item:nth-of-type(3)&#123; background-color:pink; &#125; main &gt;.item:nth-of-type(4)&#123; background-color:palegreen; &#125; main &gt;.extra&#123; width: 100%; display: flex; &#125; main &gt;.extra &gt;a&#123; flex: 1; &#125; main &gt;.extra&gt;a&gt;img&#123; width: 100%; &#125; /*底部块样式*/ footer&#123; width: 100%; font-size: 13px; &#125; footer &gt;nav&#123; width: 100%; display: flex; border-top: 1px solid #cccccc; border-bottom: 1px solid #cccccc; &#125; footer &gt;nav &gt;a&#123; flex: 1; line-height: 30px; text-align: center; color: #888; text-decoration: none; &#125; footer &gt;.link&#123; text-align: center; line-height: 25px; margin-top: 10px; &#125; footer .copy&#123; text-align: center; margin-top: 10px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="container"&gt; &lt;header&gt; &lt;a href=""&gt; &lt;img src="banner.jpg" alt=""/&gt; &lt;/a&gt; &lt;/header&gt; &lt;main&gt; &lt;section class="item"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt; &lt;a href=""&gt;海外酒店&lt;/a&gt; &lt;a href=""&gt;团购&lt;/a&gt; &lt;a href=""&gt;特惠酒店&lt;/a&gt; &lt;a href=""&gt;客栈公寓&lt;/a&gt; &lt;/div&gt; &lt;/section&gt; &lt;section class="item"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt; &lt;a href=""&gt;海外酒店&lt;/a&gt; &lt;a href=""&gt;团购&lt;/a&gt; &lt;a href=""&gt;特惠酒店&lt;/a&gt; &lt;a href=""&gt;客栈公寓&lt;/a&gt; &lt;/div&gt; &lt;/section&gt; &lt;section class="item"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt; &lt;a href=""&gt;海外酒店&lt;/a&gt; &lt;a href=""&gt;团购&lt;/a&gt; &lt;a href=""&gt;特惠酒店&lt;/a&gt; &lt;a href=""&gt;客栈公寓&lt;/a&gt; &lt;/div&gt; &lt;/section&gt; &lt;section class="item"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt; &lt;a href=""&gt;海外酒店&lt;/a&gt; &lt;a href=""&gt;团购&lt;/a&gt; &lt;a href=""&gt;特惠酒店&lt;/a&gt; &lt;a href=""&gt;客栈公寓&lt;/a&gt; &lt;/div&gt; &lt;/section&gt; &lt;section class="item"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt; &lt;a href=""&gt;海外酒店&lt;/a&gt; &lt;a href=""&gt;团购&lt;/a&gt; &lt;a href=""&gt;特惠酒店&lt;/a&gt; &lt;a href=""&gt;客栈公寓&lt;/a&gt; &lt;/div&gt; &lt;/section&gt; &lt;section class="extra"&gt; &lt;a href=""&gt; &lt;img src="extra1.png" alt=""/&gt; &lt;/a&gt; &lt;a href=""&gt; &lt;img src="exra2.png" alt=""/&gt; &lt;/a&gt; &lt;/section&gt; &lt;/main&gt; &lt;footer&gt; &lt;nav&gt; &lt;a href=""&gt;电话预定&lt;/a&gt; &lt;a href=""&gt;下载客户端&lt;/a&gt; &lt;a href=""&gt;我的订单&lt;/a&gt; &lt;/nav&gt; &lt;p class="link"&gt; &lt;a href=""&gt;网站地图&lt;/a&gt; &lt;a href=""&gt;ENGLISH&lt;/a&gt; &lt;a href=""&gt;电脑版&lt;/a&gt; &lt;/p&gt; &lt;p class="copy"&gt;&amp;copy;2015携程旅行&lt;/p&gt; &lt;/footer&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>H5/C3</category>
      </categories>
      <tags>
        <tag>flex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flex弹性布局：justify-content]]></title>
    <url>%2F2019%2F06%2F04%2Fflex%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80%EF%BC%9Ajustify-content%2F</url>
    <content type="text"><![CDATA[## 定义和用法 justify-content 用于设置或检索弹性盒子元素在主轴（横轴）方向上的对齐方式。提示：使用 align-content 属性对齐交叉轴上的各项（垂直）。|默认值：| flex-start||–|–|| 继承：| 否||可动画化：|否||版本|css3||JavaScript 语法：|object.style.justifyContent=”space-between” | CSS 语法1justify-content: flex-start|flex-end|center|space-between|space-around|initial|inherit; 属性值 值 描述 测试 flex-start 默认值。项目位于容器的开头。 测试 flex-end 项目位于容器的结尾。 测试 center 项目位于容器的中心。 测试 space-between 项目位于各行之间留有空白的容器内。 测试 space-around 项目位于各行之前、之间、之后都留有空白的容器内。 测试 initial 设置该属性为它的默认值。 测试 inherit 从父元素继承该属性。]]></content>
      <categories>
        <category>H5/C3</category>
      </categories>
      <tags>
        <tag>justify-content</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MVC和MVVM的区别]]></title>
    <url>%2F2019%2F06%2F04%2FMVC%E5%92%8CMVVM%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[@[toc] 前言mvc和mvvm究竟是怎么样子的，这是一个前后端都需要思考的问题。后面我们一步步来阐述mvc和mvvm这样设计的原因以及我们需要明白的一些问题。 MVC解释MVC全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。MVC被独特的发展起来用于映射传统的输入、处理和输出功能在一个逻辑的图形化用户界面的结构中。 几乎所有的App都只干这么一件事：将数据展示给用户看，并处理用户对界面的操作。MVC的思想：一句话描述就是Controller负责将Model的数据用View显示出来，换句话说就是在Controller里面把Model的数据赋值给View。 MModel（模型）：是应用程序中用于处理应用程序数据逻辑的部分。通常模型对象负责在数据库中存取数据。 比如我们人类有一双手，一双眼睛，一个脑袋，没有尾巴，这就是模型，Model定义了这个模块的数据模型。在代码中体现为数据管理者，Model负责对数据进行获取及存放。数据不可能凭空生成的，要么是从服务器上面获取到的数据，要么是本地数据库中的数据，也有可能是用户在UI上填写的表单即将上传到服务器上面存放，所以需要有数据来源。既然Model是数据管理者，则自然由它来负责获取数据。Controller不需要关心Model是如何拿到数据的，只管调用就行了。数据存放的地方是在Model，而使用数据的地方是在Controller，所以Model应该提供接口供controller访问其存放的数据（通常通过.h里面的只读属性） VView（视图）：是应用程序中处理数据显示的部分。通常视图是依据模型数据创建的。 View，视图，简单来说，就是我们在界面上看见的一切。它们有一部分是我们UI定死的，也就是不会根据数据来更新显示的，比如一些Logo图片啊，这里有个按钮啊，那里有个输入框啊，一些显示特定内容label啊等等；有一部分是会根据数据来显示内容的，比如tableView来显示好友列表啊，这个tableView的显示内容肯定是根据数据来显示的。我们使用MVC解决问题的时候，通常是解决这些根据数据来显示内容的视图。 CController（控制器）：是应用程序中处理用户交互的部分。通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。 Controller是MVC中的数据和视图的协调者，也就是在Controller里面把Model的数据赋值给View来显示（或者是View接收用户输入的数据然后由Controller把这些数据传给Model来保存到本地或者上传到服务器）。 综合以上内容，实际上你应该可以通过面向对象的基本思想来推导出controller出现的原因：我们所有的App都是界面和数据的交互，所以需要类来进行界面的绘制，于是出现了View，需要类来管理数据于是出现了Model。我们设计的View应该能显示任意的内容比如UILabel显示的文字应该是任意的而不只是某个特定Model的内容，所以我们不应该在View的实现中去写和Model相关的任何代码，如果这样做了，那么View的可扩展性就相当低了。而Model只是负责处理数据的，它根本不知道数据到时候会拿去干啥，可能拿去作为算法噼里啪啦去了，可能拿去显示给用户了，它既然无法接收用户的交互，它就不应该去管和视图相关的任何信息，所以Model中不应该写任何View相关代码。然而我们的数据和界面应该同步，也就是一定要有个地方要把Model的数据赋值给View，而Model内部和View的内部都不可能去写这样的代码，所以只能新创造一个类出来了，取名为Controller。它被UIKit逐渐完善成了我们现在使用的UIViewController。 下面看这张图斯坦福大学公开课上的这幅图来说明，这可以说是最经典和最规范的MVC标准这张图把MVC分为三个独立的区域，并且中间用了一些线来隔开。很有意思的设计，因为这些线似乎出现在了驾校科目一的内容中，你瞧C和V以及C和M之间的白线，一部分是虚线一部分是实线对吧，这就表明了引用关系：C可以直接引用V和M，而V和M不能直接引用C，至少你不能显式的在V和M的代码中去写和C相关的任何代码，而V和M之间则是双黄线，没错，它们俩谁也不能引用谁，你既不能在M里面写V，也不能在V里面写M。哦，上面的描述有点小小的问题，你不是“不能”这样写，而是“不应该”这样写，没人能阻止你在写代码的时候在一个M里面去写V，但是一旦你这样做了，那么你就违背了MVC的规范，你就不是在使用MVC了，所以这算是MVC的一个必要条件：使用MVC –&gt; M里面没有V的代码。所以M里面没有V的代码就是使用MVC的必要条件。 View和Controller的交互按钮点击事件，是View来接收的，但是处理这个事件的应该是Controller，所以View把这个事件传递给了Controller，如何传递的呢，见图，看到View上面的action没有，这就是事件，看到Controller上面的target没有，这就是靶子，View究竟要把事件传递给谁，它被规定了传递给靶子，Controller实际上就是靶子。只是View只负责传递事件，不负责关心靶子是谁。就像你是一个负责运货的少年，你唯一知道的是你要把货（action）交给上头（开发者）告诉你的那个收货的人（target），至于那个收货的人是警察还是怪兽，你都不需要关心。这是V和C的一种交互方式，叫做target-action。所以你看，这张图简直就是神来之笔，旁边还栩栩如生的画出了V对C的另一种传值：协议-委托。委托有两种：代理和数据源。什么是代理，就是专门处理should、will、did事件的委托，什么是数据源，就是专门处理data、count等等的委托。 Model和Controller的交互M是干嘛的？上面说了，M就是数据管理者，你可以理解为它直接和数据库打交道。这里的数据库可能是本地的，也可能是服务器上的，M会从数据库获取数据，也可能把数据上传给数据库。M也将提供属性或者接口来供C访问其持有的数据。我们就拿一个简单的需求作为例子，假如我想在一个模块中显示一段文字，这段文字是从网上获取下来的。那么使用MVC的话，在C中肯定需要一个UILabel（V）作为属性来显示这段文字，而这段文字由谁来获取呢，肯定是由M来获取了。而获取的地方在哪里呢？通常在C的生命周期里面，所以往往是在C的一个生命周期方法比如viewDidLoad里面调用M获取数据的方法来获取数据。现在问题来了，M获取数据的方法是异步的网络请求，网络请求结束后，C才应该用请求下来的数据重新赋值给V，现在的问题是，C如何知道网络请求结束了？这里我们一定要换一种角度去思考，我们进一步考虑M和V之间的关系：它们应该是一种同步的关系，也就是，不管任何时刻，只要M的值发生改变，V的显示就应该发生改变（显示最新的M的内容）。所以我们可以关注M的值改变，而不用关心M的网络请求是否结束了。实际上C根本不知道M从哪去拿的数据，C的责任是负责把M最新的数据赋值给V。所以C应该关注的事件是：M的值是否发生了变化。 MVVM什么是MVVMMVVM：Model、View、ViewModel。 你会下意识地把它和MVC来对比，你会发现，MVVM多了一个ViewModel而少了Controller。 首先说一下多出来的ViewModel（VM，不是显存）。VM的意义，和Model一样，在于数据。Model负责对数据进行取和存，然而我们对数据的操作除了取和存以外，还有一个非常重要的操作：解析。 MVVM的诞生就像我们之前分析MVC是如何合理分配工作的一样，我们需要数据所以有了M，我们需要界面所以有了V，而我们需要找一个地方把M赋值给V来显示，所以有了C，然而我们忽略了一个很重要的操作：数据解析。在MVC出生的年代，手机APP的数据往往都比较简单，没有现在那么复杂，所以那时的数据解析很可能一步就解决了，所以既然有这样一个问题要处理，而面向对象的思想就是用类和对象来解决问题，显然V和M早就被定义死了，它们都不应该处理“解析数据”的问题，理所应当的，“解析数据”这个问题就交给C来完成了。而现在的手机App功能越来越复杂，数据结构也越来越复杂，所以数据解析也就没那么简单了。如果我们继续按照MVC的设计思路，将数据解析的部分放到了Controller里面，那么Controller就将变得相当臃肿。还有相当重要的一点：Controller被设计出来并不是处理数据解析的。1、管理自己的生命周期；2、处理Controller之间的跳转；3、实现Controller容器。这里面根本没有“数据解析”这一项，所以显然，数据解析也不应该由Controller来完成。那么我们的MVC中，M、V、C都不应该处理数据解析，那么由谁来呢？这个问题实际上在面向对象的时候相当好回答：既然目前没有类能够处理这个问题，那么就创建一个新的类出来解决不就好了？所以我们聪明的开发者们就专门为数据解析创建出了一个新的类：ViewModel。这就是MVVM的诞生。 如何实现MVVM搞清楚了MVVM为什么会出现，将对于你理解如何实现MVVM有极大的帮助。在我们开始着手实现MVVM之前，我先简单提一下之前遗留的一个问题：为什么MVVM这个名字里面，没有Controller的出现（为什么不叫MVCVM，C去哪了）。本来这个问题应该在实现后再来解释，但是我们这里是教学，为了让大家更好的明白我们接下来的思想，所以这里要提前解释一下这个结论：Controller的存在感被完全的降低了。我们在待会实现MVVM的时候你就能体会到了，这里请先把这个结论印在脑海当中：Controller的存在感被完全的降低了、Controller的存在感被完全的降低了、Controller的存在感被完全的降低了。好的，我们终于要开始着手实现MVVM了。如果你已经搞懂了MVC，那么用MVVM实现一个相同的功能将会变得非常简单。你只需要记住两点：1、Controller的存在感被完全的降低了；2、VM的出现就是Controller存在感降低的原因。 Controller存在感降低的原因在MVVM中，Controller不再像MVC那样直接持有Model了。想象Controller是一个Boss，数据是一堆文件（Model），如果现在是MVC，那么数据解析（比如整理文件）需要由Boss亲自完成，然而实际上Boss需要的仅仅是整理好的文件而不是那一堆乱七八糟的整理前的文件。所以Boss招聘了一个秘书，现在Boss就不再需要管理原始数据（整理之前的文件）了，他只需要去找秘书：你帮我把文件整理好后给我。那么这个秘书就首先去拿到文件（原始数据），然后进行整理（数据解析），接下来把整理的结果给Boss。所以秘书就是VM了，并且Controller（Boss）现在只需要直接持有VM而不需要再持有M了。如果再进一步理解C、VM、M之间的关系：因为Controller只需要数据解析的结果而不关心过程，所以就相当于VM把“如何解析Model”给封装起来了，C甚至根本就不需要知道M的存在就能把工作做好，前提它需要持有一个VM。那么我们MVVM中的持有关系就是：C持有VM，VM持有M。这里有一个比较争议的地方：C该不该持有M。我的答案是不该。为什么呢，因为C持有M没有任何意义。就算C直接拿到了M的数据，它还是要去让VM进行数据解析，而数据解析就需要M，那么直接让VM持有M而C直接持有VM就足够了。最后再分享一个我在实现MVVM中的一个技巧，也谈不上是技巧吧，算是一种必要的思想：一旦在实现Controller的过程中遇到任何跟Model（或者数据）相关的问题，就找VM要答案。这个思想待会我们会在实现代码的时候用到。 最后贴图文章参考：https://blog.csdn.net/u013282174/article/details/51220199]]></content>
      <categories>
        <category>框架设计</category>
      </categories>
      <tags>
        <tag>MVC和MVVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6学习笔记]]></title>
    <url>%2F2019%2F06%2F04%2FES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1.变量&emsp;&emsp;var&emsp;重复申明、函数级作用域&emsp;&emsp;let&emsp;不能重复申明、块级作用域、变量&emsp;&emsp;const&emsp;不能重复申明、块级作用域、常量 2.箭头函数&emsp;&emsp;a.方便&emsp;&emsp;&emsp;&emsp;i.如果只有一个参数，（）可以省&emsp;&emsp;&emsp;&emsp;ii.如果只有一个return，{}可以省&emsp;&emsp;b.修正this&emsp;&emsp;this相对正常点 3.参数扩展&emsp;&emsp;收集&emsp;&emsp;扩展 &emsp;&emsp;默认参数&emsp;&emsp;&emsp;&emsp;function show(a,b=5){&emsp;&emsp;&emsp;&emsp;} 4.数组方法&emsp;&emsp;map&emsp;&emsp;&emsp;&emsp;映射&emsp;&emsp;reduce&emsp;&emsp;&emsp;汇总：一堆-&gt;一个&emsp;&emsp;filter&emsp;&emsp;&emsp;&emsp;过滤：一堆-&gt;剩下的&emsp;&emsp;forEach&emsp;&emsp;&ensp;循环 5.字符串&emsp;&emsp;startsWith&emsp;&emsp;以什么开头&emsp;&emsp;endsWith&emsp;&emsp;以什么结尾&emsp;&emsp;字符串模板：`\${a}xxx\${b}` 6.Promise&emsp;&emsp;封装异步的操作 &emsp;&emsp;promise.all([ ]); 7.generator&emsp;&emsp;function *show(){&emsp;&emsp;yield&emsp;&emsp;} 8.JSON&emsp;&emsp;JSON.stringify({a:12,b:5}) =&gt; ‘{“a”:12,”b”:5}’&emsp;&emsp;JSON.parse(‘{“a”:12,”b”:5}’) =&gt; {a:12,b:5} 9.解构赋值&emsp;&emsp;let [a,b,c]=[12,5,8]; &emsp;&emsp;注意点：&emsp;&emsp;&emsp;&emsp;1.左右结构一样&emsp;&emsp;&emsp;&emsp;2.右边是个合法的东西&emsp;&emsp;&emsp;&emsp;3.声明、赋值一次完成 10.面向对象&emsp;&emsp;&emsp;&emsp;对象新写法：&emsp;&emsp;class Test{&emsp;&emsp;&emsp;&emsp;constructor(){&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;this.xxx=&emsp;&emsp;&emsp;&emsp;}&emsp;&emsp;&emsp;&emsp;方法1（）{ &emsp;&emsp;&emsp;&emsp;}&emsp;&emsp;&emsp;&emsp;方法2（）{ &emsp;&emsp;&emsp;&emsp;}&emsp;&emsp;} &emsp;&emsp;&emsp;&emsp;继承：&emsp;&emsp;&emsp;&emsp;class Cs2 extends Cls1{&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;constructor(){&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;super();&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;}&emsp;&emsp;&emsp;&emsp;}]]></content>
      <categories>
        <category>es6</category>
      </categories>
      <tags>
        <tag>es6笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[post大文件上传失败原因]]></title>
    <url>%2F2019%2F06%2F04%2FPHP-post%E5%A4%A7%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%A4%B1%E8%B4%A5%E5%8E%9F%E5%9B%A0%2F</url>
    <content type="text"><![CDATA[## post大文件上传失败原因 今天在使用使用post上传文件的时候发现报错了，原因竟然是因为文件过大。这就很奇怪了，post上传文件不是没有大小限制嘛？这里报错其实并不是代码的问题，错误在于web服务器对于文件上传大小有限制，当你上传的文件大小超过他的限制就会出现这种情况。 解决办法12345678//如果想修改上传文件的限制可以修改php.ini文件file_uploads = On; //是否允许上传文件 On/off 默认是onupload_max_filesize = 2048M; //上传文件最大限制，默认2Mpost_max_size = 2048M // 通过Post提交的最多数据max_execution_time = 30000; //脚本最长的执行事件 单位为秒max_input_time = 30000； //接收提交的数据的时间限制 单位为秒memory_limit = 2048M; //最大内存消耗 在我电脑上文件地址是：H:\wamp\bin\apache\apache2.4.23\bin这个按照你自己电脑安装的位置来就行了找到这个文件用phpstorm打开（不要用记事本打开，会出现格式问题）然后Ctrl+F查找upload_max_filesize 改为2048M（改多少看个人需求了）其他的也一样改就行了，把所有的改完用Ctrl+S保存一下然后把web服务器重启一下就行了。然后测试上传成功。]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>post大文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bootstrap的使用方法及其基本模板]]></title>
    <url>%2F2019%2F06%2F04%2Fbootstrap%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E5%8F%8A%E5%85%B6%E5%9F%BA%E6%9C%AC%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[### 什么是Bootstrap Bootstrap来自 Twitter，是目前很受欢迎的前端框架。Bootstrap 是基于 HTML、CSS、JavaScript 的，它简洁灵活，使得 Web 开发更加快捷。它由Twitter的设计师Mark Otto和Jacob Thornton合作开发，是一个CSS/HTML框架。Bootstrap提供了优雅的HTML和CSS规范，它即是由动态CSS语言Less写成。Bootstrap一经推出后颇受欢迎，一直是GitHub上的热门开源项目，包括NASA的MSNBC（微软全国广播公司）的Breaking News都使用了该项目。 国内一些移动开发者较为熟悉的框架，如WeX5前端开源框架等，也是基于Bootstrap源码进行性能优化而来。 如何使用1.下载bootstrap下载链接：https://v3.bootcss.com/getting-started/下载有三个版本如果仅仅是使用的话下载第一个就行了 2.引入只需要把下载好的文件解压拖入webstrom即可 3.基本模板1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt; &lt;title&gt;使用模板&lt;/title&gt; &lt;!-- Bootstrap地址，使用自己的地址就行了 --&gt; &lt;link href="https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/css/bootstrap.min.css" rel="stylesheet"&gt; &lt;!--兼容IE8--&gt; &lt;script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"&gt;&lt;/script&gt; &lt;/head&gt;&lt;body&gt;&lt;h1&gt;你好，世界！&lt;/h1&gt;&lt;!-- jQuery地址 (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) --&gt;&lt;script src="https://cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"&gt;&lt;/script&gt;&lt;!-- js地址下载文件中有（加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。） --&gt;&lt;script src="https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/js/bootstrap.min.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 模板注意点: 3个meta标签必须放在最前面 引入bootstrap地址 引入jquery文件(Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) 引入下载文件中的js文件（bootstrap.min.js） 4.使用方法1.在bootstrap官网中找到自己想要的功能（bootstrap中文官网：http://www.bootcss.com/）2.把模板复制到想要放置的位置例如：标签页的模板把代码复制到想要放置的地方（我这里是放在了body里）。效果图：3.修改样式，改成自己想要的]]></content>
      <categories>
        <category>bootstrap</category>
      </categories>
      <tags>
        <tag>bootstrap使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于请求报文，响应报文前端需要知道哪些？面试的时候又该如何回答？]]></title>
    <url>%2F2019%2F06%2F04%2F%E5%85%B3%E4%BA%8E%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%EF%BC%8C%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E5%89%8D%E7%AB%AF%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E5%93%AA%E4%BA%9B%EF%BC%9F%E9%9D%A2%E8%AF%95%E7%9A%84%E6%97%B6%E5%80%99%E5%8F%88%E8%AF%A5%E5%A6%82%E4%BD%95%E5%9B%9E%E7%AD%94%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[在学习web前端Ajax时需要进行前端后端交互，这时候我们需要了解什么是请求报文，什么是响应报文，我们前端需要用到哪些？ 1. 请求报文一个HTTP请求报文由请求行（request line）、请求头部（header）和请求主体3个部分组成。 1.1 请求行请求行由三部分组成：请求方法，请求URL（不包括域名），HTTP协议版本请求方法比较多：GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT最常用的是GET和POST。 1.2 请求头请求头部由关键字/值对组成，每行一对 User-Agent : 产生请求的浏览器类型Accept : 客户端希望接受的数据类型，比如 Accept：text/xml（application/json）表示希望接受到的是xml（json）类型Content-Type：发送端发送的实体数据的数据类型。比如，Content-Type：text/html（application/json）表示发送的是html类型。Host : 请求的主机名，允许多个域名同处一个IP地址，即虚拟主机。 1.3 请求主体GET没有请求数据，POST有。 与请求数据相关的最常使用的请求头是 Content-Type 和 Content-Length 。 2. 响应报文HTTP响应报文和请求报文的结构差不多，也是由三个部分组成：状态行，响应头，响应主体 2.1 状态行状态行也由三部分组成：服务器HTTP协议版本，响应状态码，状态码的文本描述格式：HTTP-Version Status-Code Reason-Phrase CRLF比如：HTTP/1.1 200 OK状态码：由3位数字组成，第一个数字定义了响应的类别 1xx：指示信息，表示请求已接收，继续处理2xx：成功，表示请求已被成功接受，处理。3xx：重定向4xx：客户端错误5xx：服务器端错误，服务器未能实现合法的请求 2.2 响应头服务器的一些信息，服务器想要告诉浏览器的一些信息。 2.3 响应主体正常用户看到的内容。 3. 面试时如何回答？请求报文：请求报文包括请求行、请求头、请求主体。主要有：发送的方法、浏览器的信息以及发送的数据。 响应报文：响应报文包括状态行、响应头和响应主体。主要是：请求是否成功，服务器的信息以及浏览器中直接可以看到的内容。]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>请求报文，响应报文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[遮罩层的简单使用分析]]></title>
    <url>%2F2019%2F06%2F04%2F%E9%81%AE%E7%BD%A9%E5%B1%82%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[今天我们来聊聊遮罩层的简单使用。遮罩层是基于以下几个属性来实现的： 1.z-index定义：z-index 属性设置元素的堆叠顺序。拥有更高堆叠顺序的元素总是会处于堆叠顺序较低的元素的前面。简单来说就是谁的z-index属性值高在z轴方向会在更外面。 2.opacity作用：规定不透明度。从 0.0 （完全透明）到 1.0（完全不透明）。 3.display这里我们只需要理解这个属性的两个值：none :此元素不会被显示。block :此元素将显示为块级元素，此元素前后会带有换行符。(简单理解就是显示) 4.position定位，需要这个属性是因为，有了这个属性才可以控制遮罩层放哪（一般在中心位置）。 这些了解以后，看看下面的案例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;遮罩层&lt;/title&gt; &lt;style&gt; html,body &#123; margin:0; height:100%; &#125; #shade&#123; position:absolute; top:0; left:0; z-index:2; /*z-index 属性设置元素的堆叠顺序。拥有更高堆叠顺序的元素总是会处于堆叠顺序较低的元素的前面。*/ width:100%; height:100%; background-color:#000; opacity:0.3; /*opacity透明度*/ /*兼容IE8及以下版本浏览器*/ filter: alpha(opacity=30); display:none; &#125; #modal &#123; position: absolute; z-index:3; top: 0; bottom: 0; left: 0; right: 0; width:200px; height:200px; margin: auto; display:none; background-color:skyblue; &#125;&lt;/style&gt; &lt;script&gt; window.onload=function()&#123; var a1=document.getElementById('a1'); var a2=document.getElementById('a2'); a1.onclick=shield; a2.onclick=cancel_shield; function shield(e)&#123; e.preventDefault();//取消事件的默认动作。 var shade = document.getElementById("shade"); shade.style.display = "block"; var modal = document.getElementById("modal"); modal.style.display = "block"; &#125; function cancel_shield(e)&#123; e.preventDefault();//取消事件的默认动作。 var shade = document.getElementById("shade"); shade.style.display = "none"; var modal = document.getElementById("modal"); modal.style.display = "none"; &#125; &#125;;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;a id="a1" href="#"&gt;打开遮罩&lt;/a&gt;&lt;div id="shade"&gt;&lt;/div&gt;&lt;div id="modal"&gt; &lt;a id="a2" href="#"&gt;关闭&lt;/a&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果图：开始：点击：打开遮罩 总结总的来说，遮罩其实是在原来界面上加上一个半透明的蒙版，然后在外面在加一个你想要实现的效果。注意点：1.z-index的值是大的在外面。2.position属性如果不设置则无法移动位置。]]></content>
      <categories>
        <category>css/html</category>
      </categories>
      <tags>
        <tag>遮罩层</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端学习路线---避免踩坑]]></title>
    <url>%2F2019%2F06%2F04%2F%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF---%E9%81%BF%E5%85%8D%E8%B8%A9%E5%9D%91%EF%BC%8C%E7%9B%B4%E5%87%BB%E5%85%AC%E5%8F%B8%E9%9C%80%E6%B1%82%2F</url>
    <content type="text"><![CDATA[我自己在学习web前端之前对web的学习路线也是很懵，在网上查了查各种学习路线也是有点慌。今天我就自己的学习过程来聊一聊web各个阶段需要学习的内容，以及怎么样就可以去面试了。 初期阶段html+css+javaScript。在我看来html负责网页点基本框架—房梁，毛胚房。css负责网页点美化装饰—房屋的装修。js负责网页的一些特效让其更酷炫—房屋的一些功能性建筑。学完这一部分我们如果可以自己写一个静态页面也就差不多了。学习视频推荐：1.html,css部分：http://yun.itheima.com/course/267.html2.js部分：https://www.bilibili.com/video/av34087791?from=search&amp;seid=2090123722468261815 中级阶段h5,c3,jQuery,Ajax（php基础）这一阶段就需要学以上部分的内容了，php基础如果有时间学完了自然好，不够作为前端，php部分只需要一些基础罢了，因为在学Ajax时，需要前后端交互需要懂一些后端知识，这里推荐一个视频是ajax和php一起学习的 ：https://www.bilibili.com/video/av15657082?from=search&amp;seid=1260798168543389571h5,cs3推荐视频：https://www.bilibili.com/video/av32966342?p=2jQuery推荐视频：https://www.bilibili.com/video/av40716170?from=search&amp;seid=6250929934997451575 学完这些以后已经可以出去找实习了，不过如果想去比较好的公司的话还需要学习一些框架。 高级阶段bootstrap,vue,es6,node.js框架其实有很多为什么选择以上这些框架呢？这是我在各大招聘网站上看那些大公司对实习生的要求汇总选择出来的，也许有部分公司要求不一样，不过以上框架已经可以满足大部分公司的需求了。bootstrap属于一个css部分的ui框架方便我们界面布局，推荐视频：https://www.bilibili.com/video/av10636408?from=search&amp;seid=8826659398424695725vue推荐视频：https://www.bilibili.com/video/av36650577?from=search&amp;seid=13367424259640329646es6推荐视频:https://www.bilibili.com/video/av20327829?from=search&amp;seid=12468498045351456704node.js是属于后端的，那为什么把他写在这呢？现如今许多前端框架都依赖node.js，node.js也使前端工作变的更加轻松，在某一方面改变了前端以前比较尴尬的情况。node.js推荐视频：https://www.bilibili.com/video/av27670326?from=search&amp;seid=16453837271820328900 学无止境做web前端需要有一个意识—学无止境。现如今技术更新换代特别快，几年就出一个新框架，如果一直保守自己懂的那几个老框架，虽然也能完成任务，但久而久之势必会被淘汰。当学完了以上那些东西，web也属于入门了这时候我推荐还是多看一些书籍。这里我推荐几本书籍。推荐书籍：javaScript高级程序设计（第三版）（红宝书），javaScript权威指南（第六版）（犀牛书），javascript DOM编程艺术（第二版）以上推荐的都是原生javaScript的一些书籍，毕竟框架在怎么出新也是在原生javaScript的基础上写出来的，只有基础扎实才能走的更远。 以上是我就自身而谈的一些观点，也许不完全正确，欢迎大家指正。也欢迎对web感兴趣的小伙伴和我交流。]]></content>
      <categories>
        <category>css/html</category>
      </categories>
      <tags>
        <tag>心得分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用css中的border绘制三角形的方法和原理]]></title>
    <url>%2F2019%2F06%2F04%2F%E4%BD%BF%E7%94%A8css%E4%B8%AD%E7%9A%84border%E7%BB%98%E5%88%B6%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E6%96%B9%E6%B3%95%E5%92%8C%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[实现首先看看怎么实现的贴上代码; 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .sjx&#123; width: 0px; height: 0px; border-width: 40px; border-style: solid; border-color: transparent transparent transparent red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="sjx"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果图： 分析代码主要代码就是style中的border样式。首先宽高设为0，border-width就是三角形的高度，border-color（上，右，下，左）这里把前三个设置为透明，第四个设置为红色，所以三角形方向是向右的。为了方便理解，这里把border-color四个颜色都设置出来看看 这里可以这么理解:由于div宽高设置为0，而边框为40px就会出现一个80*80的正方形，上下左右平分则是四个三角形。但如果不设置下边框而设置其他三个边框则会如下图： 从这里可以看出没了下边框就变成了40*80的长方形，所以实质上这个正方形还是4个40*80的矩形拼成的。但是如果只设置左右，或者上下的边框则什么也没有，因为div长宽都为0，则显示不出来，这里之所以会显示是因为上下和左右至少各有一个，会互相赋值，比如上边框高度为40px由于没有宽度则不显示，此时如果设置一个左边框会把左边框的高40px赋值给上边框的框则会显示出来。]]></content>
      <categories>
        <category>css/html</category>
      </categories>
      <tags>
        <tag>border绘制三角形</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css选择器权重及其计算规则]]></title>
    <url>%2F2019%2F06%2F04%2Fcss%E9%80%89%E6%8B%A9%E5%99%A8%E6%9D%83%E9%87%8D%E5%8F%8A%E5%85%B6%E8%AE%A1%E7%AE%97%E8%A7%84%E5%88%99%2F</url>
    <content type="text"><![CDATA[css选择器 @[toc] 选择器类型 ID #id class .class 标签 p 通用 * 属性 [type=”text”] 伪类 ：hover 伪元素 ::first-line 子选择器、相邻选择器 css选择器权重值 选择器 权重 !important 权重 !important Infinity(无限大) 行列样式 1000 Id选择器 0100 Class选择器/属性/伪类 0010 标签选择器 0001 *通配符选择器 0000 (大于默认样式与继承验样式) 继承样式 权重最小(比*通配符还小) 注意：选择器的权重值不是一个确定的值，例如标签选择器的权重值为1，但是这个1是一个256进制数，就是0到255后+1才是1。就是说权重值2和1中间差了255。这表示256个权重值为1的选择器加一起才抵得上一个权重为2的，这在后面权重计算有用。 还有需要注意的是，！important的权重值虽然是正无穷，但其实也是可也计算的，比如正无穷+1或者*1，就是要比正无穷大，在计算机中正无穷的值，都是一个有界的。不是数学上无界的一个慨念！权重计算方法 一般而言，选择器越特殊，它的优先级越高。也就是选择器指向的越准确，它的优先级就越高。单一选择器直接比较权重，多个选择器则需要计算。 复杂的计算方法： 用1表示派生选择器的优先级 用10表示类选择器的优先级 用100标示ID选择器的优先级- div.test1 .span var 优先级 1+10 +10 +1 span#xxx .songs li 优先级1+100 + 10 + 1 #xxx li 优先级 100 +1 案例]]></content>
      <categories>
        <category>css/html</category>
      </categories>
      <tags>
        <tag>选择器权重计算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css控制超出一行内容显示省略号]]></title>
    <url>%2F2019%2F06%2F04%2Fcss%E6%8E%A7%E5%88%B6%E8%B6%85%E5%87%BA%E4%B8%80%E8%A1%8C%E5%86%85%E5%AE%B9%E6%98%BE%E7%A4%BA%E7%9C%81%E7%95%A5%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[前言在前端开发过程中，经常会遇到文字超过一行内容的情况，要求隐藏超出部分并且以省略号显示。像这样： 实现方法主要依赖下面三个属性实现 123456/* 规定段落中的文本不进行换行： */white-space: nowrap;/* 内容会被修剪，并且其余内容是不可见的。 */overflow: hidden;/* 显示省略符号来代表被修剪的文本。 */text-overflow: ellipsis 实例1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body &#123; width: 500px; text-align: center; &#125; div&#123; /* 规定段落中的文本不进行换行： */ white-space: nowrap; /* 内容会被修剪，并且其余内容是不可见的。 */ overflow: hidden; /* 显示省略符号来代表被修剪的文本。 */ text-overflow: ellipsis &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;“世界很复杂，百度更懂你”，百度翻译拥有网页版和手机APP等多种产品形态，此外还针对开发者提供开放云接口服务，日均响应上亿次翻译请求。除文本翻译外，结合用户多样性的翻译需求，推出网页翻译、网络释义、海量例句、权威词典、离线翻译、语音翻译、对话翻译、实用口语、拍照翻译、AR翻译、趣味配音等功能，同时还针对对译文质量要求较高的用户，提供人工翻译服务，让用户畅享每一次翻译体验。&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果如图：]]></content>
      <categories>
        <category>css/html</category>
      </categories>
      <tags>
        <tag>css控制一行显示</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端必备PS技巧]]></title>
    <url>%2F2019%2F06%2F04%2F%E5%89%8D%E7%AB%AF%E5%BF%85%E5%A4%87PS%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[PS在前端主要有两方面的应用：1：测量图像大小、距离 2：切图测量不用说大家平时开发都需要用，而切图也是前端必备技能。我们作为前端会比UI更清楚我们需要的图片，有时候需要修改也可以自己动手，不必处处麻烦UI，也提高了工作效率。 那我们从零开始吧！ 1.下载工具PS在这里分享一下正版PS安装包，内含注册码的，链接失效了可以下方评论。下载链接：链接：https://pan.baidu.com/s/1oIeHrcH2VBGx8ujO2MGiKA提取码：adoz 2. 设置工具为了使用更加方面我们可以先设置一下一些窗口格式。在上面菜单栏点击窗口把：图层，信息，历史记录勾选上在视图窗口把标尺勾选上。 3.测量和取色 【测量宽高】工具：参考线，矩形选框，信息面板。 1 从标尺上拉出参考线（在标尺上按住鼠标左键不松往你想要地方拉，就会出现一根线，上下左右都可以，也可以不拉，拉了会更精确些，选框会自动吸附到参考线上） 2 找到矩形选框，选中你要测量的地方，选中的时候你可以看两个地方：1 鼠标位置有显示宽高 2 信息面板也有显示。不过当你松开鼠标，就只有信息面板有显示信息了，如下。 【取色】：取色器+吸管工具 1 点击取色器，会出现一个面板，这个时候把鼠标放在图片上会发现自动变成了吸管工具，不用专门去找，然后点击你想要取的颜色，面板上就出现你想要的信息。（还可以用取色器检查你的按钮或者背景是不是是纯色） 4.切图 ：切片工具现在工具栏找到切片工具：选取需要切的范围，然后在菜单栏—&gt;文件—&gt;转为web格式然后调整图片格式和质量按自己需求来：然后存储到相应位置使用即可。]]></content>
      <categories>
        <category>css/html</category>
      </categories>
      <tags>
        <tag>ps</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3 @media 查询]]></title>
    <url>%2F2019%2F06%2F04%2FCSS3%40media%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[CSS3 @media 查询 首先贴一个例子： 如果文档宽度小于 300 像素则修改背景颜色(background-color): 12345@media screen and (max-width: 300px) &#123; body &#123; background-color:lightblue; &#125;&#125; 定义和使用使用 @media 查询，你可以针对不同的媒体类型定义不同的样式。 @media 可以针对不同的屏幕尺寸设置不同的样式，特别是如果你需要设置设计响应式的页面，@media 是非常有用的。 当你重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面。 Media所有参数汇总 width:浏览器可视宽度。 height:浏览器可视高度。 device-width:设备屏幕的宽度。 device-height:设备屏幕的高度。 orientation:检测设备目前处于横向还是纵向状态。 aspect-ratio:检测浏览器可视宽度和高度的比例。(例如：aspect-ratio:16/9) device-aspect-ratio:检测设备的宽度和高度的比例。 color:检测颜色的位数。（例如：min-color:32就会检测设备是否拥有32位颜色） color-index:检查设备颜色索引表中的颜色，他的值不能是负数。 monochrome:检测单色楨缓冲区域中的每个像素的位数。（这个太高级，估计咱很少会用的到） resolution:检测屏幕或打印机的分辨率。(例如：min-resolution:300dpi或min-resolution:118dpcm)。 grid：检测输出的设备是网格的还是位图设备。 使用方法 准备工作1：设置Meta标签首先我们在使用Media的时候需要先设置下面这段代码，来兼容移动设备的展示效果： 1&lt;meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"&gt; 这段代码的几个参数解释： width = device-width：宽度等于当前设备的宽度 initial-scale：初始的缩放比例（默认设置为1.0） minimum-scale：允许用户缩放到的最小比例（默认设置为1.0） maximum-scale：允许用户缩放到的最大比例（默认设置为1.0） user-scalable：用户是否可以手动缩放（默认设置为no，因为我们不希望用户放大缩小页面） 准备工作2：加载兼容文件JS因为IE8既不支持HTML5也不支持CSS3 Media，所以我们需要加载两个JS文件，来保证我们的代码实现兼容效果： 1234&lt;!--[if lt IE 9]&gt; &lt;script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"&gt;&lt;/script&gt; &lt;script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"&gt;&lt;/script&gt;&lt;![endif]--&gt; 准备工作3：设置IE渲染方式默认为最高(这部分可以选择添加也可以不添加)现在有很多人的IE浏览器都升级到IE9以上了，所以这个时候就有又很多诡异的事情发生了，例如现在是IE9的浏览器，但是浏览器的文档模式却是IE8: 为了防止这种情况，我们需要下面这段代码来让IE的文档模式永远都是最新的： 1&lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; 案例1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"/&gt;&lt;style&gt;body &#123; background-color:lightgreen;&#125;@media screen and (max-width: 300px) &#123; body &#123; background-color:lightblue; &#125;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;重置浏览器查看大小。当浏览器窗口的宽度小于 300 像素时，背景颜色会变成淡蓝，否则是淡绿色。&lt;input type="button" onclick="resize_window()" value="查看效果"&gt;&lt;/p&gt;&lt;SCRIPT&gt;&lt;!--function resize_window() &#123; window.open ('http://www.w3cschool.cc/try/demo_source/trycss3_media_example1.htm','newwindow','height=299,width=299,top=0,left=0,toolbar=no,menubar=no,scrollbars=no, resizable=no,location=no, status=no')&#125;//写成一行--&gt;&lt;/SCRIPT&gt;&lt;/body&gt;&lt;/html&gt; 效果图参考：http://www.520ued.comhttp://www.runoob.com/cssref/css3-pr-mediaquery.html]]></content>
      <categories>
        <category>H5/C3</category>
      </categories>
      <tags>
        <tag>_@media</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rem、em的区别与使用方法]]></title>
    <url>%2F2019%2F06%2F04%2Frem%E3%80%81em%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[## 前言 我们先来看看比较重要的两点： rem与em的本质区别 rem(root element)是参照html的font-size,em(element)是参照父元素的font-size 使用rem与em的优点 以rem/em为单位比px更方便,屏幕尺寸发生变化时只需要更改html/body基数即可,不需要再重新给每个标签写不同的font-size rem 使用rem为单位,系统处理时(将rem转化为px)只会看html的font-size 在使用media query做响应式布局时(以bootstrap为例)： a.首先要做的是确定rem的基数(即html的font-size),一般都是以10px为基数(方便计算),这个可以根据自己的习惯来. b.确定html基准百分数(rem参照下html的字体大小采取百分数形式),百分数是自己设定的基数除以默认字体大小(16px)的值.比如以10px为基数时,基准百分数就是: 10px/16px=62.5%;即设置html的font-size为62.5%; c.当html的基准百分数设置之后,元素使用rem为单位时就是以基数(a中设置的基数值)为基础单位,换算方式为: 10px=1rem;比如要设置一个p标签的字体大小为20px,用rem表示就是2rem(公式: 以rem为单位的值=想要设置的字体大小(20px)/基数值(10px)=2rem). d.响应式实现: 使用@media 在监测到屏幕尺寸发生变化时只需为html设置不同的基数值即可 如下面例子: 在屏幕宽度小于414px时以8px为基数,非响应式下(415px-1365px)以10px为基数;大于1366px时以12px为基数 12345678910111213141516171819html&#123; font-size: 62.5%; // 以10px为基数,此时class为a的标签字体大小为20px&#125; .a&#123; font-size: 2rem;&#125; @media screen and (max-width: 414px)&#123; html&#123; font-size: 50%; // 以8px为基数,此时class为a的标签字体大小为16px &#125;&#125; @media screen and (min-width: 1366px)&#123; html&#123; font-size: 75%; // 以12px为基数,此时class为a的标签字体大小为24px &#125;&#125; em 使用em为单位,系统处理时(将em转化为px)只会看父元素（本文以body为例）的font-size 使用px为基准此时只需要设置一个基数即可,然后接下来使用时只需要用想要的字体大小除以设置的基数值即为以em为单位的值;如: 设置em基数为10px,要设置一个标签的字体大小为15px,则em=想要设置的值(15px)/基数(10px)=1.5em.例: 12345678910111213141516171819body&#123; font-size: 10px; // 以10px为基数,此时class为a的标签字体大小为20px&#125; .a&#123; font-size: 2em;&#125; @media screen and (max-width: 414px)&#123; body&#123; font-size: 8px; // 以8px为基数,此时class为a的标签字体大小为16px &#125;&#125; @media screen and (min-width: 1366px)&#123; body&#123; font-size: 12px; // 以12px为基数,此时class为a的标签字体大小为24px &#125;&#125; 使用百分比为基准 使用方式同上面以rem为单位的步骤,例: 12345678910111213141516171819body&#123; font-size: 62.5%; // 以10px为基数,此时class为a的标签字体大小为20px&#125; .a&#123; font-size: 2em;&#125; @media screen and (max-width: 414px)&#123; body&#123; font-size: 50%; // 以8px为基数,此时class为a的标签字体大小为16px &#125;&#125; @media screen and (min-width: 1366px)&#123; body&#123; font-size: 75%; // 以12px为基数,此时class为a的标签字体大小为24px &#125;&#125; 说明: 具体使用时其实两者差不多,rem也可以直接以px为基准单位,只是两者参照标签不同,使用时需注意]]></content>
      <categories>
        <category>css/html</category>
      </categories>
      <tags>
        <tag>_rem _em</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端需要了解的JSON---数据读取与转化]]></title>
    <url>%2F2019%2F05%2F10%2F%E5%89%8D%E7%AB%AF%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84JSON---%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%8F%96%E4%B8%8E%E8%BD%AC%E5%8C%96%2F</url>
    <content type="text"><![CDATA[### 学习JSON之前我们需要明白的几点： 12345678/* * 1.json是一种数据的格式 * 2.json跟编程语言没有关系 * 3.json的载体是字符串 * 4.基本上所有的编程语言都支持JSON * 5.语言简洁 基本上所有的编程语言 都提供了对应的方法 来解析JSON * 6.JSON格式的字符串 转换完毕之后 会变成数组 对象 * */ json的写法 – 用来表示对象123456789//对象使用&#123;&#125; //属性名 必须使用""包裹 如果属性值是数值 可以不使用双引号 var JSONObject = '&#123;"name":"刘亦菲","skill":"失忆"&#125;'; console.log(JSONObject); //转化为 对应的 对象（数组） var obj = JSON.parse(JSONObject); console.log(obj); //读取对象属性值 console.log(obj.name+'|'+obj.skill); 结果： JSON的写法 – 用来表示数组1234567var JSONArr = '["绿色的花菜","大蒜","番茄","圣女果"]';console.log(JSONArr);//转化为对应的数组（对象）var arr = JSON.parse(JSONArr);console.log(arr);//读取数组中第三个元素console.log(arr[2]); 结果： JSON的写法 – 对象数组1234567var JSONObjArr = '&#123;"name":"彭林","skill":"约跑","friend":["周琳琳","林立群","....."]&#125;'; console.log(JSONObjArr); //转化为对应的对象数组 var result = JSON.parse(JSONObjArr); console.log(result); //读取对象数组元素 console.log(result.friend[1]); 结果：]]></content>
      <categories>
        <category>json</category>
      </categories>
      <tags>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剖析js原型与原型链]]></title>
    <url>%2F2019%2F05%2F10%2F%E5%89%96%E6%9E%90js%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[## 原型模式 &emsp;&emsp;我们创建的每一个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，而这这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。如果按字面意思来理解，那么prototype就是通过调用构造函数而创建的那个对象实例的原型对象。使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。换句话说，不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中，如下面的例子所示： 原型对象和实例的关系有点像JAVA中父类子类的关系，有些继承的味道。 12345678910111213141516function persion()&#123;&#125;persion.prototype.name = "Nicholas";persion.prototype.age = 29;persion.prototype.job = "Software Engineer";persion.prototype.sayName = function () &#123; alert(this.name);&#125;;var person1 = new persion();person1.sayName(); //"Nicholas"var person2 = new persion();person2.sayName(); //"Nicholas"alert(person1.sayName == person2.sayName); //"true" &emsp;&emsp;在此，我们将sayName（）方法和所有属性直接添加到了person的prototype属性中，构造函数变成了空函数。即使如此，也仍然可以通过调用构造函数来创建新对象，而且新对象还会具有相同的属性和方法。但与构造函数模式不同的是，新对象的这些属性和方法是由所有实例共享的。换句话说，person1和person2访问的都是同一组属性和同一个sayName（）函数。要理解原型模式的工作原理，必须先理解ECMAScript中原型对象的性质。 1.理解原型对象&emsp;&emsp;无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个prototype属性，这个属性指向函数的原型对象。在默认情况下，所有原型对象都会自动获得一个constructor（构造函数）属性，这个属性包含一个指向prototype属性所在函数的指针。就拿前面的例子来说，Person.prototype.constructor 指向person。而通过这个构造函数，我们还可继续为原型对象添加其他属性和方法。&emsp;&emsp;创建了自定义的构造函数之后，其原型对象默认只会取得 constructor属性；至于其他方法，则都是从object继承而来的。当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部属性），指向构造函数的原型对象。ECMA-262第5版中管这个指针叫[[Prototype]]。虽然在脚本中没有标准的方式访问[[Prototype]]，但Firefox、Safari和Chrome在每个对象上都支持一个属性proto；而在其他实现中，这个属性对脚本则是完全不可见的。不过，要明确的真正重要的一点就是，这个连接存在于实例与构造函数的原型对象之间，而不是存在于实例与构造函数之间。&emsp;&emsp;以前面使用Person构造函数和 Person.prototype创建实例的代码为例，图6-1展示了各个对象之间的关系。&emsp;&emsp;图6-1展示了person构造函数、person的原型属性以及person现有的两个实例之间的关系。在此，person.prototype 指向了原型对象，而Person.prototype.constructor又指回了Person。原型对象中除了包含constructor属性之外，还包括后来添加的其他属性。person的每个实例——person1和person2都包含一个内部属性，该属性仅仅指向了person.prototype；换句话说，它们与构造函数没有直接的关系。此外，要格外注意的是，虽然这两个实例都不包含属性和方法，但我们却可以调用person1.sayName（）。这是通过查找对象属性的过程来实现的。 这可以这么理解，构造函数是一个空函数。创建一个实例的代码虽然是构造函数new出来的，可实际上是通过原型对象创建出来的，实例与构造函数并没有直接的关系，实例是基于原型对象创建的，而原型对象的constructor指向构造函数。 &emsp;&emsp;虽然在所有实现中都无法访问到[[Prototype]]，但可以通过isPrototypeOf（）方法来确定对象之间是否存在这种关系。从本质上讲，如果[[Prototype]]指向调用isPrototypeof（）方法的对象（person.prototype），那么这个方法就返回true，如下所示： 12alert(Person.prototype.isPrototypeof(person1));//truealert(Person.prototype.isPrototypeof(person2));//true &emsp;&emsp;这里，我们用原型对象的isPrototypeof（）方法测试了person1和person2。因为它们内部都有一个指向Person.prototype的指针，因此都返回了true。&emsp;&emsp;ECMAScript5增加了一个新方法，叫object.getPrototypeof（），在所有支持的实现中，这个方法返回t[Prototype]]的值。例如： 12alert(Object.getPrototypeof(personl)==Person.prototype);//true alert(Object.getPrototypeof(person1). name);//"Nicholas" &emsp;&emsp;这里的第一行代码只是确定object.getPrototypeof（）返回的对象实际就是这个对象的原型。第二行代码取得了原型对象中name属性的值，也就是“Nicholas”。使用object.getPrototypeof（）可以方便地取得一个对象的原型，而这在利用原型实现继承（本章稍后会讨论）的情况下是非常重要的。支持这个方法的浏览器有IE9+、Firefox 3.5+、Safari 5+、Opera12+和Chrome。&emsp;&emsp;每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性。搜索首先从对象实例本身开始。如果在实例中找到了具有给定名字的属性，则返回该属性的值；如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性。如果在原型对象中找到了这个属性，则返回该属性的值。也就是说，在我们调用person1.sayName（）的时候，会先后执行两次搜索。首先，解析器会问：“实例 person1有sayName属性吗？”答：“没有。”然后，它继续搜索，再问：“person1的原型有sayName属性吗？”答：“有。”于是，它就读取那个保存在原型对象中的函数。当我们调用person2.sayName（）时，将会重现相同的搜索过程，得到相同的结果。而这正是多个对象实例共享原型所保存的属性和方法的基本原理。 搜索首先从对象实例本身开始。如果在实例中找到了具有给定名字的属性，则返回该属性的值；如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性。 &emsp;&emsp;虽然可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值。如果我们在实例中添加了一个属性，而该属性与实例原型中的一个属性同名，那我们就在实例中创建该属性，该属性将会屏蔽原型中的那个属性。来看下面的例子。 123456789101112function Person()&#123;Person. prototype. name="Nicholas"; Person. prototype. age=29; Person. prototype. job="Software Engineer"; Person. prototype, sayName=function()(alert(this. name);&#125;; var personl=new Person();var person2=new Person();peraonl.name =nGreg"；alert（person1.name）；//"Greg"—来自实例alert（person2.name）；//"Nicholaa"——来自原型 &emsp;&emsp;在这个例子中，person1的name 被一个新值给屏蔽了。但无论访问person1.name还是访问person2.name都能够正常地返回值，即分别是“Greg*（来自对象实例）和“wicholas”（来自原型）。当在alert（）中访问 person1.name时，需要读取它的值，因此就会在这个实例上搜索一个名为name的属性。这个属性确实存在，于是就返回它的值而不必再搜索原型了。当以同样的方式访问 person2.name时，并没有在实例上发现该属性，因此就会继续搜索原型，结果在那里找到了name-属性。&emsp;当为对象实例添加一个属性时，这个属性就会屏蔽原型对象中保存的同名属性；换句话说，添加这个属性只会阻止我们访问原型中的那个属性，但不会修改那个属性。即使将这个属性设置为nu11，也只会在实例中设置这个属性，而不会恢复其指向原型的连接。 可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值。如果实例中添加的属性与实例原型中一样则会断开该属性指向原型的连接 不过，使用delete 操作符则可以完全删除实例属性，从而让我们能够重新访问原型中的属性，如下所示。 123456789101112131415161718function Person()&#123;&#125;Person.prototype.name="Nicholas";Person.prototype.age=29;Person.prototype.job="Software Engineer";Person.prototype.sayName=function()&#123;alert（this.name）；&#125;;var personl=new Person();var pexson2=new Person();person1.name="Greg";alert(personl.name);//"Greg“——来自实例alert(person2.name);//"Nicholas“——来自原型delete personl.name;alert(peraonl.name);//"Nicholaa——来自原型 &emsp;&emsp;在这个修改后的例子中，我们使用delete操作符删除了person1.name，之前它保存的“Greg”值屏蔽了同名的原型属性。把它删除以后，就恢复了对原型中name属性的连接。因此，接下来再调用person1.name时，返回的就是原型中name属性的值了。 原型链&emsp;&emsp;ECMAScript中描述了原型链的概念，并将原型链作为实现继承的主要方法。其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。简单回顾一下构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。那么，假如我们让原型对象等于另一个类型的实例，结果会怎么样呢？显然，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立，如此层层递进，就构成了实例与原型的链条。这就是所谓原型链的基本概念。 可以简单理解成一个环套一个环和铁链一样。第一个环里的原型对象是第二个环里的实例，第二个环里的原型对象又是第三环里的实例则一环套一环。 &emsp;&emsp;实现原型链有一种基本模式，其代码大致如下。 123456789101112131415161718192021function SuperType()&#123;this. property=true;&#125;Superrype.prototype.get SuperValue=function（）&#123;return this.property;&#125;;function SubType（）&#123;this.subproperty=false;&#125;//继承了SuperType Subrype.prototype=newSuperlype（）;SubType.prototype.getSubValue=function（）&#123;return this.subproperty;）;var instance=new SubType（）;alert（instance.getSuperValue（））;//true &emsp;&emsp;以上代码定义了两个类型：Superrype和SubType。每个类型分别有一个属性和一个方法。它们的主要区别是Subrype继承了superrype，而继承是通过创建Superrype的实例，并将该实例赋给SubType.prototype实现的。实现的本质是重写原型对象，代之以一个新类型的实例。换句话说，原来存在于Superrype的实例中的所有属性和方法，现在也存在于Sublype.prototype中了。在确立了继承关系之后，我们给SubType.prototype 添加了一个方法，这样就在继承了SuperType的属性和方法的基础上又添加了一个新方法。这个例子中的实例以及构造函数和原型之间的关系如图6-4所示。&emsp;&emsp;在上面的代码中，我们没有使用Subype默认提供的原型，而是给它换了一个新原型；这个新原型就是superrype的实例。于是，新原型不仅具有作为一个Superrype的实例所拥有的全部属性和方法，而且其内部还有一个指针，指向了superrype的原型。最终结果就是这样的：instance指向 Subrype的原型，subrype的原型又指向Superrype的原型。getSupervalue（）方法仍然还在SuperType.prototype中，但property 则位于SubType.prototype中。这是因为property是一个实例属性，而 getSuperValue（）则是一个原型方法。既然 SubType.prototype 现在是Superrype的实例，那么property当然就位于该实例中了。此外，要注意instance.constructor现在指向的是Supertype，这是因为原来subrype.prototype中的 constructor被重写了的缘故。&emsp;&emsp;通过实现原型链，本质上扩展了本章前面介绍的原型搜索机制。读者大概还记得，当以读取模式访问一个实例属性时，首先会在实例中搜索该属性。如果没有找到该属性，则会继续搜索实例的原型。在通过原型链实现继承的情况下，搜索过程就得以沿着原型链继续向上。就拿上面的例子来说，调用instance.getSuperValue（）会经历三个搜索步骤：1）搜索实例；2）搜索Subrype.prototype；3）搜索SuperType.prototype，最后一步才会找到该方法。在找不到属性或方法的情况下，搜索过程总是要一环一环地前行到原型链末端才会停下来。 参考书籍：JavaScript高级程序设计（第三版）]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>原型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[匿名函数、自执行函数，自执行匿名函数和立即执行的函数表达式区别]]></title>
    <url>%2F2019%2F05%2F10%2F%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E3%80%81%E8%87%AA%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0%EF%BC%8C%E8%87%AA%E6%89%A7%E8%A1%8C%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E5%92%8C%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E7%9A%84%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[## 匿名函数、自执行函数，自执行匿名函数和立即执行的函数表达式区别 今天在写代码的时候发现对自执行函数有点懵，便去查询资料。然后紧接着自执行匿名函数，立即执行函数，匿名函数一窝蜂的出来了，借此就好好谈谈这几个函数的区别吧。 匿名函数匿名函数比较好理解，顾名思义就是没有名字的函数 12345678//普通函数:此函数声明了一个名为a的函数。 function a()&#123; return 1; &#125;;//匿名函数:这时你会发现报错了function()&#123; return 1;&#125;; 这时你会发现单独运行一个匿名函数，由于不符合语法要求，会报错。解决方法：只需要用（）把匿名函数包起来即可 123（function()&#123; return 1;&#125;;） 自执行函数，立即执行的函数在介绍这里之前，我们先聊一聊”自执行”这个说法，关于”自执行“每个人理解不一样，有人称他为：自动执行，也有称作：立即调用，在这里我比较认同另一种说法:立即调用的函数表达式。 什么是自执行？ 我们创建了一个匿名的函数，并立即执行它，由于外部无法引用它内部的变量，因此在执行完后很快就会被释放，关键是这种机制不会污染全局对象。 自执行函数，即定义和调用合为一体。 1234567//对于函数表达式，在后面加括号即可以让函数立即执行；例如下面这个函数，至于为什么加了括号就可以立即执行，我们可以这么理解，就是像f()；这样写的话，函数 可以立即执行是没问题的，我们在经常会用到，那么对于函数表达式来说，fn1就是对后面的匿名函数的一个引用，因此在后面的匿名函数后直接加括号，自然也就可以立即执行 var f = function()&#123; console.log("ss"); &#125;(); 自执行函数的其他几种写法我个人推荐第一种写法，好处是，能提醒阅读代码的人，这段代码是一个整体。 1234567891011121314151617//方法1：最前最后加括号(function()&#123; alert(1);&#125;());//方法2：function外面加括号(function()&#123; alert(1);&#125;)();方法3：function前面加运算符，常见的是!与void 。!function()&#123; alert(1);&#125;();void function()&#123; alert(2);&#125;(); 在参考了多个网站总算将这些理念弄清楚一些。 参考网址： http://www.cnblogs.com/TomXu/archive/2011/12/31/2289423.html https://www.cnblogs.com/jessiespur/p/9283101.html https://www.jianshu.com/p/1d52ed86d52c]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>匿名函数 自执行函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基本类型和引用类型的区别以及在内存中的分配]]></title>
    <url>%2F2019%2F05%2F10%2F%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%88%86%E9%85%8D%2F</url>
    <content type="text"><![CDATA[ECMAScript变量可能包含两种不同数据类型的值：基本类型值和引用类型值。基本类型值指的是简单的数据段，而引用类型值指那些可能由多个值构成的对象。 主要区别 基本数据类型 引用数据类型 &lt; 在栈中进行分配 在堆中进行分配 变量名指向具体的数值 变量名指向存数据对象的内存地址,即变量名指向hash值 变量在声明之后java就会立刻分配给他内存空间 它以特殊的方式(类似C指针)指向对象实体（具体的值），这类变量声明时不会分配内存，只是存储了一个内存地址 基本类型之间的赋值是创建新的拷贝 对象之间的赋值只是传递引用 “==”和“!=”是在比较值 “==”和“!=”是在比较两个引用是否相同，需要自己实现equals()方法 基本类型变量创建和销毁很快 类对象需要JVM去销毁 动态的属性定义基本类型值和引用类型值的方法时类似的：创建一个变量并为该变量赋值。但是对于不同类型值可以执行的操作就不一样了。 引用类型值我们可以为其添加属性和方法，也可以改变和删除其属性和方法。请看下面的例子： 123var person = new Object();person.name = "Nicholas";//添加属性并且赋值alert(person.name);//输出Nicholas 上面代码创建了一个对象并将其保存在了变量person中。然后为对象添加了一个名为name的属性并且将字符串“Nicholas”赋给了这个属性。 基本类型值我们不能给基本类型的值添加属性，尽管这样做并不会出错。例如： 123var name = "Nicholas";name.age = 27;alert(name.age); //得到：undefind 在这个例子中，我们为字符串name定义了一个名为age的属性，并且赋值27。但在下面使用alert访问这个属性的时候，发现该属性不存在。这说明基本类型不能动态的添加属性。 复制变量值除了保存方式不同之外，在从一个变量向另一个变量复制基本类型和引用类型值时，也存在不同。 基本类型值如果从一个变量向另一个变量复制基本类型的值，会在变量对象上创建一个新值。然后把改制复制到新变量分配的位置上。看一个小例子： 12var num1 = 5;var num2 = num1; 在此，num1中保存的值时5.当使用num1的值来初始化num2时，num2中也保存了值5.但num2中的5与num1中 的5 是完全独立的。该值只是num1中5的一个副本。这两个变量可以参与任何操作而不会相会影响。 引用类型值当从一个变量向另一个变量复制引用类型的值时，同样也会将存储在变量对象中的值复制一份放到为新变量分配的空间中。不同的是，这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一个对象。复制操作以后，这两个变量实际上将引用同一个对象。因此，改变其中一个变量，就会影响另一个变量。如下面的例子所示： 1234var obj1 = new object();var obj2 = obj1;obj1.name = "Nicholaa";alert(obj2.name);//输出“Nicholas” 首先，变量obj1保存了一个对象的新实例。然后，这个值被复制到了obj2中；换句话说，obj1和obj2都指向同一个对象。这样，当为obj1添加属性name后，可以通过obj2来访问这个属性，因为这两个变量引用都是同一个对象。具体关系可以看下图：参考文献：JavaScript高级程序设计（第3版）]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>基本类型和引用类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中的回调函数callback]]></title>
    <url>%2F2019%2F05%2F10%2FJavaScript%E4%B8%AD%E7%9A%84%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0callback%2F</url>
    <content type="text"><![CDATA[## 解释 A callback is a function that is passed as an argument to another function and is executed after its parent function has completed. 以上callback的英文解释，非常清晰简明，有时候英文理解要比翻译成中文二次理解更清楚。大概意思是：回调是一个函数，它作为参数传递给另一个函数，并在其父函数完成后执行。其实函数也是一种数据类型，既可以当作参数进行传递，也可以当作方法的返回值传递 先明白异步和同步想要理解清楚callback还是需要先把异步async/同步sync概念弄清楚。先写一个异步小例子： 12345678910111213141516function a()&#123; console.log('我是函数a开头') setTimeout(function () &#123; console.log('我是setTimeout') &#125;,1000) console.log('我是函数a结尾')&#125;function b()&#123; console.log('我是函数b')&#125;a()b() 执行结果： 从执行结果可以看出来执行顺序是之上而下执行下来，但setTimeout函数被放在了最后执行。这是一个异步操作，执行的时候并不会等待setTimeout而直接向下执行，等到所有任务执行完成在回过头来执行setTimeout函数。即使setTimeout第二个参数是0也会最后执行，setTimeout第二个参数的数字是表示执行最快时间不是一个确定时间。 理解&emsp;&emsp;回调函数字面上理解下来就是，回调就是一个函数的调用过程。函数a有一个参数，这个参数是个函数b，当函数a执行完以后执行函数b。那么这个过程就叫回调。字面意思也很好理解：回调，回调，就是回头调用的意思。函数a的事先干完，回头再调用函数b。&emsp;&emsp;需要注意的是：所以回调与同步、异步并没有直接的联系，回调只是一种实现方式，既可以有同步回调，也可以有异步回调，还可以有事件处理回调和延迟函数回调，这些在我们工作中有很多的使用场景&emsp;&emsp;所以其实并不是我们不认识回调函数，而是我们都萦绕在了这个“callback“ 这个词上，当你在一个函数中看到它是就会困惑，其实它只是一个形参名字而已。 回调函数其实我们平时都使用过，来看看下面几个经典的： ajax中的回调函数： 点击事件的回调函数： 数组中遍历的回调函数： 作用大多数情况下，callback是用来拿到函数中的数据，这牵扯到闭包的概念，可以看这篇文章：javaScript里的闭包到底是什么？该怎么理解？ 就以Ajax的封装为例吧： 1234567var oReq = new XMLHttpRequest() oReq.onload = function () &#123; console.log(oReq.responseText) &#125; oReq.open("get",url,true) oReq.send() 上面的是为封装的Ajax，我们请求到的数据responseText只能在onload中拿到，想要拿数据进行下一步操作也只能在onload函数中进行。但我们如果要封装给其他人使用，我们并不知道使用者需要拿这数据干什么，因此我们需要把responseText传递出去，这时候就需要使用callback。 1234567891011121314 function get(url,callback)&#123; var oReq = new XMLHttpRequest() oReq.onload = function () &#123;// console.log(oReq.responseText) callback(oReq.responseText) &#125; oReq.open("get",url,true) oReq.send() &#125; get('data.json', function (data) &#123; console.log(data) &#125;) 上面这是封装以后的代码，我们通过callback把responseText传递出去,get方法的第二个参数就是回调函数callback，而data就是callback函数传递出来的responseText数据，通过回调函数拿到数据，使用者需要拿数据干什么都行了。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>callback</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[定时调用和延时调用用法及区别]]></title>
    <url>%2F2019%2F05%2F10%2F%E5%AE%9A%E6%97%B6%E8%B0%83%E7%94%A8%E5%92%8C%E5%BB%B6%E6%97%B6%E8%B0%83%E7%94%A8%E7%94%A8%E6%B3%95%E5%8F%8A%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[定时调用setlnterval()定义和用法setInterval() 方法可按照指定的周期（以毫秒计）来调用函数或计算表达式。 setInterval() 方法会不停地调用函数，直到 clearInterval() 被调用或窗口被关闭。由 setInterval() 返回的 ID 值可用作 clearInterval() 方法的参数。 语法setInterval(code,millisec) 参数 1、code（必需）：回调函数， 每隔一段时间要执行一次的函数 2、millisec（必需）：每次调用间隔时间，单位是ms 返回值 一个可以传递给 Window.clearInterval() 从而取消对 code 的周期性执行的值。 实例 12//每隔6000毫秒执行一次testFunction()函数，执行无数次。setInterval("testFunction()","6000"); 延时调用setTimeout()定义和用法setTimeout() 方法用于在指定的毫秒数后调用函数或计算表达式。 语法setTimeout(code,millisec) 参数 1、回调函数， 需要隔一定时间后执行的函数 2、每次调用间隔时间，单位是ms 提示和注释 提示：setTimeout() 只执行 code 一次。如果要多次调用，请使用 setInterval() 或者让 code 自身再次调用 setTimeout()。 实例 12//每隔6000毫秒执行一次testFunction()函数，执行无数次。setTimeout("testFunction()","6000"); 小案例]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>定时调用和延时调用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaScript正则表达式（内附最全的常用正则表达式）]]></title>
    <url>%2F2019%2F05%2F10%2FjavaScript%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E5%86%85%E9%99%84%E6%9C%80%E5%85%A8%E7%9A%84%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[### JavaScript 正则表达式 正则表达式（英语：Regular Expression，在代码中常简写为regex、regexp或RE）使用单个字符串来描述、匹配一系列符合某个句法规则的字符串搜索模式。 搜索模式可用于文本搜索和文本替换。 什么是正则表达式？正则表达式是由一个字符序列形成的搜索模式。当你在文本中搜索数据时，你可以用搜索模式来描述你要查询的内容。正则表达式可以是一个简单的字符，或一个更复杂的模式。正则表达式可用于所有文本搜索和文本替换的操作。 语法1/pattern/modifiers; 实例1var patt = /hello/i 实例解析： /hello/i 是一个正则表达式。hello 是一个模式 (用于检索匹配关键字)。i 是一个修饰符 (搜索不区分大小写)。 使用字符串方法 在 JavaScript 中，正则表达式通常用于两个字符串方法 : search() 和 replace()。 search() 方法 用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串，并返回子字符串的起始位置。 replace() 方法 用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子字符串。 search() 方法使用使用正则表达式搜索 “make” 字符串，且不区分大小写： 123var str = "Visit make";var n = str.search(/make/i);//结果：6 search 方法可使用字符串作为参数。字符串参数会转换为正则表达式： 123var str = "Visit make";var n = str.search("make");//结果：6 replace() 方法使用使用正则表达式且不区分大小写将字符串中的 Microsoft 替换为 make : 123var str = "Visit Microsoft!";var res = str.replace(/microsoft/i, "make");//结果：Visit make! replace() 方法将接收字符串作为参数： 12var str = "Visit Microsoft!";var res = str.replace("Microsoft", "make"); 正则表达式修饰符修饰符 可以在全局搜索中不区分大小写:正则表达式模式 方括号用于查找某个范围内的字符： 常用正则表达式一、校验数字的表达式12345678910111213141516171819 1 数字：^[0-9]*$ 2 n位的数字：^\d&#123;n&#125;$ 3 至少n位的数字：^\d&#123;n,&#125;$ 4 m-n位的数字：^\d&#123;m,n&#125;$ 5 零和非零开头的数字：^(0|[1-9][0-9]*)$ 6 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]&#123;1,2&#125;)?$ 7 带1-2位小数的正数或负数：^(\-)?\d+(\.\d&#123;1,2&#125;)?$ 8 正数、负数、和小数：^(\-|\+)?\d+(\.\d+)?$ 9 有两位小数的正实数：^[0-9]+(.[0-9]&#123;2&#125;)?$10 有1~3位小数的正实数：^[0-9]+(.[0-9]&#123;1,3&#125;)?$11 非零的正整数：^[1-9]\d*$ 或 ^([1-9][0-9]*)&#123;1,3&#125;$ 或 ^\+?[1-9][0-9]*$12 非零的负整数：^\-[1-9][]0-9"*$ 或 ^-[1-9]\d*$13 非负整数：^\d+$ 或 ^[1-9]\d*|0$14 非正整数：^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$15 非负浮点数：^\d+(\.\d+)?$ 或 ^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$16 非正浮点数：^((-\d+(\.\d+)?)|(0+(\.0+)?))$ 或 ^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$17 正浮点数：^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$ 或 ^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$18 负浮点数：^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$ 或 ^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$19 浮点数：^(-?\d+)(\.\d+)?$ 或 ^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$ 二、校验字符的表达式123456789101112 1 汉字：^[\u4e00-\u9fa5]&#123;0,&#125;$ 2 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]&#123;4,40&#125;$ 3 长度为3-20的所有字符：^.&#123;3,20&#125;$ 4 由26个英文字母组成的字符串：^[A-Za-z]+$ 5 由26个大写英文字母组成的字符串：^[A-Z]+$ 6 由26个小写英文字母组成的字符串：^[a-z]+$ 7 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$ 8 由数字、26个英文字母或者下划线组成的字符串：^\w+$ 或 ^\w&#123;3,20&#125;$ 9 中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0-9_]+$10 中文、英文、数字但不包括下划线等符号：^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]&#123;2,20&#125;$11 可以输入含有^%&amp;',;=?$\"等字符：[^%&amp;',;=?$\x22]+12 禁止输入含有~的字符：[^~\x22]+ 三、特殊需求表达式1234567891011121314151617181920212223242526272829303132331 Email地址：^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$ 2 域名：[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(/.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+/.? 3 InternetURL：[a-zA-z]+://[^\s]* 或 ^http://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=]*)?$ 4 手机号码：^(13[0-9]|14[0-9]|15[0-9]|16[0-9]|17[0-9]|18[0-9]|19[0-9])\d&#123;8&#125;$ (由于工信部放号段不定时，所以建议使用泛解析 ^([1][3,4,5,6,7,8,9])\d&#123;9&#125;$) 5 电话号码("XXX-XXXXXXX"、"XXXX-XXXXXXXX"、"XXX-XXXXXXX"、"XXX-XXXXXXXX"、"XXXXXXX"和"XXXXXXXX)：^(\(\d&#123;3,4&#125;-)|\d&#123;3.4&#125;-)?\d&#123;7,8&#125;$ 6 国内电话号码(0511-4405222、021-87888822)：\d&#123;3&#125;-\d&#123;8&#125;|\d&#123;4&#125;-\d&#123;7&#125; 7 18位身份证号码(数字、字母x结尾)：^((\d&#123;18&#125;)|([0-9x]&#123;18&#125;)|([0-9X]&#123;18&#125;))$ 8 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$ 9 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w&#123;5,17&#125;$10 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).&#123;8,10&#125;$ 11 日期格式：^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;12 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$13 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ 14 钱的输入格式：15 1.有四种钱的表示形式我们可以接受:"10000.00" 和 "10,000.00", 和没有 "分" 的 "10000" 和 "10,000"：^[1-9][0-9]*$ 16 2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符"0"不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$ 17 3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ 18 4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ 19 5.必须说明的是,小数点后面至少应该有1位数,所以"10."是不通过的,但是 "10" 和 "10.2" 是通过的：^[0-9]+(.[0-9]&#123;2&#125;)?$ 20 6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]&#123;1,2&#125;)?$ 21 7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*(.[0-9]&#123;1,2&#125;)?$ 22 8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*)(.[0-9]&#123;1,2&#125;)?$ 23 备注：这就是最终结果了,别忘了"+"可以用"*"替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里24 xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$25 中文字符的正则表达式：[\u4e00-\u9fa5]26 双字节字符：[^\x00-\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))27 空白行的正则表达式：\n\s*\r (可以用来删除空白行)28 HTML标记的正则表达式：&lt;(\S*?)[^&gt;]*&gt;.*?&lt;/\1&gt;|&lt;.*? /&gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)29 首尾空白字符的正则表达式：^\s*|\s*$或(^\s*)|(\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)30 腾讯QQ号：[1-9][0-9]&#123;4,&#125; (腾讯QQ号从10000开始)31 中国邮政编码：[1-9]\d&#123;5&#125;(?!\d) (中国邮政编码为6位数字)32 IP地址：\d+\.\d+\.\d+\.\d+ (提取IP地址时有用)33 IP地址：((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.)&#123;3&#125;(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)) 参考文章：https://www.w3cschool.cn/javascript/js-regexp.htmlhttp://www.cnblogs.com/zxin/archive/2013/01/26/2877765.html]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaScript里的闭包到底是什么？该怎么理解？]]></title>
    <url>%2F2019%2F05%2F10%2FjavaScript%E9%87%8C%E7%9A%84%E9%97%AD%E5%8C%85%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E8%AF%A5%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[关于javaScript里的闭包问题，看了很多答案都不甚理解，在这里我谈谈我理解里的闭包。在理解闭包是什么之前我需要先理解什么是作用域。 全局作用域打开一个 js ，随便写了一行代码，这行代码所在的位置就会是全局作用域（global scope）。比如： 1var i =1;//全局作用域在代码任何位置都可以使用，一篇代码只有一个全局作用域 局部作用域全局作用域只有一个，在全局使用域里面定义的其它的作用域都被称为局部作用域（local scope）。局部作用域是由函数创建的，每个函数都会创建一个局部作用域。 123456789// 作用域 A: 全局作用域（位于函数外部）var nameA = "全局作用域"var a = function() &#123; // 作用域 B：局部作用域(在函数内部) // 这里是的局部作用域是由函数a创建的 var nameB = '局部作用域'&#125; 在这个局部作用域里面定义的东西，在这个作用域的外面是访问不到的。试一下： 12345678var nameA = "全局作用域"var a = function() &#123; var nameB = '局部作用域'&#125;console.log(nameA)// 返回：全局作用域console.log(nameB)//返回：undefined 闭包了解了作用域接下来我讲一讲闭包 定义维基百科：在计算机科学中，闭包（Closure），是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。所以，有另一种说法认为闭包是由函数和与其相关的引用环境组合而成的实体。 上面的定义看的有点懵，那我说说我的看法：在我看来，不是说能够访问到其他作用域的变量就是闭包，这是很笼统的。准确来说，闭包是基于正常的垃圾回收处理机制下的。也就是说，一般情况一个函数（函数作用域）执行完毕，里面声明的变量会全部释放，被垃圾回收器回收。但闭包利用一个技巧，让作用域里面的变量，在函数执行完之后依旧保存没有被垃圾回收处理掉。 还是有点懵？那贴上一段代码来看看： 12345678function fn(x) &#123; var a = 3; return function (y) &#123; alert(x + y + (++a)); &#125;&#125;var bar = fn(2); // bar 现在是一个闭包bar(10); 我们来看看这段代码，我们声明了一个函数fn，在到var bar = fn(2)开始执行函fn(2)，由于只传入一个参数2，所以执行到return function(y)这一行代码会停下等参数y传入，但是这个时候我们想想a变量和参数回收了吗？其实并没有，因为return function(y)这一行代码还未执行，还在等待参数y传入。f n的变量并没有被释放，在return在等待继续使用这些变量了，这个时候bar就是一个闭包。这时候在看看维基百科的解释是不是有些明白了？ 闭包的缺点 1 因为闭包的变量保存在内存中，内存泄漏，对内存的消耗很大，所以不要滥用闭包 闭包常用的地方： 1 es5 for循环事件监听 2 函数里使用了定时器 3 封装许多高级的功能集减少闭包使用可以用立即执行函数传递变量 参考：https://www.cnblogs.com/JIANGCHEN520/p/7118656.html]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[for和for in的区别]]></title>
    <url>%2F2019%2F05%2F10%2Ffor%E4%B8%8Efor%20in%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[从学习C语言开始就学习了遍历，for更是用的特别熟悉。在javascript中除了有for循环还有for in，刚开始接触for in的时候总是把他当for来使用。感觉没什么区别然而在最近写项目时遇到了这个for in才知悉了他与for的不同，果然还是实践出真知。下面先简单介绍一下for 和 for in吧： for的语法结构：1234567 for( 初始值;判断条件;步幅)&#123; code &#125; for( var i =0;i&lt;5;i++ )&#123; //i初始值为0；i是否小写5；每次循环后i加1 console.log(i);// 0 1 2 3 4 &#125; for in的写法：12345678910111213 var man = &#123; age:21, name:"张三", sex:"男"&#125;console.log(man);//结果：Object age: 21 name: "张三" sex: "男" __proto__: Object 1234for(var attr in man)&#123;//attr是属性，attr可以换成任意变量名 console.log(attr);// 输出的是 属性名：age name sex console.log(wq[attr]);//属性相对应的值 20 咸鱼 男&#125; 看到这里我相信有些人已经看明白了。不过我还是多嘴说一下吧，上面的for循环就是我们常用的方法用来遍历,十分简单的操作。而下面的for in呢？他一般时用来遍历对象的，在我的理解看来，for 循环可以遍历一个数组属于一维，而for in遍历对象，对象有多个属性，各个属性又有各自 的值相当于二位数组了。在上面的案例里面，想要获取对象的属性相应的值for是遍历不了的，这个时候for in就出场了。但使用for in的时候还要注意几个小问题： 而for in就不同了，上面的案例中，对象wq里有三个属性和相对应的值，想要获取到这三个属性及相对应的值for是办不到的，只有for in才可以，所以说，for in一般都是用在遍历对象的，另外，for in也可以遍历数组，但是会存在以下几个问题。 1、 for in这种循环i是string类型的，不能直接进行几何运算2、遍历顺序有可能不是按照实际数组的内部顺序3、使用for in会遍历数组所有的可枚举属性，包括原型。例如上栗的原型方法method和name属性4、简而言之，for-in是为普通对象设计的，你可以遍历得到字符串类型的键，因此不适用于数组遍历。 所以说for in也有他的局限性，因此遍历一般的数组用for比较好，遍历对象就需要for in了 最后附上一个小案例]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>for in</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax发送get_post请求的基本格式模板以及验证用户是否存在案例]]></title>
    <url>%2F2019%2F05%2F10%2FAjax%E5%8F%91%E9%80%81get_post%E8%AF%B7%E6%B1%82%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A0%BC%E5%BC%8F%E6%A8%A1%E6%9D%BF%E4%BB%A5%E5%8F%8A%E9%AA%8C%E8%AF%81%E7%94%A8%E6%88%B7%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E6%A1%88%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[Ajax发送get/post请求主要分为以下4步： 1.创建对象1var xhr = new XMLHttpRequest(); 2.设置请求行//（get请求数据写在url后面）open(&apos;method&apos;,&apos;url&apos;,&apos;async&apos;); /*method:请求的类型：GET或POST * url:文件在服务器上的位置 * async:true(异步)或false(同步),默认true * */ xhr.open(&apos;get&apos;,&apos;getData.php&apos;，true); 3.设置请求头//（get请求可以省略，post不发数据也可以省略） xhr.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;); 4.请求主体发送12//get请求为空，或者写null，post请求数据写在这里，如果没有数据，直接为空或者写null xhr.send(null); 为了方便理解，下面我贴一个验证用户是否存在的小案例： 前端部分代码12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;用户注册&lt;/h2&gt; &lt;input type="text" placeholder="请输入用户名"&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt; //什么时候发送请求？onblur:失去焦点 document.querySelector('input').onblur = function()&#123; //1.创建对象 var xhr = new XMLHttpRequest(); //2.设置请求行 xhr.open('get','checkName.php?name='+this.value); //3.设置请求头（此处用get请求可以省略） // xhr.setRequestHeader(); //这里是设置回调函数 xhr.onload = function () &#123; document.querySelector('h2').innerHTML = xhr.responseText;//呈现给用户看 &#125; //4.请求主体发送（get请求为空，或者写null） xhr.send(null); &#125;&lt;/script&gt; 后端部分代码12345678910111213&lt;?php//获取数据$name = $_GET['name'];//用数组模拟数据库$nameArr = array('jack','rose','nike');//在数据库中查询数据，in_array（要查询的数据名，在哪个数据库查询）$result = in_array($name,$nameArr);if($result == true)&#123; echo '很遗憾，已被使用';&#125;else&#123; echo '恭喜你，可以使用';&#125;?&gt; 查询前查询rose(数据库中存在)查询Tom(数据库中不存在)]]></content>
      <categories>
        <category>Ajax</category>
      </categories>
      <tags>
        <tag>_get_post</tag>
      </tags>
  </entry>
</search>
