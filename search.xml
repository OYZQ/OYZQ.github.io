<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[前端需要了解的JSON---数据读取与转化]]></title>
    <url>%2F2019%2F05%2F10%2F%E5%89%8D%E7%AB%AF%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84JSON---%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%8F%96%E4%B8%8E%E8%BD%AC%E5%8C%96%2F</url>
    <content type="text"><![CDATA[### 学习JSON之前我们需要明白的几点： 12345678/* * 1.json是一种数据的格式 * 2.json跟编程语言没有关系 * 3.json的载体是字符串 * 4.基本上所有的编程语言都支持JSON * 5.语言简洁 基本上所有的编程语言 都提供了对应的方法 来解析JSON * 6.JSON格式的字符串 转换完毕之后 会变成数组 对象 * */ json的写法 – 用来表示对象123456789//对象使用&#123;&#125; //属性名 必须使用""包裹 如果属性值是数值 可以不使用双引号 var JSONObject = '&#123;"name":"刘亦菲","skill":"失忆"&#125;'; console.log(JSONObject); //转化为 对应的 对象（数组） var obj = JSON.parse(JSONObject); console.log(obj); //读取对象属性值 console.log(obj.name+'|'+obj.skill); 结果： JSON的写法 – 用来表示数组1234567var JSONArr = '["绿色的花菜","大蒜","番茄","圣女果"]';console.log(JSONArr);//转化为对应的数组（对象）var arr = JSON.parse(JSONArr);console.log(arr);//读取数组中第三个元素console.log(arr[2]); 结果： JSON的写法 – 对象数组1234567var JSONObjArr = '&#123;"name":"彭林","skill":"约跑","friend":["周琳琳","林立群","....."]&#125;'; console.log(JSONObjArr); //转化为对应的对象数组 var result = JSON.parse(JSONObjArr); console.log(result); //读取对象数组元素 console.log(result.friend[1]); 结果：]]></content>
      <categories>
        <category>json</category>
      </categories>
      <tags>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剖析js原型与原型链]]></title>
    <url>%2F2019%2F05%2F10%2F%E5%89%96%E6%9E%90js%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[## 原型模式 &emsp;&emsp;我们创建的每一个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，而这这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。如果按字面意思来理解，那么prototype就是通过调用构造函数而创建的那个对象实例的原型对象。使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。换句话说，不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中，如下面的例子所示： 原型对象和实例的关系有点像JAVA中父类子类的关系，有些继承的味道。 12345678910111213141516function persion()&#123;&#125;persion.prototype.name = "Nicholas";persion.prototype.age = 29;persion.prototype.job = "Software Engineer";persion.prototype.sayName = function () &#123; alert(this.name);&#125;;var person1 = new persion();person1.sayName(); //"Nicholas"var person2 = new persion();person2.sayName(); //"Nicholas"alert(person1.sayName == person2.sayName); //"true" &emsp;&emsp;在此，我们将sayName（）方法和所有属性直接添加到了person的prototype属性中，构造函数变成了空函数。即使如此，也仍然可以通过调用构造函数来创建新对象，而且新对象还会具有相同的属性和方法。但与构造函数模式不同的是，新对象的这些属性和方法是由所有实例共享的。换句话说，person1和person2访问的都是同一组属性和同一个sayName（）函数。要理解原型模式的工作原理，必须先理解ECMAScript中原型对象的性质。 1.理解原型对象&emsp;&emsp;无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个prototype属性，这个属性指向函数的原型对象。在默认情况下，所有原型对象都会自动获得一个constructor（构造函数）属性，这个属性包含一个指向prototype属性所在函数的指针。就拿前面的例子来说，Person.prototype.constructor 指向person。而通过这个构造函数，我们还可继续为原型对象添加其他属性和方法。&emsp;&emsp;创建了自定义的构造函数之后，其原型对象默认只会取得 constructor属性；至于其他方法，则都是从object继承而来的。当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部属性），指向构造函数的原型对象。ECMA-262第5版中管这个指针叫[[Prototype]]。虽然在脚本中没有标准的方式访问[[Prototype]]，但Firefox、Safari和Chrome在每个对象上都支持一个属性proto；而在其他实现中，这个属性对脚本则是完全不可见的。不过，要明确的真正重要的一点就是，这个连接存在于实例与构造函数的原型对象之间，而不是存在于实例与构造函数之间。&emsp;&emsp;以前面使用Person构造函数和 Person.prototype创建实例的代码为例，图6-1展示了各个对象之间的关系。&emsp;&emsp;图6-1展示了person构造函数、person的原型属性以及person现有的两个实例之间的关系。在此，person.prototype 指向了原型对象，而Person.prototype.constructor又指回了Person。原型对象中除了包含constructor属性之外，还包括后来添加的其他属性。person的每个实例——person1和person2都包含一个内部属性，该属性仅仅指向了person.prototype；换句话说，它们与构造函数没有直接的关系。此外，要格外注意的是，虽然这两个实例都不包含属性和方法，但我们却可以调用person1.sayName（）。这是通过查找对象属性的过程来实现的。 这可以这么理解，构造函数是一个空函数。创建一个实例的代码虽然是构造函数new出来的，可实际上是通过原型对象创建出来的，实例与构造函数并没有直接的关系，实例是基于原型对象创建的，而原型对象的constructor指向构造函数。 &emsp;&emsp;虽然在所有实现中都无法访问到[[Prototype]]，但可以通过isPrototypeOf（）方法来确定对象之间是否存在这种关系。从本质上讲，如果[[Prototype]]指向调用isPrototypeof（）方法的对象（person.prototype），那么这个方法就返回true，如下所示： 12alert(Person.prototype.isPrototypeof(person1));//truealert(Person.prototype.isPrototypeof(person2));//true &emsp;&emsp;这里，我们用原型对象的isPrototypeof（）方法测试了person1和person2。因为它们内部都有一个指向Person.prototype的指针，因此都返回了true。&emsp;&emsp;ECMAScript5增加了一个新方法，叫object.getPrototypeof（），在所有支持的实现中，这个方法返回t[Prototype]]的值。例如： 12alert(Object.getPrototypeof(personl)==Person.prototype);//true alert(Object.getPrototypeof(person1). name);//"Nicholas" &emsp;&emsp;这里的第一行代码只是确定object.getPrototypeof（）返回的对象实际就是这个对象的原型。第二行代码取得了原型对象中name属性的值，也就是“Nicholas”。使用object.getPrototypeof（）可以方便地取得一个对象的原型，而这在利用原型实现继承（本章稍后会讨论）的情况下是非常重要的。支持这个方法的浏览器有IE9+、Firefox 3.5+、Safari 5+、Opera12+和Chrome。&emsp;&emsp;每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性。搜索首先从对象实例本身开始。如果在实例中找到了具有给定名字的属性，则返回该属性的值；如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性。如果在原型对象中找到了这个属性，则返回该属性的值。也就是说，在我们调用person1.sayName（）的时候，会先后执行两次搜索。首先，解析器会问：“实例 person1有sayName属性吗？”答：“没有。”然后，它继续搜索，再问：“person1的原型有sayName属性吗？”答：“有。”于是，它就读取那个保存在原型对象中的函数。当我们调用person2.sayName（）时，将会重现相同的搜索过程，得到相同的结果。而这正是多个对象实例共享原型所保存的属性和方法的基本原理。 搜索首先从对象实例本身开始。如果在实例中找到了具有给定名字的属性，则返回该属性的值；如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性。 &emsp;&emsp;虽然可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值。如果我们在实例中添加了一个属性，而该属性与实例原型中的一个属性同名，那我们就在实例中创建该属性，该属性将会屏蔽原型中的那个属性。来看下面的例子。 123456789101112function Person()&#123;Person. prototype. name="Nicholas"; Person. prototype. age=29; Person. prototype. job="Software Engineer"; Person. prototype, sayName=function()(alert(this. name);&#125;; var personl=new Person();var person2=new Person();peraonl.name =nGreg"；alert（person1.name）；//"Greg"—来自实例alert（person2.name）；//"Nicholaa"——来自原型 &emsp;&emsp;在这个例子中，person1的name 被一个新值给屏蔽了。但无论访问person1.name还是访问person2.name都能够正常地返回值，即分别是“Greg*（来自对象实例）和“wicholas”（来自原型）。当在alert（）中访问 person1.name时，需要读取它的值，因此就会在这个实例上搜索一个名为name的属性。这个属性确实存在，于是就返回它的值而不必再搜索原型了。当以同样的方式访问 person2.name时，并没有在实例上发现该属性，因此就会继续搜索原型，结果在那里找到了name-属性。&emsp;当为对象实例添加一个属性时，这个属性就会屏蔽原型对象中保存的同名属性；换句话说，添加这个属性只会阻止我们访问原型中的那个属性，但不会修改那个属性。即使将这个属性设置为nu11，也只会在实例中设置这个属性，而不会恢复其指向原型的连接。 可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值。如果实例中添加的属性与实例原型中一样则会断开该属性指向原型的连接 不过，使用delete 操作符则可以完全删除实例属性，从而让我们能够重新访问原型中的属性，如下所示。 123456789101112131415161718function Person()&#123;&#125;Person.prototype.name="Nicholas";Person.prototype.age=29;Person.prototype.job="Software Engineer";Person.prototype.sayName=function()&#123;alert（this.name）；&#125;;var personl=new Person();var pexson2=new Person();person1.name="Greg";alert(personl.name);//"Greg“——来自实例alert(person2.name);//"Nicholas“——来自原型delete personl.name;alert(peraonl.name);//"Nicholaa——来自原型 &emsp;&emsp;在这个修改后的例子中，我们使用delete操作符删除了person1.name，之前它保存的“Greg”值屏蔽了同名的原型属性。把它删除以后，就恢复了对原型中name属性的连接。因此，接下来再调用person1.name时，返回的就是原型中name属性的值了。 原型链&emsp;&emsp;ECMAScript中描述了原型链的概念，并将原型链作为实现继承的主要方法。其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。简单回顾一下构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。那么，假如我们让原型对象等于另一个类型的实例，结果会怎么样呢？显然，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立，如此层层递进，就构成了实例与原型的链条。这就是所谓原型链的基本概念。 可以简单理解成一个环套一个环和铁链一样。第一个环里的原型对象是第二个环里的实例，第二个环里的原型对象又是第三环里的实例则一环套一环。 &emsp;&emsp;实现原型链有一种基本模式，其代码大致如下。 123456789101112131415161718192021function SuperType()&#123;this. property=true;&#125;Superrype.prototype.get SuperValue=function（）&#123;return this.property;&#125;;function SubType（）&#123;this.subproperty=false;&#125;//继承了SuperType Subrype.prototype=newSuperlype（）;SubType.prototype.getSubValue=function（）&#123;return this.subproperty;）;var instance=new SubType（）;alert（instance.getSuperValue（））;//true &emsp;&emsp;以上代码定义了两个类型：Superrype和SubType。每个类型分别有一个属性和一个方法。它们的主要区别是Subrype继承了superrype，而继承是通过创建Superrype的实例，并将该实例赋给SubType.prototype实现的。实现的本质是重写原型对象，代之以一个新类型的实例。换句话说，原来存在于Superrype的实例中的所有属性和方法，现在也存在于Sublype.prototype中了。在确立了继承关系之后，我们给SubType.prototype 添加了一个方法，这样就在继承了SuperType的属性和方法的基础上又添加了一个新方法。这个例子中的实例以及构造函数和原型之间的关系如图6-4所示。&emsp;&emsp;在上面的代码中，我们没有使用Subype默认提供的原型，而是给它换了一个新原型；这个新原型就是superrype的实例。于是，新原型不仅具有作为一个Superrype的实例所拥有的全部属性和方法，而且其内部还有一个指针，指向了superrype的原型。最终结果就是这样的：instance指向 Subrype的原型，subrype的原型又指向Superrype的原型。getSupervalue（）方法仍然还在SuperType.prototype中，但property 则位于SubType.prototype中。这是因为property是一个实例属性，而 getSuperValue（）则是一个原型方法。既然 SubType.prototype 现在是Superrype的实例，那么property当然就位于该实例中了。此外，要注意instance.constructor现在指向的是Supertype，这是因为原来subrype.prototype中的 constructor被重写了的缘故。&emsp;&emsp;通过实现原型链，本质上扩展了本章前面介绍的原型搜索机制。读者大概还记得，当以读取模式访问一个实例属性时，首先会在实例中搜索该属性。如果没有找到该属性，则会继续搜索实例的原型。在通过原型链实现继承的情况下，搜索过程就得以沿着原型链继续向上。就拿上面的例子来说，调用instance.getSuperValue（）会经历三个搜索步骤：1）搜索实例；2）搜索Subrype.prototype；3）搜索SuperType.prototype，最后一步才会找到该方法。在找不到属性或方法的情况下，搜索过程总是要一环一环地前行到原型链末端才会停下来。 参考书籍：JavaScript高级程序设计（第三版）]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>原型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[匿名函数、自执行函数，自执行匿名函数和立即执行的函数表达式区别]]></title>
    <url>%2F2019%2F05%2F10%2F%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E3%80%81%E8%87%AA%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0%EF%BC%8C%E8%87%AA%E6%89%A7%E8%A1%8C%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E5%92%8C%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E7%9A%84%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[## 匿名函数、自执行函数，自执行匿名函数和立即执行的函数表达式区别 今天在写代码的时候发现对自执行函数有点懵，便去查询资料。然后紧接着自执行匿名函数，立即执行函数，匿名函数一窝蜂的出来了，借此就好好谈谈这几个函数的区别吧。 匿名函数匿名函数比较好理解，顾名思义就是没有名字的函数 12345678//普通函数:此函数声明了一个名为a的函数。 function a()&#123; return 1; &#125;;//匿名函数:这时你会发现报错了function()&#123; return 1;&#125;; 这时你会发现单独运行一个匿名函数，由于不符合语法要求，会报错。解决方法：只需要用（）把匿名函数包起来即可 123（function()&#123; return 1;&#125;;） 自执行函数，立即执行的函数在介绍这里之前，我们先聊一聊”自执行”这个说法，关于”自执行“每个人理解不一样，有人称他为：自动执行，也有称作：立即调用，在这里我比较认同另一种说法:立即调用的函数表达式。 什么是自执行？ 我们创建了一个匿名的函数，并立即执行它，由于外部无法引用它内部的变量，因此在执行完后很快就会被释放，关键是这种机制不会污染全局对象。 自执行函数，即定义和调用合为一体。 1234567//对于函数表达式，在后面加括号即可以让函数立即执行；例如下面这个函数，至于为什么加了括号就可以立即执行，我们可以这么理解，就是像f()；这样写的话，函数 可以立即执行是没问题的，我们在经常会用到，那么对于函数表达式来说，fn1就是对后面的匿名函数的一个引用，因此在后面的匿名函数后直接加括号，自然也就可以立即执行 var f = function()&#123; console.log("ss"); &#125;(); 自执行函数的其他几种写法我个人推荐第一种写法，好处是，能提醒阅读代码的人，这段代码是一个整体。 1234567891011121314151617//方法1：最前最后加括号(function()&#123; alert(1);&#125;());//方法2：function外面加括号(function()&#123; alert(1);&#125;)();方法3：function前面加运算符，常见的是!与void 。!function()&#123; alert(1);&#125;();void function()&#123; alert(2);&#125;(); 在参考了多个网站总算将这些理念弄清楚一些。 参考网址： http://www.cnblogs.com/TomXu/archive/2011/12/31/2289423.html https://www.cnblogs.com/jessiespur/p/9283101.html https://www.jianshu.com/p/1d52ed86d52c]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>匿名函数 自执行函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基本类型和引用类型的区别以及在内存中的分配]]></title>
    <url>%2F2019%2F05%2F10%2F%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%88%86%E9%85%8D%2F</url>
    <content type="text"><![CDATA[ECMAScript变量可能包含两种不同数据类型的值：基本类型值和引用类型值。基本类型值指的是简单的数据段，而引用类型值指那些可能由多个值构成的对象。 主要区别 基本数据类型 引用数据类型 &lt; 在栈中进行分配 在堆中进行分配 变量名指向具体的数值 变量名指向存数据对象的内存地址,即变量名指向hash值 变量在声明之后java就会立刻分配给他内存空间 它以特殊的方式(类似C指针)指向对象实体（具体的值），这类变量声明时不会分配内存，只是存储了一个内存地址 基本类型之间的赋值是创建新的拷贝 对象之间的赋值只是传递引用 “==”和“!=”是在比较值 “==”和“!=”是在比较两个引用是否相同，需要自己实现equals()方法 基本类型变量创建和销毁很快 类对象需要JVM去销毁 动态的属性定义基本类型值和引用类型值的方法时类似的：创建一个变量并为该变量赋值。但是对于不同类型值可以执行的操作就不一样了。 引用类型值我们可以为其添加属性和方法，也可以改变和删除其属性和方法。请看下面的例子： 123var person = new Object();person.name = "Nicholas";//添加属性并且赋值alert(person.name);//输出Nicholas 上面代码创建了一个对象并将其保存在了变量person中。然后为对象添加了一个名为name的属性并且将字符串“Nicholas”赋给了这个属性。 基本类型值我们不能给基本类型的值添加属性，尽管这样做并不会出错。例如： 123var name = "Nicholas";name.age = 27;alert(name.age); //得到：undefind 在这个例子中，我们为字符串name定义了一个名为age的属性，并且赋值27。但在下面使用alert访问这个属性的时候，发现该属性不存在。这说明基本类型不能动态的添加属性。 复制变量值除了保存方式不同之外，在从一个变量向另一个变量复制基本类型和引用类型值时，也存在不同。 基本类型值如果从一个变量向另一个变量复制基本类型的值，会在变量对象上创建一个新值。然后把改制复制到新变量分配的位置上。看一个小例子： 12var num1 = 5;var num2 = num1; 在此，num1中保存的值时5.当使用num1的值来初始化num2时，num2中也保存了值5.但num2中的5与num1中 的5 是完全独立的。该值只是num1中5的一个副本。这两个变量可以参与任何操作而不会相会影响。 引用类型值当从一个变量向另一个变量复制引用类型的值时，同样也会将存储在变量对象中的值复制一份放到为新变量分配的空间中。不同的是，这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一个对象。复制操作以后，这两个变量实际上将引用同一个对象。因此，改变其中一个变量，就会影响另一个变量。如下面的例子所示： 1234var obj1 = new object();var obj2 = obj1;obj1.name = "Nicholaa";alert(obj2.name);//输出“Nicholas” 首先，变量obj1保存了一个对象的新实例。然后，这个值被复制到了obj2中；换句话说，obj1和obj2都指向同一个对象。这样，当为obj1添加属性name后，可以通过obj2来访问这个属性，因为这两个变量引用都是同一个对象。具体关系可以看下图：参考文献：JavaScript高级程序设计（第3版）]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>基本类型和引用类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中的回调函数callback]]></title>
    <url>%2F2019%2F05%2F10%2FJavaScript%E4%B8%AD%E7%9A%84%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0callback%2F</url>
    <content type="text"><![CDATA[## 解释 A callback is a function that is passed as an argument to another function and is executed after its parent function has completed. 以上callback的英文解释，非常清晰简明，有时候英文理解要比翻译成中文二次理解更清楚。大概意思是：回调是一个函数，它作为参数传递给另一个函数，并在其父函数完成后执行。其实函数也是一种数据类型，既可以当作参数进行传递，也可以当作方法的返回值传递 先明白异步和同步想要理解清楚callback还是需要先把异步async/同步sync概念弄清楚。先写一个异步小例子： 12345678910111213141516function a()&#123; console.log('我是函数a开头') setTimeout(function () &#123; console.log('我是setTimeout') &#125;,1000) console.log('我是函数a结尾')&#125;function b()&#123; console.log('我是函数b')&#125;a()b() 执行结果： 从执行结果可以看出来执行顺序是之上而下执行下来，但setTimeout函数被放在了最后执行。这是一个异步操作，执行的时候并不会等待setTimeout而直接向下执行，等到所有任务执行完成在回过头来执行setTimeout函数。即使setTimeout第二个参数是0也会最后执行，setTimeout第二个参数的数字是表示执行最快时间不是一个确定时间。 理解&emsp;&emsp;回调函数字面上理解下来就是，回调就是一个函数的调用过程。函数a有一个参数，这个参数是个函数b，当函数a执行完以后执行函数b。那么这个过程就叫回调。字面意思也很好理解：回调，回调，就是回头调用的意思。函数a的事先干完，回头再调用函数b。&emsp;&emsp;需要注意的是：所以回调与同步、异步并没有直接的联系，回调只是一种实现方式，既可以有同步回调，也可以有异步回调，还可以有事件处理回调和延迟函数回调，这些在我们工作中有很多的使用场景&emsp;&emsp;所以其实并不是我们不认识回调函数，而是我们都萦绕在了这个“callback“ 这个词上，当你在一个函数中看到它是就会困惑，其实它只是一个形参名字而已。 回调函数其实我们平时都使用过，来看看下面几个经典的： ajax中的回调函数： 点击事件的回调函数： 数组中遍历的回调函数： 作用大多数情况下，callback是用来拿到函数中的数据，这牵扯到闭包的概念，可以看这篇文章：javaScript里的闭包到底是什么？该怎么理解？ 就以Ajax的封装为例吧： 1234567var oReq = new XMLHttpRequest() oReq.onload = function () &#123; console.log(oReq.responseText) &#125; oReq.open("get",url,true) oReq.send() 上面的是为封装的Ajax，我们请求到的数据responseText只能在onload中拿到，想要拿数据进行下一步操作也只能在onload函数中进行。但我们如果要封装给其他人使用，我们并不知道使用者需要拿这数据干什么，因此我们需要把responseText传递出去，这时候就需要使用callback。 1234567891011121314 function get(url,callback)&#123; var oReq = new XMLHttpRequest() oReq.onload = function () &#123;// console.log(oReq.responseText) callback(oReq.responseText) &#125; oReq.open("get",url,true) oReq.send() &#125; get('data.json', function (data) &#123; console.log(data) &#125;) 上面这是封装以后的代码，我们通过callback把responseText传递出去,get方法的第二个参数就是回调函数callback，而data就是callback函数传递出来的responseText数据，通过回调函数拿到数据，使用者需要拿数据干什么都行了。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>callback</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[定时调用和延时调用用法及区别]]></title>
    <url>%2F2019%2F05%2F10%2F%E5%AE%9A%E6%97%B6%E8%B0%83%E7%94%A8%E5%92%8C%E5%BB%B6%E6%97%B6%E8%B0%83%E7%94%A8%E7%94%A8%E6%B3%95%E5%8F%8A%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[定时调用setlnterval()定义和用法setInterval() 方法可按照指定的周期（以毫秒计）来调用函数或计算表达式。 setInterval() 方法会不停地调用函数，直到 clearInterval() 被调用或窗口被关闭。由 setInterval() 返回的 ID 值可用作 clearInterval() 方法的参数。 语法setInterval(code,millisec) 参数 1、code（必需）：回调函数， 每隔一段时间要执行一次的函数 2、millisec（必需）：每次调用间隔时间，单位是ms 返回值 一个可以传递给 Window.clearInterval() 从而取消对 code 的周期性执行的值。 实例 12//每隔6000毫秒执行一次testFunction()函数，执行无数次。setInterval("testFunction()","6000"); 延时调用setTimeout()定义和用法setTimeout() 方法用于在指定的毫秒数后调用函数或计算表达式。 语法setTimeout(code,millisec) 参数 1、回调函数， 需要隔一定时间后执行的函数 2、每次调用间隔时间，单位是ms 提示和注释 提示：setTimeout() 只执行 code 一次。如果要多次调用，请使用 setInterval() 或者让 code 自身再次调用 setTimeout()。 实例 12//每隔6000毫秒执行一次testFunction()函数，执行无数次。setTimeout("testFunction()","6000"); 小案例]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>定时调用和延时调用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaScript正则表达式（内附最全的常用正则表达式）]]></title>
    <url>%2F2019%2F05%2F10%2FjavaScript%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E5%86%85%E9%99%84%E6%9C%80%E5%85%A8%E7%9A%84%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[### JavaScript 正则表达式 正则表达式（英语：Regular Expression，在代码中常简写为regex、regexp或RE）使用单个字符串来描述、匹配一系列符合某个句法规则的字符串搜索模式。 搜索模式可用于文本搜索和文本替换。 什么是正则表达式？正则表达式是由一个字符序列形成的搜索模式。当你在文本中搜索数据时，你可以用搜索模式来描述你要查询的内容。正则表达式可以是一个简单的字符，或一个更复杂的模式。正则表达式可用于所有文本搜索和文本替换的操作。 语法1/pattern/modifiers; 实例1var patt = /hello/i 实例解析： /hello/i 是一个正则表达式。hello 是一个模式 (用于检索匹配关键字)。i 是一个修饰符 (搜索不区分大小写)。 使用字符串方法 在 JavaScript 中，正则表达式通常用于两个字符串方法 : search() 和 replace()。 search() 方法 用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串，并返回子字符串的起始位置。 replace() 方法 用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子字符串。 search() 方法使用使用正则表达式搜索 “make” 字符串，且不区分大小写： 123var str = "Visit make";var n = str.search(/make/i);//结果：6 search 方法可使用字符串作为参数。字符串参数会转换为正则表达式： 123var str = "Visit make";var n = str.search("make");//结果：6 replace() 方法使用使用正则表达式且不区分大小写将字符串中的 Microsoft 替换为 make : 123var str = "Visit Microsoft!";var res = str.replace(/microsoft/i, "make");//结果：Visit make! replace() 方法将接收字符串作为参数： 12var str = "Visit Microsoft!";var res = str.replace("Microsoft", "make"); 正则表达式修饰符修饰符 可以在全局搜索中不区分大小写:正则表达式模式 方括号用于查找某个范围内的字符： 常用正则表达式一、校验数字的表达式12345678910111213141516171819 1 数字：^[0-9]*$ 2 n位的数字：^\d&#123;n&#125;$ 3 至少n位的数字：^\d&#123;n,&#125;$ 4 m-n位的数字：^\d&#123;m,n&#125;$ 5 零和非零开头的数字：^(0|[1-9][0-9]*)$ 6 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]&#123;1,2&#125;)?$ 7 带1-2位小数的正数或负数：^(\-)?\d+(\.\d&#123;1,2&#125;)?$ 8 正数、负数、和小数：^(\-|\+)?\d+(\.\d+)?$ 9 有两位小数的正实数：^[0-9]+(.[0-9]&#123;2&#125;)?$10 有1~3位小数的正实数：^[0-9]+(.[0-9]&#123;1,3&#125;)?$11 非零的正整数：^[1-9]\d*$ 或 ^([1-9][0-9]*)&#123;1,3&#125;$ 或 ^\+?[1-9][0-9]*$12 非零的负整数：^\-[1-9][]0-9"*$ 或 ^-[1-9]\d*$13 非负整数：^\d+$ 或 ^[1-9]\d*|0$14 非正整数：^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$15 非负浮点数：^\d+(\.\d+)?$ 或 ^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$16 非正浮点数：^((-\d+(\.\d+)?)|(0+(\.0+)?))$ 或 ^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$17 正浮点数：^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$ 或 ^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$18 负浮点数：^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$ 或 ^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$19 浮点数：^(-?\d+)(\.\d+)?$ 或 ^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$ 二、校验字符的表达式123456789101112 1 汉字：^[\u4e00-\u9fa5]&#123;0,&#125;$ 2 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]&#123;4,40&#125;$ 3 长度为3-20的所有字符：^.&#123;3,20&#125;$ 4 由26个英文字母组成的字符串：^[A-Za-z]+$ 5 由26个大写英文字母组成的字符串：^[A-Z]+$ 6 由26个小写英文字母组成的字符串：^[a-z]+$ 7 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$ 8 由数字、26个英文字母或者下划线组成的字符串：^\w+$ 或 ^\w&#123;3,20&#125;$ 9 中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0-9_]+$10 中文、英文、数字但不包括下划线等符号：^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]&#123;2,20&#125;$11 可以输入含有^%&amp;',;=?$\"等字符：[^%&amp;',;=?$\x22]+12 禁止输入含有~的字符：[^~\x22]+ 三、特殊需求表达式1234567891011121314151617181920212223242526272829303132331 Email地址：^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$ 2 域名：[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(/.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+/.? 3 InternetURL：[a-zA-z]+://[^\s]* 或 ^http://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=]*)?$ 4 手机号码：^(13[0-9]|14[0-9]|15[0-9]|16[0-9]|17[0-9]|18[0-9]|19[0-9])\d&#123;8&#125;$ (由于工信部放号段不定时，所以建议使用泛解析 ^([1][3,4,5,6,7,8,9])\d&#123;9&#125;$) 5 电话号码("XXX-XXXXXXX"、"XXXX-XXXXXXXX"、"XXX-XXXXXXX"、"XXX-XXXXXXXX"、"XXXXXXX"和"XXXXXXXX)：^(\(\d&#123;3,4&#125;-)|\d&#123;3.4&#125;-)?\d&#123;7,8&#125;$ 6 国内电话号码(0511-4405222、021-87888822)：\d&#123;3&#125;-\d&#123;8&#125;|\d&#123;4&#125;-\d&#123;7&#125; 7 18位身份证号码(数字、字母x结尾)：^((\d&#123;18&#125;)|([0-9x]&#123;18&#125;)|([0-9X]&#123;18&#125;))$ 8 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$ 9 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w&#123;5,17&#125;$10 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).&#123;8,10&#125;$ 11 日期格式：^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;12 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$13 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ 14 钱的输入格式：15 1.有四种钱的表示形式我们可以接受:"10000.00" 和 "10,000.00", 和没有 "分" 的 "10000" 和 "10,000"：^[1-9][0-9]*$ 16 2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符"0"不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$ 17 3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ 18 4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ 19 5.必须说明的是,小数点后面至少应该有1位数,所以"10."是不通过的,但是 "10" 和 "10.2" 是通过的：^[0-9]+(.[0-9]&#123;2&#125;)?$ 20 6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]&#123;1,2&#125;)?$ 21 7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*(.[0-9]&#123;1,2&#125;)?$ 22 8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*)(.[0-9]&#123;1,2&#125;)?$ 23 备注：这就是最终结果了,别忘了"+"可以用"*"替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里24 xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$25 中文字符的正则表达式：[\u4e00-\u9fa5]26 双字节字符：[^\x00-\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))27 空白行的正则表达式：\n\s*\r (可以用来删除空白行)28 HTML标记的正则表达式：&lt;(\S*?)[^&gt;]*&gt;.*?&lt;/\1&gt;|&lt;.*? /&gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)29 首尾空白字符的正则表达式：^\s*|\s*$或(^\s*)|(\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)30 腾讯QQ号：[1-9][0-9]&#123;4,&#125; (腾讯QQ号从10000开始)31 中国邮政编码：[1-9]\d&#123;5&#125;(?!\d) (中国邮政编码为6位数字)32 IP地址：\d+\.\d+\.\d+\.\d+ (提取IP地址时有用)33 IP地址：((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.)&#123;3&#125;(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)) 参考文章：https://www.w3cschool.cn/javascript/js-regexp.htmlhttp://www.cnblogs.com/zxin/archive/2013/01/26/2877765.html]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaScript里的闭包到底是什么？该怎么理解？]]></title>
    <url>%2F2019%2F05%2F10%2FjavaScript%E9%87%8C%E7%9A%84%E9%97%AD%E5%8C%85%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E8%AF%A5%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[关于javaScript里的闭包问题，看了很多答案都不甚理解，在这里我谈谈我理解里的闭包。在理解闭包是什么之前我需要先理解什么是作用域。 全局作用域打开一个 js ，随便写了一行代码，这行代码所在的位置就会是全局作用域（global scope）。比如： 1var i =1;//全局作用域在代码任何位置都可以使用，一篇代码只有一个全局作用域 局部作用域全局作用域只有一个，在全局使用域里面定义的其它的作用域都被称为局部作用域（local scope）。局部作用域是由函数创建的，每个函数都会创建一个局部作用域。 123456789// 作用域 A: 全局作用域（位于函数外部）var nameA = "全局作用域"var a = function() &#123; // 作用域 B：局部作用域(在函数内部) // 这里是的局部作用域是由函数a创建的 var nameB = '局部作用域'&#125; 在这个局部作用域里面定义的东西，在这个作用域的外面是访问不到的。试一下： 12345678var nameA = "全局作用域"var a = function() &#123; var nameB = '局部作用域'&#125;console.log(nameA)// 返回：全局作用域console.log(nameB)//返回：undefined 闭包了解了作用域接下来我讲一讲闭包 定义维基百科：在计算机科学中，闭包（Closure），是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。所以，有另一种说法认为闭包是由函数和与其相关的引用环境组合而成的实体。 上面的定义看的有点懵，那我说说我的看法：在我看来，不是说能够访问到其他作用域的变量就是闭包，这是很笼统的。准确来说，闭包是基于正常的垃圾回收处理机制下的。也就是说，一般情况一个函数（函数作用域）执行完毕，里面声明的变量会全部释放，被垃圾回收器回收。但闭包利用一个技巧，让作用域里面的变量，在函数执行完之后依旧保存没有被垃圾回收处理掉。 还是有点懵？那贴上一段代码来看看： 12345678function fn(x) &#123; var a = 3; return function (y) &#123; alert(x + y + (++a)); &#125;&#125;var bar = fn(2); // bar 现在是一个闭包bar(10); 我们来看看这段代码，我们声明了一个函数fn，在到var bar = fn(2)开始执行函fn(2)，由于只传入一个参数2，所以执行到return function(y)这一行代码会停下等参数y传入，但是这个时候我们想想a变量和参数回收了吗？其实并没有，因为return function(y)这一行代码还未执行，还在等待参数y传入。f n的变量并没有被释放，在return在等待继续使用这些变量了，这个时候bar就是一个闭包。这时候在看看维基百科的解释是不是有些明白了？ 闭包的缺点 1 因为闭包的变量保存在内存中，内存泄漏，对内存的消耗很大，所以不要滥用闭包 闭包常用的地方： 1 es5 for循环事件监听 2 函数里使用了定时器 3 封装许多高级的功能集减少闭包使用可以用立即执行函数传递变量 参考：https://www.cnblogs.com/JIANGCHEN520/p/7118656.html]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[for和for in的区别]]></title>
    <url>%2F2019%2F05%2F10%2Ffor%E4%B8%8Efor%20in%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[从学习C语言开始就学习了遍历，for更是用的特别熟悉。在javascript中除了有for循环还有for in，刚开始接触for in的时候总是把他当for来使用。感觉没什么区别然而在最近写项目时遇到了这个for in才知悉了他与for的不同，果然还是实践出真知。下面先简单介绍一下for 和 for in吧： for的语法结构：1234567 for( 初始值;判断条件;步幅)&#123; code &#125; for( var i =0;i&lt;5;i++ )&#123; //i初始值为0；i是否小写5；每次循环后i加1 console.log(i);// 0 1 2 3 4 &#125; for in的写法：12345678910111213 var man = &#123; age:21, name:"张三", sex:"男"&#125;console.log(man);//结果：Object age: 21 name: "张三" sex: "男" __proto__: Object 1234for(var attr in man)&#123;//attr是属性，attr可以换成任意变量名 console.log(attr);// 输出的是 属性名：age name sex console.log(wq[attr]);//属性相对应的值 20 咸鱼 男&#125; 看到这里我相信有些人已经看明白了。不过我还是多嘴说一下吧，上面的for循环就是我们常用的方法用来遍历,十分简单的操作。而下面的for in呢？他一般时用来遍历对象的，在我的理解看来，for 循环可以遍历一个数组属于一维，而for in遍历对象，对象有多个属性，各个属性又有各自 的值相当于二位数组了。在上面的案例里面，想要获取对象的属性相应的值for是遍历不了的，这个时候for in就出场了。但使用for in的时候还要注意几个小问题： 而for in就不同了，上面的案例中，对象wq里有三个属性和相对应的值，想要获取到这三个属性及相对应的值for是办不到的，只有for in才可以，所以说，for in一般都是用在遍历对象的，另外，for in也可以遍历数组，但是会存在以下几个问题。 1、 for in这种循环i是string类型的，不能直接进行几何运算2、遍历顺序有可能不是按照实际数组的内部顺序3、使用for in会遍历数组所有的可枚举属性，包括原型。例如上栗的原型方法method和name属性4、简而言之，for-in是为普通对象设计的，你可以遍历得到字符串类型的键，因此不适用于数组遍历。 所以说for in也有他的局限性，因此遍历一般的数组用for比较好，遍历对象就需要for in了 最后附上一个小案例]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>for in</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax发送get_post请求的基本格式模板以及验证用户是否存在案例]]></title>
    <url>%2F2019%2F05%2F10%2FAjax%E5%8F%91%E9%80%81get_post%E8%AF%B7%E6%B1%82%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A0%BC%E5%BC%8F%E6%A8%A1%E6%9D%BF%E4%BB%A5%E5%8F%8A%E9%AA%8C%E8%AF%81%E7%94%A8%E6%88%B7%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E6%A1%88%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[Ajax发送get/post请求主要分为以下4步： 1.创建对象1var xhr = new XMLHttpRequest(); 2.设置请求行//（get请求数据写在url后面）open(&apos;method&apos;,&apos;url&apos;,&apos;async&apos;); /*method:请求的类型：GET或POST * url:文件在服务器上的位置 * async:true(异步)或false(同步),默认true * */ xhr.open(&apos;get&apos;,&apos;getData.php&apos;，true); 3.设置请求头//（get请求可以省略，post不发数据也可以省略） xhr.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;); 4.请求主体发送12//get请求为空，或者写null，post请求数据写在这里，如果没有数据，直接为空或者写null xhr.send(null); 为了方便理解，下面我贴一个验证用户是否存在的小案例： 前端部分代码12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;用户注册&lt;/h2&gt; &lt;input type="text" placeholder="请输入用户名"&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt; //什么时候发送请求？onblur:失去焦点 document.querySelector('input').onblur = function()&#123; //1.创建对象 var xhr = new XMLHttpRequest(); //2.设置请求行 xhr.open('get','checkName.php?name='+this.value); //3.设置请求头（此处用get请求可以省略） // xhr.setRequestHeader(); //这里是设置回调函数 xhr.onload = function () &#123; document.querySelector('h2').innerHTML = xhr.responseText;//呈现给用户看 &#125; //4.请求主体发送（get请求为空，或者写null） xhr.send(null); &#125;&lt;/script&gt; 后端部分代码12345678910111213&lt;?php//获取数据$name = $_GET['name'];//用数组模拟数据库$nameArr = array('jack','rose','nike');//在数据库中查询数据，in_array（要查询的数据名，在哪个数据库查询）$result = in_array($name,$nameArr);if($result == true)&#123; echo '很遗憾，已被使用';&#125;else&#123; echo '恭喜你，可以使用';&#125;?&gt; 查询前查询rose(数据库中存在)查询Tom(数据库中不存在)]]></content>
      <categories>
        <category>Ajax</category>
      </categories>
      <tags>
        <tag>_get_post</tag>
      </tags>
  </entry>
</search>
