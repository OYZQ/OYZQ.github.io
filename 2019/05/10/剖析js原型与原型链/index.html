<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>剖析js原型与原型链 | OuYang'blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">剖析js原型与原型链</h1><a id="logo" href="/.">OuYang'blog</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">剖析js原型与原型链</h1><div class="post-meta">May 10, 2019<span> | </span><span class="category"><a href="/categories/js/">js</a></span></div><div class="post-content"><p>﻿## 原型模式</p>
<p>&emsp;&emsp;我们创建的每一个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，而这这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。如果按字面意思来理解，那么prototype就是通过调用构造函数而创建的那个对象实例的原型对象。使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。换句话说，不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中，如下面的例子所示：</p>
<blockquote>
<p>原型对象和实例的关系有点像JAVA中父类子类的关系，有些继承的味道。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">persion</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">persion.prototype.name = <span class="string">"Nicholas"</span>;</span><br><span class="line">persion.prototype.age = <span class="number">29</span>;</span><br><span class="line">persion.prototype.job = <span class="string">"Software Engineer"</span>;</span><br><span class="line">persion.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> persion();</span><br><span class="line">person1.sayName(); <span class="comment">//"Nicholas"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> persion();</span><br><span class="line">person2.sayName(); <span class="comment">//"Nicholas"</span></span><br><span class="line">alert(person1.sayName == person2.sayName); <span class="comment">//"true"</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在此，我们将sayName（）方法和所有属性直接添加到了person的prototype属性中，构造函数变成了空函数。即使如此，也仍然可以通过调用构造函数来创建新对象，而且新对象还会具有相同的属性和方法。但与构造函数模式不同的是，新对象的这些属性和方法是由所有实例共享的。换句话说，person1和person2访问的都是同一组属性和同一个sayName（）函数。要理解原型模式的工作原理，必须先理解ECMAScript中原型对象的性质。</p>
<h3 id="1-理解原型对象"><a href="#1-理解原型对象" class="headerlink" title="1.理解原型对象"></a>1.理解原型对象</h3><p>&emsp;&emsp;无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个prototype属性，这个属性指向函数的原型对象。在默认情况下，所有原型对象都会自动获得一个constructor（构造函数）属性，这个属性包含一个指向prototype属性所在函数的指针。就拿前面的例子来说，Person.prototype.constructor 指向person。而通过这个构造函数，我们还可继续为原型对象添加其他属性和方法。<br>&emsp;&emsp;创建了自定义的构造函数之后，其原型对象默认只会取得 constructor属性；至于其他方法，则都是从object继承而来的。当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部属性），指向构造函数的原型对象。ECMA-262第5版中管这个指针叫[[Prototype]]。虽然在脚本中没有标准的方式访问[[Prototype]]，但Firefox、Safari和Chrome在每个对象上都支持一个属性proto；而在其他实现中，这个属性对脚本则是完全不可见的。不过，要明确的真正重要的一点就是，这个连接存在于实例与构造函数的原型对象之间，而不是存在于实例与构造函数之间。<br>&emsp;&emsp;以前面使用Person构造函数和 Person.prototype创建实例的代码为例，图6-1展示了各个对象之间的关系。<br><img src="https://img-blog.csdnimg.cn/20190420200006450.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDY4NTUw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">&emsp;&emsp;图6-1展示了person构造函数、person的原型属性以及person现有的两个实例之间的关系。在此，person.prototype 指向了原型对象，而Person.prototype.constructor又指回了Person。原型对象中除了包含constructor属性之外，还包括后来添加的其他属性。person的每个实例——person1和person2都包含一个内部属性，该属性仅仅指向了person.prototype；换句话说，它们与构造函数没有直接的关系。此外，要格外注意的是，虽然这两个实例都不包含属性和方法，但我们却可以调用person1.sayName（）。这是通过查找对象属性的过程来实现的。</p>
<blockquote>
<p>这可以这么理解，构造函数是一个空函数。创建一个实例的代码虽然是构造函数new出来的，可实际上是通过原型对象创建出来的，实例与构造函数并没有直接的关系，实例是基于原型对象创建的，而原型对象的constructor指向构造函数。</p>
</blockquote>
<p>&emsp;&emsp;虽然在所有实现中都无法访问到[[Prototype]]，但可以通过isPrototypeOf（）方法来确定对象之间是否存在这种关系。从本质上讲，如果[[Prototype]]指向调用isPrototypeof（）方法的对象（person.prototype），那么这个方法就返回true，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alert(Person.prototype.isPrototypeof(person1));<span class="comment">//true</span></span><br><span class="line">alert(Person.prototype.isPrototypeof(person2));<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这里，我们用原型对象的isPrototypeof（）方法测试了person1和person2。因为它们内部都有一个指向Person.prototype的指针，因此都返回了true。<br>&emsp;&emsp;ECMAScript5增加了一个新方法，叫object.getPrototypeof（），在所有支持的实现中，这个方法返回t[Prototype]]的值。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="built_in">Object</span>.getPrototypeof(personl)==Person.prototype);<span class="comment">//true </span></span><br><span class="line">alert(<span class="built_in">Object</span>.getPrototypeof(person1). name);<span class="comment">//"Nicholas"</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这里的第一行代码只是确定object.getPrototypeof（）返回的对象实际就是这个对象的原型。第二行代码取得了原型对象中name属性的值，也就是“Nicholas”。使用object.getPrototypeof（）可以方便地取得一个对象的原型，而这在利用原型实现继承（本章稍后会讨论）的情况下是非常重要的。支持这个方法的浏览器有IE9+、Firefox 3.5+、Safari 5+、Opera12+和Chrome。<br>&emsp;&emsp;每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性。搜索首先从对象实例本身开始。如果在实例中找到了具有给定名字的属性，则返回该属性的值；如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性。如果在原型对象中找到了这个属性，则返回该属性的值。也就是说，在我们调用person1.sayName（）的时候，会先后执行两次搜索。首先，解析器会问：“实例 person1有sayName属性吗？”答：“没有。”然后，它继续搜索，再问：“person1的原型有sayName属性吗？”答：“有。”于是，它就读取那个保存在原型对象中的函数。当我们调用person2.sayName（）时，将会重现相同的搜索过程，得到相同的结果。而这正是多个对象实例共享原型所保存的属性和方法的基本原理。</p>
<blockquote>
<p>搜索首先从对象实例本身开始。如果在实例中找到了具有给定名字的属性，则返回该属性的值；如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性。</p>
</blockquote>
<p>&emsp;&emsp;虽然可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值。如果我们在实例中添加了一个属性，而该属性与实例原型中的一个属性同名，那我们就在实例中创建该属性，该属性将会屏蔽原型中的那个属性。来看下面的例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">Person. prototype. name=<span class="string">"Nicholas"</span>; </span><br><span class="line">Person. prototype. age=<span class="number">29</span>; </span><br><span class="line">Person. prototype. job=<span class="string">"Software Engineer"</span>; </span><br><span class="line">Person. prototype, sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">alert(this. name</span>);</span></span><br><span class="line"><span class="function">&#125;; </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">var</span> <span class="title">personl</span>=<span class="title">new</span> <span class="title">Person</span>(<span class="params"></span>);</span></span><br><span class="line"><span class="function"><span class="title">var</span> <span class="title">person2</span>=<span class="title">new</span> <span class="title">Person</span>(<span class="params"></span>);</span></span><br><span class="line"><span class="function"><span class="title">peraonl</span>.<span class="title">name</span> =<span class="title">nGreg</span>"；<span class="title">alert</span>（<span class="title">person1</span>.<span class="title">name</span>）；//"<span class="title">Greg</span>"—来自实例</span></span><br><span class="line"><span class="function"><span class="title">alert</span>（<span class="title">person2</span>.<span class="title">name</span>）；//"<span class="title">Nicholaa</span>"——来自原型</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在这个例子中，person1的name 被一个新值给屏蔽了。但无论访问person1.name还是访问person2.name都能够正常地返回值，即分别是“Greg*（来自对象实例）和“wicholas”（来自原型）。当在alert（）中访问 person1.name时，需要读取它的值，因此就会在这个实例上搜索一个名为name的属性。这个属性确实存在，于是就返回它的值而不必再搜索原型了。当以同样的方式访问 person2.name时，并没有在实例上发现该属性，因此就会继续搜索原型，结果在那里找到了name-属性。<br>&emsp;当为对象实例添加一个属性时，这个属性就会屏蔽原型对象中保存的同名属性；换句话说，添加这个属性只会阻止我们访问原型中的那个属性，但不会修改那个属性。即使将这个属性设置为nu11，也只会在实例中设置这个属性，而不会恢复其指向原型的连接。</p>
<blockquote>
<p>可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值。如果实例中添加的属性与实例原型中一样则会断开该属性指向原型的连接</p>
</blockquote>
<p>不过，使用delete 操作符则可以完全删除实例属性，从而让我们能够重新访问原型中的属性，如下所示。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name=<span class="string">"Nicholas"</span>;</span><br><span class="line">Person.prototype.age=<span class="number">29</span>;</span><br><span class="line">Person.prototype.job=<span class="string">"Software Engineer"</span>;</span><br><span class="line">Person.prototype.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert（<span class="keyword">this</span>.name）；</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> personl=<span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> pexson2=<span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">person1.name=<span class="string">"Greg"</span>;</span><br><span class="line">alert(personl.name);<span class="comment">//"Greg“——来自实例</span></span><br><span class="line">alert(person2.name);<span class="comment">//"Nicholas“——来自原型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> personl.name;</span><br><span class="line">alert(peraonl.name);<span class="comment">//"Nicholaa——来自原型</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在这个修改后的例子中，我们使用delete操作符删除了person1.name，之前它保存的“Greg”值屏蔽了同名的原型属性。把它删除以后，就恢复了对原型中name属性的连接。因此，接下来再调用person1.name时，返回的就是原型中name属性的值了。</p>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>&emsp;&emsp;ECMAScript中描述了原型链的概念，并将原型链作为实现继承的主要方法。其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。简单回顾一下构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。那么，假如我们让原型对象等于另一个类型的实例，结果会怎么样呢？显然，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立，如此层层递进，就构成了实例与原型的链条。这就是所谓原型链的基本概念。</p>
<blockquote>
<p>可以简单理解成一个环套一个环和铁链一样。第一个环里的原型对象是第二个环里的实例，第二个环里的原型对象又是第三环里的实例则一环套一环。</p>
</blockquote>
<p>&emsp;&emsp;实现原型链有一种基本模式，其代码大致如下。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>. property=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Superrype.prototype.get SuperValue=<span class="function"><span class="keyword">function</span>（）</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.property;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>（）</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.subproperty=<span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承了SuperType </span></span><br><span class="line">Subrype.prototype=newSuperlype（）;</span><br><span class="line"></span><br><span class="line">SubType.prototype.getSubValue=<span class="function"><span class="keyword">function</span>（）</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.subproperty;</span><br><span class="line">）;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance=<span class="keyword">new</span> SubType（）;</span><br><span class="line">alert（instance.getSuperValue（））;<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;以上代码定义了两个类型：Superrype和SubType。每个类型分别有一个属性和一个方法。它们的主要区别是Subrype继承了superrype，而继承是通过创建Superrype的实例，并将该实例赋给SubType.prototype实现的。实现的本质是重写原型对象，代之以一个新类型的实例。换句话说，原来存在于Superrype的实例中的所有属性和方法，现在也存在于Sublype.prototype中了。在确立了继承关系之后，我们给SubType.prototype 添加了一个方法，这样就在继承了SuperType的属性和方法的基础上又添加了一个新方法。这个例子中的实例以及构造函数和原型之间的关系如图6-4所示。<br><img src="https://img-blog.csdnimg.cn/20190420203718399.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDY4NTUw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">&emsp;&emsp;在上面的代码中，我们没有使用Subype默认提供的原型，而是给它换了一个新原型；这个新原型就是superrype的实例。于是，新原型不仅具有作为一个Superrype的实例所拥有的全部属性和方法，而且其内部还有一个指针，指向了superrype的原型。最终结果就是这样的：instance指向 Subrype的原型，subrype的原型又指向Superrype的原型。getSupervalue（）方法仍然还在SuperType.prototype中，但property 则位于SubType.prototype中。这是因为property是一个实例属性，而 getSuperValue（）则是一个原型方法。既然 SubType.prototype 现在是Superrype的实例，那么property当然就位于该实例中了。此外，要注意instance.constructor现在指向的是Supertype，这是因为原来subrype.prototype中的 constructor被重写了的缘故。<br>&emsp;&emsp;通过实现原型链，本质上扩展了本章前面介绍的原型搜索机制。读者大概还记得，当以读取模式访问一个实例属性时，首先会在实例中搜索该属性。如果没有找到该属性，则会继续搜索实例的原型。在通过原型链实现继承的情况下，搜索过程就得以沿着原型链继续向上。就拿上面的例子来说，调用instance.getSuperValue（）会经历三个搜索步骤：1）搜索实例；2）搜索Subrype.prototype；3）搜索SuperType.prototype，最后一步才会找到该方法。在找不到属性或方法的情况下，搜索过程总是要一环一环地前行到原型链末端才会停下来。</p>
<p>参考书籍：JavaScript高级程序设计（第三版）</p>
</div><div class="tags"><a href="/tags/原型/">原型</a></div><div class="post-nav"><a class="pre" href="/2019/05/10/前端需要了解的JSON---数据读取与转化/">前端需要了解的JSON---数据读取与转化</a><a class="next" href="/2019/05/10/匿名函数、自执行函数，自执行匿名函数和立即执行的函数表达式区别/">匿名函数、自执行函数，自执行匿名函数和立即执行的函数表达式区别</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://yoursite.com"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Ajax/">Ajax</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/js/">js</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/json/">json</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/get-post/" style="font-size: 15px;">_get_post</a> <a href="/tags/callback/" style="font-size: 15px;">callback</a> <a href="/tags/for-in/" style="font-size: 15px;">for in</a> <a href="/tags/闭包/" style="font-size: 15px;">闭包</a> <a href="/tags/json/" style="font-size: 15px;">json</a> <a href="/tags/匿名函数-自执行函数/" style="font-size: 15px;">匿名函数 自执行函数</a> <a href="/tags/基本类型和引用类型/" style="font-size: 15px;">基本类型和引用类型</a> <a href="/tags/定时调用和延时调用/" style="font-size: 15px;">定时调用和延时调用</a> <a href="/tags/正则表达式/" style="font-size: 15px;">正则表达式</a> <a href="/tags/原型/" style="font-size: 15px;">原型</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/06/02/for与for in的区别 - 副本/">for和for in的区别</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/10/前端需要了解的JSON---数据读取与转化/">前端需要了解的JSON---数据读取与转化</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/10/剖析js原型与原型链/">剖析js原型与原型链</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/10/匿名函数、自执行函数，自执行匿名函数和立即执行的函数表达式区别/">匿名函数、自执行函数，自执行匿名函数和立即执行的函数表达式区别</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/10/基本类型和引用类型的区别以及在内存中的分配/">基本类型和引用类型的区别以及在内存中的分配</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/10/JavaScript中的回调函数callback/">JavaScript中的回调函数callback</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/10/定时调用和延时调用用法及区别/">定时调用和延时调用用法及区别</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/10/javaScript正则表达式（内附最全的常用正则表达式）/">javaScript正则表达式（内附最全的常用正则表达式）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/10/javaScript里的闭包到底是什么？该怎么理解？/">javaScript里的闭包到底是什么？该怎么理解？</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/10/for与for in的区别/">for和for in的区别</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">OuYang'blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>